{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "contracts/Uniswap/V3-Helpers/FixedPoint96.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.4.0;\n\n/// @title FixedPoint96\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\n/// @dev Used in SqrtPriceMath.sol\nlibrary FixedPoint96 {\n    uint8 internal constant RESOLUTION = 96;\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\n}\n"
    },
    "contracts/Uniswap/V3-Helpers/FullMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0 <=0.8.24;\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    function mulDiv(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        // 512-bit multiply [prod1 prod0] = a * b\n        // Compute the product mod 2**256 and mod 2**256 - 1\n        // then use the Chinese Remainder Theorem to reconstruct\n        // the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2**256 + prod0\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(a, b, not(0))\n            prod0 := mul(a, b)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        // Handle non-overflow cases, 256 by 256 division\n        if (prod1 == 0) {\n            require(denominator > 0);\n            assembly {\n                result := div(prod0, denominator)\n            }\n            return result;\n        }\n\n        // Make sure the result is less than 2**256.\n        // Also prevents denominator == 0\n        require(denominator > prod1);\n\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0]\n        // Compute remainder using mulmod\n        uint256 remainder;\n        assembly {\n            remainder := mulmod(a, b, denominator)\n        }\n        // Subtract 256 bit number from 512 bit number\n        assembly {\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        // Factor powers of two out of denominator\n        // Compute largest power of two divisor of denominator.\n        // Always >= 1.\n        uint256 twos = (type(uint256).max - denominator + 1) & denominator;\n\n        // Divide denominator by power of two\n        assembly {\n            denominator := div(denominator, twos)\n        }\n\n        // Divide [prod1 prod0] by the factors of two\n        assembly {\n            prod0 := div(prod0, twos)\n        }\n        // Shift in bits from prod1 into prod0. For this we need\n        // to flip `twos` such that it is 2**256 / twos.\n        // If twos is zero, then it becomes one\n        assembly {\n            twos := add(div(sub(0, twos), twos), 1)\n        }\n        prod0 |= prod1 * twos;\n\n        // Invert denominator mod 2**256\n        // Now that denominator is an odd number, it has an inverse\n        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n        // Compute the inverse by starting with a seed that is correct\n        // correct for four bits. That is, denominator * inv = 1 mod 2**4\n        uint256 inv = (3 * denominator) ^ 2;\n        // Now use Newton-Raphson iteration to improve the precision.\n        // Thanks to Hensel's lifting lemma, this also works in modular\n        // arithmetic, doubling the correct bits in each step.\n        inv *= 2 - denominator * inv; // inverse mod 2**8\n        inv *= 2 - denominator * inv; // inverse mod 2**16\n        inv *= 2 - denominator * inv; // inverse mod 2**32\n        inv *= 2 - denominator * inv; // inverse mod 2**64\n        inv *= 2 - denominator * inv; // inverse mod 2**128\n        inv *= 2 - denominator * inv; // inverse mod 2**256\n\n        // Because the division is now exact we can divide by multiplying\n        // with the modular inverse of denominator. This will give us the\n        // correct result modulo 2**256. Since the precoditions guarantee\n        // that the outcome is less than 2**256, this is the final result.\n        // We don't need to compute the high bits of the result and prod1\n        // is no longer required.\n        result = prod0 * inv;\n        return result;\n    }\n\n    /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    function mulDivRoundingUp(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        result = mulDiv(a, b, denominator);\n        if (mulmod(a, b, denominator) > 0) {\n            require(result < type(uint256).max);\n            result++;\n        }\n    }\n}\n"
    },
    "contracts/Uniswap/V3-Helpers/LiquidityAmounts.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\nimport \"./FullMath.sol\";\nimport \"./FixedPoint96.sol\";\n\n/// @title Liquidity amount functions\n/// @notice Provides functions for computing liquidity amounts from token amounts and prices\nlibrary LiquidityAmounts {\n    /// @notice Downcasts uint256 to uint128\n    /// @param x The uint258 to be downcasted\n    /// @return y The passed value, downcasted to uint128\n    function toUint128(uint256 x) private pure returns (uint128 y) {\n        require((y = uint128(x)) == x);\n    }\n\n    /// @notice Computes the amount of liquidity received for a given amount of token0 and price range\n    /// @dev Calculates amount0 * (sqrt(upper) * sqrt(lower)) / (sqrt(upper) - sqrt(lower))\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n    /// @param amount0 The amount0 being sent in\n    /// @return liquidity The amount of returned liquidity\n    function getLiquidityForAmount0(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint256 amount0\n    ) internal pure returns (uint128 liquidity) {\n        if (sqrtRatioAX96 > sqrtRatioBX96)\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n        uint256 intermediate = FullMath.mulDiv(\n            sqrtRatioAX96,\n            sqrtRatioBX96,\n            FixedPoint96.Q96\n        );\n        return\n            toUint128(\n                FullMath.mulDiv(\n                    amount0,\n                    intermediate,\n                    sqrtRatioBX96 - sqrtRatioAX96\n                )\n            );\n    }\n\n    /// @notice Computes the amount of liquidity received for a given amount of token1 and price range\n    /// @dev Calculates amount1 / (sqrt(upper) - sqrt(lower)).\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n    /// @param amount1 The amount1 being sent in\n    /// @return liquidity The amount of returned liquidity\n    function getLiquidityForAmount1(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint256 amount1\n    ) internal pure returns (uint128 liquidity) {\n        if (sqrtRatioAX96 > sqrtRatioBX96)\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n        return\n            toUint128(\n                FullMath.mulDiv(\n                    amount1,\n                    FixedPoint96.Q96,\n                    sqrtRatioBX96 - sqrtRatioAX96\n                )\n            );\n    }\n\n    /// @notice Computes the maximum amount of liquidity received for a given amount of token0, token1, the current\n    /// pool prices and the prices at the tick boundaries\n    /// @param sqrtRatioX96 A sqrt price representing the current pool prices\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n    /// @param amount0 The amount of token0 being sent in\n    /// @param amount1 The amount of token1 being sent in\n    /// @return liquidity The maximum amount of liquidity received\n    function getLiquidityForAmounts(\n        uint160 sqrtRatioX96,\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint256 amount0,\n        uint256 amount1\n    ) internal pure returns (uint128 liquidity) {\n        if (sqrtRatioAX96 > sqrtRatioBX96)\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n        if (sqrtRatioX96 <= sqrtRatioAX96) {\n            liquidity = getLiquidityForAmount0(\n                sqrtRatioAX96,\n                sqrtRatioBX96,\n                amount0\n            );\n        } else if (sqrtRatioX96 < sqrtRatioBX96) {\n            uint128 liquidity0 = getLiquidityForAmount0(\n                sqrtRatioX96,\n                sqrtRatioBX96,\n                amount0\n            );\n            uint128 liquidity1 = getLiquidityForAmount1(\n                sqrtRatioAX96,\n                sqrtRatioX96,\n                amount1\n            );\n\n            liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;\n        } else {\n            liquidity = getLiquidityForAmount1(\n                sqrtRatioAX96,\n                sqrtRatioBX96,\n                amount1\n            );\n        }\n    }\n\n    /// @notice Computes the amount of token0 for a given amount of liquidity and a price range\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n    /// @param liquidity The liquidity being valued\n    /// @return amount0 The amount of token0\n    function getAmount0ForLiquidity(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint128 liquidity\n    ) internal pure returns (uint256 amount0) {\n        if (sqrtRatioAX96 > sqrtRatioBX96)\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n        return\n            FullMath.mulDiv(\n                uint256(liquidity) << FixedPoint96.RESOLUTION,\n                sqrtRatioBX96 - sqrtRatioAX96,\n                sqrtRatioBX96\n            ) / sqrtRatioAX96;\n    }\n\n    /// @notice Computes the amount of token1 for a given amount of liquidity and a price range\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n    /// @param liquidity The liquidity being valued\n    /// @return amount1 The amount of token1\n    function getAmount1ForLiquidity(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint128 liquidity\n    ) internal pure returns (uint256 amount1) {\n        if (sqrtRatioAX96 > sqrtRatioBX96)\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n        return\n            FullMath.mulDiv(\n                liquidity,\n                sqrtRatioBX96 - sqrtRatioAX96,\n                FixedPoint96.Q96\n            );\n    }\n\n    /// @notice Computes the token0 and token1 value for a given amount of liquidity, the current\n    /// pool prices and the prices at the tick boundaries\n    /// @param sqrtRatioX96 A sqrt price representing the current pool prices\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n    /// @param liquidity The liquidity being valued\n    /// @return amount0 The amount of token0\n    /// @return amount1 The amount of token1\n    function getAmountsForLiquidity(\n        uint160 sqrtRatioX96,\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint128 liquidity\n    ) internal pure returns (uint256 amount0, uint256 amount1) {\n        if (sqrtRatioAX96 > sqrtRatioBX96)\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n        if (sqrtRatioX96 <= sqrtRatioAX96) {\n            amount0 = getAmount0ForLiquidity(\n                sqrtRatioAX96,\n                sqrtRatioBX96,\n                liquidity\n            );\n        } else if (sqrtRatioX96 < sqrtRatioBX96) {\n            amount0 = getAmount0ForLiquidity(\n                sqrtRatioX96,\n                sqrtRatioBX96,\n                liquidity\n            );\n            amount1 = getAmount1ForLiquidity(\n                sqrtRatioAX96,\n                sqrtRatioX96,\n                liquidity\n            );\n        } else {\n            amount1 = getAmount1ForLiquidity(\n                sqrtRatioAX96,\n                sqrtRatioBX96,\n                liquidity\n            );\n        }\n    }\n}\n"
    },
    "contracts/Uniswap/V3-Helpers/TickMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0 <=0.8.24;\n\n/// @title Math library for computing sqrt prices from ticks and vice versa\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\n/// prices between 2**-128 and 2**128\nlibrary TickMath {\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\n    int24 internal constant MIN_TICK = -887272;\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\n    int24 internal constant MAX_TICK = -MIN_TICK;\n\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_RATIO =\n        1461446703485210103287273052203988822378723970342;\n\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\n    /// @dev Throws if |tick| > max tick\n    /// @param tick The input tick for the above formula\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\n    /// at the given tick\n    function getSqrtRatioAtTick(\n        int24 tick\n    ) internal pure returns (uint160 sqrtPriceX96) {\n        uint256 absTick = tick < 0\n            ? uint256(-int256(tick))\n            : uint256(int256(tick));\n        require(absTick <= uint256(uint24(MAX_TICK)), \"T\");\n\n        uint256 ratio = absTick & 0x1 != 0\n            ? 0xfffcb933bd6fad37aa2d162d1a594001\n            : 0x100000000000000000000000000000000;\n        if (absTick & 0x2 != 0)\n            ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n        if (absTick & 0x4 != 0)\n            ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n        if (absTick & 0x8 != 0)\n            ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n        if (absTick & 0x10 != 0)\n            ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n        if (absTick & 0x20 != 0)\n            ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n        if (absTick & 0x40 != 0)\n            ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n        if (absTick & 0x80 != 0)\n            ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n        if (absTick & 0x100 != 0)\n            ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n        if (absTick & 0x200 != 0)\n            ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n        if (absTick & 0x400 != 0)\n            ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n        if (absTick & 0x800 != 0)\n            ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n        if (absTick & 0x1000 != 0)\n            ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n        if (absTick & 0x2000 != 0)\n            ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n        if (absTick & 0x4000 != 0)\n            ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n        if (absTick & 0x8000 != 0)\n            ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n        if (absTick & 0x10000 != 0)\n            ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n        if (absTick & 0x20000 != 0)\n            ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n        if (absTick & 0x40000 != 0)\n            ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n        if (absTick & 0x80000 != 0)\n            ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n        if (tick > 0) ratio = type(uint256).max / ratio;\n\n        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n        sqrtPriceX96 = uint160(\n            (ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1)\n        );\n    }\n\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n    /// ever return.\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\n    function getTickAtSqrtRatio(\n        uint160 sqrtPriceX96\n    ) internal pure returns (int24 tick) {\n        // second inequality must be < because the price can never reach the price at the max tick\n        require(\n            sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO,\n            \"R\"\n        );\n        uint256 ratio = uint256(sqrtPriceX96) << 32;\n\n        uint256 r = ratio;\n        uint256 msb = 0;\n\n        assembly {\n            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(5, gt(r, 0xFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(4, gt(r, 0xFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(3, gt(r, 0xFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(2, gt(r, 0xF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(1, gt(r, 0x3))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := gt(r, 0x1)\n            msb := or(msb, f)\n        }\n\n        if (msb >= 128) r = ratio >> (msb - 127);\n        else r = ratio << (127 - msb);\n\n        int256 log_2 = (int256(msb) - 128) << 64;\n\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(63, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(62, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(61, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(60, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(59, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(58, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(57, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(56, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(55, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(54, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(53, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(52, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(51, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(50, f))\n        }\n\n        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\n\n        int24 tickLow = int24(\n            (log_sqrt10001 - 3402992956809132418596140100660247210) >> 128\n        );\n        int24 tickHi = int24(\n            (log_sqrt10001 + 291339464771989622907027621153398088495) >> 128\n        );\n\n        tick = tickLow == tickHi\n            ? tickLow\n            : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96\n            ? tickHi\n            : tickLow;\n    }\n}\n"
    },
    "contracts/Uniswap/V4-Core/ERC6909.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {IERC6909Claims} from \"./interfaces/external/IERC6909Claims.sol\";\n\n/// @notice Minimalist and gas efficient standard ERC6909 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC6909.sol)\n/// @dev Copied from the commit at 4b47a19038b798b4a33d9749d25e570443520647\n/// @dev This contract has been modified from the implementation at the above link.\nabstract contract ERC6909 is IERC6909Claims {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OperatorSet(address indexed owner, address indexed operator, bool approved);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id, uint256 amount);\n\n    event Transfer(address caller, address indexed from, address indexed to, uint256 indexed id, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                             ERC6909 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => mapping(address => bool)) public isOperator;\n\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\n\n    mapping(address => mapping(address => mapping(uint256 => uint256))) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC6909 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function transfer(address receiver, uint256 id, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender][id] -= amount;\n\n        balanceOf[receiver][id] += amount;\n\n        emit Transfer(msg.sender, msg.sender, receiver, id, amount);\n\n        return true;\n    }\n\n    function transferFrom(address sender, address receiver, uint256 id, uint256 amount) public virtual returns (bool) {\n        if (msg.sender != sender && !isOperator[sender][msg.sender]) {\n            uint256 allowed = allowance[sender][msg.sender][id];\n            if (allowed != type(uint256).max) allowance[sender][msg.sender][id] = allowed - amount;\n        }\n\n        balanceOf[sender][id] -= amount;\n\n        balanceOf[receiver][id] += amount;\n\n        emit Transfer(msg.sender, sender, receiver, id, amount);\n\n        return true;\n    }\n\n    function approve(address spender, uint256 id, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender][id] = amount;\n\n        emit Approval(msg.sender, spender, id, amount);\n\n        return true;\n    }\n\n    function setOperator(address operator, bool approved) public virtual returns (bool) {\n        isOperator[msg.sender][operator] = approved;\n\n        emit OperatorSet(msg.sender, operator, approved);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == 0x01ffc9a7 // ERC165 Interface ID for ERC165\n            || interfaceId == 0x0f632fb3; // ERC165 Interface ID for ERC6909\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address receiver, uint256 id, uint256 amount) internal virtual {\n        balanceOf[receiver][id] += amount;\n\n        emit Transfer(msg.sender, address(0), receiver, id, amount);\n    }\n\n    function _burn(address sender, uint256 id, uint256 amount) internal virtual {\n        balanceOf[sender][id] -= amount;\n\n        emit Transfer(msg.sender, sender, address(0), id, amount);\n    }\n}\n"
    },
    "contracts/Uniswap/V4-Core/ERC6909Claims.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {ERC6909} from \"./ERC6909.sol\";\n\n/// @notice ERC6909Claims inherits ERC6909 and implements an internal burnFrom function\nabstract contract ERC6909Claims is ERC6909 {\n    /// @notice Burn `amount` tokens of token type `id` from `from`.\n    /// @dev if sender is not `from` they must be an operator or have sufficient allowance.\n    /// @param from The address to burn tokens from.\n    /// @param id The currency to burn.\n    /// @param amount The amount to burn.\n    function _burnFrom(address from, uint256 id, uint256 amount) internal {\n        address sender = msg.sender;\n        if (from != sender && !isOperator[from][sender]) {\n            uint256 senderAllowance = allowance[from][sender][id];\n            if (senderAllowance != type(uint256).max) {\n                allowance[from][sender][id] = senderAllowance - amount;\n            }\n        }\n        _burn(from, id, amount);\n    }\n}\n"
    },
    "contracts/Uniswap/V4-Core/Fees.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.19;\n\nimport {Currency, CurrencyLibrary} from \"./types/Currency.sol\";\nimport {IProtocolFeeController} from \"./interfaces/IProtocolFeeController.sol\";\nimport {IFees} from \"./interfaces/IFees.sol\";\nimport {FeeLibrary} from \"./libraries/FeeLibrary.sol\";\nimport {Pool} from \"./libraries/Pool.sol\";\nimport {PoolKey} from \"./types/PoolKey.sol\";\nimport {Owned} from \"./Owned.sol\";\nimport {IDynamicFeeManager} from \"./interfaces/IDynamicFeeManager.sol\";\n\nabstract contract Fees is IFees, Owned {\n    using FeeLibrary for uint24;\n    using CurrencyLibrary for Currency;\n\n    uint8 public constant MIN_PROTOCOL_FEE_DENOMINATOR = 4;\n\n    // the swap fee is represented in hundredths of a bip, so the max is 100%\n    uint24 public constant MAX_SWAP_FEE = 1000000;\n\n    mapping(Currency currency => uint256) public protocolFeesAccrued;\n\n    IProtocolFeeController public protocolFeeController;\n\n    uint256 private immutable controllerGasLimit;\n\n    constructor(uint256 _controllerGasLimit) {\n        controllerGasLimit = _controllerGasLimit;\n    }\n\n    /// @notice Fetch the protocol fees for a given pool, returning false if the call fails or the returned fees are invalid.\n    /// @dev to prevent an invalid protocol fee controller from blocking pools from being initialized\n    ///      the success of this function is NOT checked on initialize and if the call fails, the protocol fees are set to 0.\n    /// @dev the success of this function must be checked when called in setProtocolFee\n    function _fetchProtocolFee(PoolKey memory key) internal returns (bool success, uint16 protocolFees) {\n        if (address(protocolFeeController) != address(0)) {\n            // note that EIP-150 mandates that calls requesting more than 63/64ths of remaining gas\n            // will be allotted no more than this amount, so controllerGasLimit must be set with this\n            // in mind.\n            if (gasleft() < controllerGasLimit) revert ProtocolFeeCannotBeFetched();\n\n            (bool _success, bytes memory _data) = address(protocolFeeController).call{gas: controllerGasLimit}(\n                abi.encodeWithSelector(IProtocolFeeController.protocolFeeForPool.selector, key)\n            );\n            // Ensure that the return data fits within a word\n            if (!_success || _data.length > 32) return (false, 0);\n\n            uint256 returnData;\n            assembly {\n                returnData := mload(add(_data, 0x20))\n            }\n            // Ensure return data does not overflow a uint16 and that the underlying fees are within bounds.\n            (success, protocolFees) = returnData == uint16(returnData) && _isFeeWithinBounds(uint16(returnData))\n                ? (true, uint16(returnData))\n                : (false, 0);\n        }\n    }\n\n    function _fetchDynamicSwapFee(PoolKey memory key) internal view returns (uint24 dynamicSwapFee) {\n        dynamicSwapFee = IDynamicFeeManager(address(key.hooks)).getFee(msg.sender, key);\n        if (dynamicSwapFee >= MAX_SWAP_FEE) revert FeeTooLarge();\n    }\n\n    function _isFeeWithinBounds(uint16 fee) internal pure returns (bool) {\n        if (fee != 0) {\n            uint16 fee0 = fee % 256;\n            uint16 fee1 = fee >> 8;\n            // The fee is specified as a denominator so it cannot be LESS than the MIN_PROTOCOL_FEE_DENOMINATOR (unless it is 0).\n            if (\n                (fee0 != 0 && fee0 < MIN_PROTOCOL_FEE_DENOMINATOR) || (fee1 != 0 && fee1 < MIN_PROTOCOL_FEE_DENOMINATOR)\n            ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function setProtocolFeeController(IProtocolFeeController controller) external onlyOwner {\n        protocolFeeController = controller;\n        emit ProtocolFeeControllerUpdated(address(controller));\n    }\n\n    function collectProtocolFees(address recipient, Currency currency, uint256 amount)\n        external\n        returns (uint256 amountCollected)\n    {\n        if (msg.sender != address(protocolFeeController)) revert InvalidCaller();\n\n        amountCollected = (amount == 0) ? protocolFeesAccrued[currency] : amount;\n        protocolFeesAccrued[currency] -= amountCollected;\n        currency.transfer(recipient, amountCollected);\n    }\n}\n"
    },
    "contracts/Uniswap/V4-Core/interfaces/callback/ILockCallback.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface ILockCallback {\n    /// @notice Called by the pool manager on `msg.sender` when a lock is acquired\n    /// @param data The data that was passed to the call to lock\n    /// @return Any data that you want to be returned from the lock call\n    function lockAcquired(bytes calldata data) external returns (bytes memory);\n}\n"
    },
    "contracts/Uniswap/V4-Core/interfaces/external/IERC20Minimal.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\n/// @title Minimal ERC20 interface for Uniswap\n/// @notice Contains a subset of the full ERC20 interface that is used in Uniswap V3\ninterface IERC20Minimal {\n    /// @notice Returns the balance of a token\n    /// @param account The account for which to look up the number of tokens it has, i.e. its balance\n    /// @return The number of tokens held by the account\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @notice Transfers the amount of token from the `msg.sender` to the recipient\n    /// @param recipient The account that will receive the amount transferred\n    /// @param amount The number of tokens to send from the sender to the recipient\n    /// @return Returns true for a successful transfer, false for an unsuccessful transfer\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /// @notice Returns the current allowance given to a spender by an owner\n    /// @param owner The account of the token owner\n    /// @param spender The account of the token spender\n    /// @return The current allowance granted by `owner` to `spender`\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /// @notice Sets the allowance of a spender from the `msg.sender` to the value `amount`\n    /// @param spender The account which will be allowed to spend a given amount of the owners tokens\n    /// @param amount The amount of tokens allowed to be used by `spender`\n    /// @return Returns true for a successful approval, false for unsuccessful\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /// @notice Transfers `amount` tokens from `sender` to `recipient` up to the allowance given to the `msg.sender`\n    /// @param sender The account from which the transfer will be initiated\n    /// @param recipient The recipient of the transfer\n    /// @param amount The amount of the transfer\n    /// @return Returns true for a successful transfer, false for unsuccessful\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /// @notice Event emitted when tokens are transferred from one address to another, either via `#transfer` or `#transferFrom`.\n    /// @param from The account from which the tokens were sent, i.e. the balance decreased\n    /// @param to The account to which the tokens were sent, i.e. the balance increased\n    /// @param value The amount of tokens that were transferred\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @notice Event emitted when the approval amount for the spender of a given owner's tokens changes.\n    /// @param owner The account that approved spending of its tokens\n    /// @param spender The account for which the spending allowance was modified\n    /// @param value The new allowance from the owner to the spender\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/Uniswap/V4-Core/interfaces/external/IERC6909Claims.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IERC6909Claims {\n    /// @notice Owner balance of an id.\n    /// @param owner The address of the owner.\n    /// @param id The id of the token.\n    /// @return amount The balance of the token.\n    function balanceOf(address owner, uint256 id) external view returns (uint256 amount);\n\n    /// @notice Spender allowance of an id.\n    /// @param owner The address of the owner.\n    /// @param spender The address of the spender.\n    /// @param id The id of the token.\n    /// @return amount The allowance of the token.\n    function allowance(address owner, address spender, uint256 id) external view returns (uint256 amount);\n\n    /// @notice Checks if a spender is approved by an owner as an operator\n    /// @param owner The address of the owner.\n    /// @param spender The address of the spender.\n    /// @return approved The approval status.\n    function isOperator(address owner, address spender) external view returns (bool approved);\n\n    /// @notice Transfers an amount of an id from the caller to a receiver.\n    /// @param receiver The address of the receiver.\n    /// @param id The id of the token.\n    /// @param amount The amount of the token.\n    function transfer(address receiver, uint256 id, uint256 amount) external returns (bool);\n\n    /// @notice Transfers an amount of an id from a sender to a receiver.\n    /// @param sender The address of the sender.\n    /// @param receiver The address of the receiver.\n    /// @param id The id of the token.\n    /// @param amount The amount of the token.\n    function transferFrom(address sender, address receiver, uint256 id, uint256 amount) external returns (bool);\n\n    /// @notice Approves an amount of an id to a spender.\n    /// @param spender The address of the spender.\n    /// @param id The id of the token.\n    /// @param amount The amount of the token.\n    function approve(address spender, uint256 id, uint256 amount) external returns (bool);\n\n    /// @notice Sets or removes a spender as an operator for the caller.\n    /// @param spender The address of the spender.\n    /// @param approved The approval status.\n    function setOperator(address spender, bool approved) external returns (bool);\n}\n"
    },
    "contracts/Uniswap/V4-Core/interfaces/IDynamicFeeManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {PoolKey} from \"../types/PoolKey.sol\";\nimport {IPoolManager} from \"./IPoolManager.sol\";\n\n/// @notice The dynamic fee manager determines fees for pools\n/// @dev note that this pool is only called if the PoolKey fee value is equal to the DYNAMIC_FEE magic value\ninterface IDynamicFeeManager {\n    function getFee(address sender, PoolKey calldata key) external view returns (uint24);\n}\n"
    },
    "contracts/Uniswap/V4-Core/interfaces/IFees.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {Currency} from \"../types/Currency.sol\";\n\ninterface IFees {\n    /// @notice Thrown when the protocol fee denominator is less than 4. Also thrown when the static or dynamic fee on a pool is exceeds 100%.\n    error FeeTooLarge();\n    /// @notice Thrown when not enough gas is provided to look up the protocol fee\n    error ProtocolFeeCannotBeFetched();\n    /// @notice Thrown when the call to fetch the protocol fee reverts or returns invalid data.\n    error ProtocolFeeControllerCallFailedOrInvalidResult();\n    /// @notice Thrown when a pool does not have a dynamic fee.\n    error FeeNotDynamic();\n\n    event ProtocolFeeControllerUpdated(address protocolFeeController);\n\n    /// @notice Returns the minimum denominator for the protocol fee, which restricts it to a maximum of 25%\n    function MIN_PROTOCOL_FEE_DENOMINATOR() external view returns (uint8);\n\n    /// @notice Given a currency address, returns the protocol fees accrued in that currency\n    function protocolFeesAccrued(Currency) external view returns (uint256);\n}\n"
    },
    "contracts/Uniswap/V4-Core/interfaces/IHooks.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {PoolKey} from \"../types/PoolKey.sol\";\nimport {BalanceDelta} from \"../types/BalanceDelta.sol\";\nimport {IPoolManager} from \"./IPoolManager.sol\";\n\n/// @notice The PoolManager contract decides whether to invoke specific hooks by inspecting the leading bits\n/// of the hooks contract address. For example, a 1 bit in the first bit of the address will\n/// cause the 'before swap' hook to be invoked. See the Hooks library for the full spec.\n/// @dev Should only be callable by the v4 PoolManager.\ninterface IHooks {\n    /// @notice The hook called before the state of a pool is initialized\n    /// @param sender The initial msg.sender for the initialize call\n    /// @param key The key for the pool being initialized\n    /// @param sqrtPriceX96 The sqrt(price) of the pool as a Q64.96\n    /// @param hookData Arbitrary data handed into the PoolManager by the initializer to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function beforeInitialize(address sender, PoolKey calldata key, uint160 sqrtPriceX96, bytes calldata hookData)\n        external\n        returns (bytes4);\n\n    /// @notice The hook called after the state of a pool is initialized\n    /// @param sender The initial msg.sender for the initialize call\n    /// @param key The key for the pool being initialized\n    /// @param sqrtPriceX96 The sqrt(price) of the pool as a Q64.96\n    /// @param tick The current tick after the state of a pool is initialized\n    /// @param hookData Arbitrary data handed into the PoolManager by the initializer to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function afterInitialize(\n        address sender,\n        PoolKey calldata key,\n        uint160 sqrtPriceX96,\n        int24 tick,\n        bytes calldata hookData\n    ) external returns (bytes4);\n\n    /// @notice The hook called before liquidity is added\n    /// @param sender The initial msg.sender for the add liquidity call\n    /// @param key The key for the pool\n    /// @param params The parameters for adding liquidity\n    /// @param hookData Arbitrary data handed into the PoolManager by the liquidty provider to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function beforeAddLiquidity(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.ModifyLiquidityParams calldata params,\n        bytes calldata hookData\n    ) external returns (bytes4);\n\n    /// @notice The hook called after liquidity is added\n    /// @param sender The initial msg.sender for the add liquidity call\n    /// @param key The key for the pool\n    /// @param params The parameters for adding liquidity\n    /// @param hookData Arbitrary data handed into the PoolManager by the liquidty provider to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function afterAddLiquidity(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.ModifyLiquidityParams calldata params,\n        BalanceDelta delta,\n        bytes calldata hookData\n    ) external returns (bytes4);\n\n    /// @notice The hook called before liquidity is removed\n    /// @param sender The initial msg.sender for the remove liquidity call\n    /// @param key The key for the pool\n    /// @param params The parameters for removing liquidity\n    /// @param hookData Arbitrary data handed into the PoolManager by the liquidty provider to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function beforeRemoveLiquidity(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.ModifyLiquidityParams calldata params,\n        bytes calldata hookData\n    ) external returns (bytes4);\n\n    /// @notice The hook called after liquidity is removed\n    /// @param sender The initial msg.sender for the remove liquidity call\n    /// @param key The key for the pool\n    /// @param params The parameters for removing liquidity\n    /// @param hookData Arbitrary data handed into the PoolManager by the liquidty provider to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function afterRemoveLiquidity(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.ModifyLiquidityParams calldata params,\n        BalanceDelta delta,\n        bytes calldata hookData\n    ) external returns (bytes4);\n\n    /// @notice The hook called before a swap\n    /// @param sender The initial msg.sender for the swap call\n    /// @param key The key for the pool\n    /// @param params The parameters for the swap\n    /// @param hookData Arbitrary data handed into the PoolManager by the swapper to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function beforeSwap(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata params,\n        bytes calldata hookData\n    ) external returns (bytes4);\n\n    /// @notice The hook called after a swap\n    /// @param sender The initial msg.sender for the swap call\n    /// @param key The key for the pool\n    /// @param params The parameters for the swap\n    /// @param delta The amount owed to the locker (positive) or owed to the pool (negative)\n    /// @param hookData Arbitrary data handed into the PoolManager by the swapper to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function afterSwap(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata params,\n        BalanceDelta delta,\n        bytes calldata hookData\n    ) external returns (bytes4);\n\n    /// @notice The hook called before donate\n    /// @param sender The initial msg.sender for the donate call\n    /// @param key The key for the pool\n    /// @param amount0 The amount of token0 being donated\n    /// @param amount1 The amount of token1 being donated\n    /// @param hookData Arbitrary data handed into the PoolManager by the donor to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function beforeDonate(\n        address sender,\n        PoolKey calldata key,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata hookData\n    ) external returns (bytes4);\n\n    /// @notice The hook called after donate\n    /// @param sender The initial msg.sender for the donate call\n    /// @param key The key for the pool\n    /// @param amount0 The amount of token0 being donated\n    /// @param amount1 The amount of token1 being donated\n    /// @param hookData Arbitrary data handed into the PoolManager by the donor to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function afterDonate(\n        address sender,\n        PoolKey calldata key,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata hookData\n    ) external returns (bytes4);\n}\n"
    },
    "contracts/Uniswap/V4-Core/interfaces/IPoolManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {Currency} from \"../types/Currency.sol\";\nimport {PoolKey} from \"../types/PoolKey.sol\";\nimport {Pool} from \"../libraries/Pool.sol\";\nimport {IHooks} from \"./IHooks.sol\";\nimport {IERC6909Claims} from \"./external/IERC6909Claims.sol\";\nimport {IFees} from \"./IFees.sol\";\nimport {BalanceDelta} from \"../types/BalanceDelta.sol\";\nimport {PoolId} from \"../types/PoolId.sol\";\nimport {Position} from \"../libraries/Position.sol\";\n\ninterface IPoolManager is IFees, IERC6909Claims {\n    /// @notice Thrown when currencies touched has exceeded max of 256\n    error MaxCurrenciesTouched();\n\n    /// @notice Thrown when a currency is not netted out after a lock\n    error CurrencyNotSettled();\n\n    /// @notice Thrown when trying to interact with a non-initialized pool\n    error PoolNotInitialized();\n\n    /// @notice Thrown when lock is called, but a lock is already open\n    error AlreadyLocked();\n\n    /// @notice Thrown when a function is called outside of a lock\n    error ManagerNotLocked();\n\n    /// @notice The ERC1155 being deposited is not the Uniswap ERC1155\n    error NotPoolManagerToken();\n\n    /// @notice Pools are limited to type(int16).max tickSpacing in #initialize, to prevent overflow\n    error TickSpacingTooLarge();\n    /// @notice Pools must have a positive non-zero tickSpacing passed to #initialize\n    error TickSpacingTooSmall();\n\n    /// @notice PoolKey must have currencies where address(currency0) < address(currency1)\n    error CurrenciesOutOfOrderOrEqual();\n\n    /// @notice Emitted when a new pool is initialized\n    /// @param id The abi encoded hash of the pool key struct for the new pool\n    /// @param currency0 The first currency of the pool by address sort order\n    /// @param currency1 The second currency of the pool by address sort order\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\n    /// @param hooks The hooks contract address for the pool, or address(0) if none\n    event Initialize(\n        PoolId indexed id,\n        Currency indexed currency0,\n        Currency indexed currency1,\n        uint24 fee,\n        int24 tickSpacing,\n        IHooks hooks\n    );\n\n    /// @notice Emitted when a liquidity position is modified\n    /// @param id The abi encoded hash of the pool key struct for the pool that was modified\n    /// @param sender The address that modified the pool\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param liquidityDelta The amount of liquidity that was added or removed\n    event ModifyLiquidity(\n        PoolId indexed id,\n        address indexed sender,\n        int24 tickLower,\n        int24 tickUpper,\n        int256 liquidityDelta\n    );\n\n    /// @notice Emitted for swaps between currency0 and currency1\n    /// @param id The abi encoded hash of the pool key struct for the pool that was modified\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param amount0 The delta of the currency0 balance of the pool\n    /// @param amount1 The delta of the currency1 balance of the pool\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n    /// @param liquidity The liquidity of the pool after the swap\n    /// @param tick The log base 1.0001 of the price of the pool after the swap\n    event Swap(\n        PoolId indexed id,\n        address indexed sender,\n        int128 amount0,\n        int128 amount1,\n        uint160 sqrtPriceX96,\n        uint128 liquidity,\n        int24 tick,\n        uint24 fee\n    );\n\n    event ProtocolFeeUpdated(PoolId indexed id, uint16 protocolFee);\n\n    event DynamicSwapFeeUpdated(PoolId indexed id, uint24 dynamicSwapFee);\n\n    /// @notice Returns the constant representing the maximum tickSpacing for an initialized pool key\n    function MAX_TICK_SPACING() external view returns (int24);\n\n    /// @notice Returns the constant representing the minimum tickSpacing for an initialized pool key\n    function MIN_TICK_SPACING() external view returns (int24);\n\n    /// @notice Get the current value in slot0 of the given pool\n    function getSlot0(\n        PoolId id\n    )\n        external\n        view\n        returns (uint160 sqrtPriceX96, int24 tick, uint16 protocolFee);\n\n    /// @notice Get the current value of liquidity of the given pool\n    function getLiquidity(PoolId id) external view returns (uint128 liquidity);\n\n    /// @notice Get the current value of liquidity for the specified pool and position\n    function getLiquidity(\n        PoolId id,\n        address owner,\n        int24 tickLower,\n        int24 tickUpper\n    ) external view returns (uint128 liquidity);\n\n    /// @notice Getter for TickInfo for the given poolId and tick\n    function getPoolTickInfo(\n        PoolId id,\n        int24 tick\n    ) external view returns (Pool.TickInfo memory);\n\n    /// @notice Getter for the bitmap given the poolId and word position\n    function getPoolBitmapInfo(\n        PoolId id,\n        int16 word\n    ) external view returns (uint256 tickBitmap);\n\n    /// @notice Get the position struct for a specified pool and position\n    function getPosition(\n        PoolId id,\n        address owner,\n        int24 tickLower,\n        int24 tickUpper\n    ) external view returns (Position.Info memory position);\n\n    /// @notice Returns the reserves for a given ERC20 currency\n    function reservesOf(Currency currency) external view returns (uint256);\n\n    /// @notice Returns the locker of the pool\n    function getLocker() external view returns (address locker);\n\n    /// @notice Returns the number of nonzero deltas open on the PoolManager that must be zerod by the close of the initial lock.\n    function getLockNonzeroDeltaCount()\n        external\n        view\n        returns (uint256 _nonzeroDeltaCount);\n\n    /// @notice Initialize the state for a given pool ID\n    function initialize(\n        PoolKey memory key,\n        uint160 sqrtPriceX96,\n        bytes calldata hookData\n    ) external returns (int24 tick);\n\n    /// @notice Get the current delta for a locker in the given currency\n    /// @param locker The address of the locker\n    /// @param currency The currency for which to lookup the delta\n    function currencyDelta(\n        address locker,\n        Currency currency\n    ) external view returns (int256);\n\n    /// @notice All operations go through this function\n    /// @param data Any data to pass to the callback, via `ILockCallback(msg.sender).lockAcquired(data)`\n    /// @return The data returned by the call to `ILockCallback(msg.sender).lockAcquired(data)`\n    function lock(bytes calldata data) external payable returns (bytes memory);\n\n    struct ModifyLiquidityParams {\n        // the lower and upper tick of the position\n        int24 tickLower;\n        int24 tickUpper;\n        // how to modify the liquidity\n        int256 liquidityDelta;\n    }\n\n    /// @notice Modify the liquidity for the given pool\n    /// @dev Poke by calling with a zero liquidityDelta\n    /// @param key The pool to modify liquidity in\n    /// @param params The parameters for modifying the liquidity\n    /// @param hookData Any data to pass to the callback, via `ILockCallback(msg.sender).lockAcquired(data)`\n    /// @return delta The balance delta of the liquidity\n    function modifyLiquidity(\n        PoolKey memory key,\n        ModifyLiquidityParams memory params,\n        bytes calldata hookData\n    ) external returns (BalanceDelta);\n\n    struct SwapParams {\n        bool zeroForOne;\n        int256 amountSpecified;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swap against the given pool\n    function swap(\n        PoolKey memory key,\n        SwapParams memory params,\n        bytes calldata hookData\n    ) external returns (BalanceDelta);\n\n    /// @notice Donate the given currency amounts to the pool with the given pool key\n    function donate(\n        PoolKey memory key,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata hookData\n    ) external returns (BalanceDelta);\n\n    /// @notice Called by the user to net out some value owed to the user\n    /// @dev Can also be used as a mechanism for _free_ flash loans\n    function take(Currency currency, address to, uint256 amount) external;\n\n    /// @notice Called by the user to move value into ERC6909 balance\n    function mint(address to, uint256 id, uint256 amount) external;\n\n    /// @notice Called by the user to move value from ERC6909 balance\n    function burn(address from, uint256 id, uint256 amount) external;\n\n    /// @notice Called by the user to pay what is owed\n    function settle(Currency token) external payable returns (uint256 paid);\n\n    /// @notice Sets the protocol's swap fee for the given pool\n    /// Protocol fees are always a portion of the LP swap fee that is owed. If that fee is 0, no protocol fees will accrue even if it is set to > 0.\n    function setProtocolFee(PoolKey memory key) external;\n\n    /// @notice Updates the pools swap fees for the a pool that has enabled dynamic swap fees.\n    function updateDynamicSwapFee(PoolKey memory key) external;\n\n    /// @notice Called by external contracts to access granular pool state\n    /// @param slot Key of slot to sload\n    /// @return value The value of the slot as bytes32\n    function extsload(bytes32 slot) external view returns (bytes32 value);\n\n    /// @notice Called by external contracts to access granular pool state\n    /// @param slot Key of slot to start sloading from\n    /// @param nSlots Number of slots to load into return value\n    /// @return value The value of the sload-ed slots concatenated as dynamic bytes\n    function extsload(\n        bytes32 slot,\n        uint256 nSlots\n    ) external view returns (bytes memory value);\n}\n"
    },
    "contracts/Uniswap/V4-Core/interfaces/IProtocolFeeController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {PoolKey} from \"../types/PoolKey.sol\";\n\ninterface IProtocolFeeController {\n    /// @notice Returns the protocol fees for a pool given the conditions of this contract\n    /// @param poolKey The pool key to identify the pool. The controller may want to use attributes on the pool\n    ///   to determine the protocol fee, hence the entire key is needed.\n    function protocolFeeForPool(PoolKey memory poolKey) external view returns (uint16);\n}\n"
    },
    "contracts/Uniswap/V4-Core/libraries/BitMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\n/// @title BitMath\n/// @dev This library provides functionality for computing bit properties of an unsigned integer\nlibrary BitMath {\n    /// @notice Returns the index of the most significant bit of the number,\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\n    /// @dev The function satisfies the property:\n    ///     x >= 2**mostSignificantBit(x) and x < 2**(mostSignificantBit(x)+1)\n    /// @param x the value for which to compute the most significant bit, must be greater than 0\n    /// @return r the index of the most significant bit\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0);\n\n        unchecked {\n            if (x >= 0x100000000000000000000000000000000) {\n                x >>= 128;\n                r += 128;\n            }\n            if (x >= 0x10000000000000000) {\n                x >>= 64;\n                r += 64;\n            }\n            if (x >= 0x100000000) {\n                x >>= 32;\n                r += 32;\n            }\n            if (x >= 0x10000) {\n                x >>= 16;\n                r += 16;\n            }\n            if (x >= 0x100) {\n                x >>= 8;\n                r += 8;\n            }\n            if (x >= 0x10) {\n                x >>= 4;\n                r += 4;\n            }\n            if (x >= 0x4) {\n                x >>= 2;\n                r += 2;\n            }\n            if (x >= 0x2) r += 1;\n        }\n    }\n\n    /// @notice Returns the index of the least significant bit of the number,\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\n    /// @dev The function satisfies the property:\n    ///     (x & 2**leastSignificantBit(x)) != 0 and (x & (2**(leastSignificantBit(x)) - 1)) == 0)\n    /// @param x the value for which to compute the least significant bit, must be greater than 0\n    /// @return r the index of the least significant bit\n    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0);\n\n        unchecked {\n            r = 255;\n            if (x & type(uint128).max > 0) {\n                r -= 128;\n            } else {\n                x >>= 128;\n            }\n            if (x & type(uint64).max > 0) {\n                r -= 64;\n            } else {\n                x >>= 64;\n            }\n            if (x & type(uint32).max > 0) {\n                r -= 32;\n            } else {\n                x >>= 32;\n            }\n            if (x & type(uint16).max > 0) {\n                r -= 16;\n            } else {\n                x >>= 16;\n            }\n            if (x & type(uint8).max > 0) {\n                r -= 8;\n            } else {\n                x >>= 8;\n            }\n            if (x & 0xf > 0) {\n                r -= 4;\n            } else {\n                x >>= 4;\n            }\n            if (x & 0x3 > 0) {\n                r -= 2;\n            } else {\n                x >>= 2;\n            }\n            if (x & 0x1 > 0) r -= 1;\n        }\n    }\n}\n"
    },
    "contracts/Uniswap/V4-Core/libraries/FeeLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\nlibrary FeeLibrary {\n    uint24 public constant STATIC_FEE_MASK = 0x0FFFFF;\n    uint24 public constant DYNAMIC_FEE_FLAG = 0x800000; // 1000\n\n    function isDynamicFee(uint24 self) internal pure returns (bool) {\n        return self & DYNAMIC_FEE_FLAG != 0;\n    }\n\n    function isStaticFeeTooLarge(uint24 self) internal pure returns (bool) {\n        return self & STATIC_FEE_MASK >= 1000000;\n    }\n\n    function getStaticFee(uint24 self) internal pure returns (uint24) {\n        return self & STATIC_FEE_MASK;\n    }\n}\n"
    },
    "contracts/Uniswap/V4-Core/libraries/FixedPoint128.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\n/// @title FixedPoint128\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\nlibrary FixedPoint128 {\n    uint256 internal constant Q128 = 0x100000000000000000000000000000000;\n}\n"
    },
    "contracts/Uniswap/V4-Core/libraries/FixedPoint96.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\n/// @title FixedPoint96\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\n/// @dev Used in SqrtPriceMath.sol\nlibrary FixedPoint96 {\n    uint8 internal constant RESOLUTION = 96;\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\n}\n"
    },
    "contracts/Uniswap/V4-Core/libraries/FullMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    function mulDiv(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = a * b\n            // Compute the product mod 2**256 and mod 2**256 - 1\n            // then use the Chinese Remainder Theorem to reconstruct\n            // the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2**256 + prod0\n            uint256 prod0 = a * b; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(a, b, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Make sure the result is less than 2**256.\n            // Also prevents denominator == 0\n            require(denominator > prod1);\n\n            // Handle non-overflow cases, 256 by 256 division\n            if (prod1 == 0) {\n                assembly {\n                    result := div(prod0, denominator)\n                }\n                return result;\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0]\n            // Compute remainder using mulmod\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(a, b, denominator)\n            }\n            // Subtract 256 bit number from 512 bit number\n            assembly {\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator\n            // Compute largest power of two divisor of denominator.\n            // Always >= 1.\n            uint256 twos = (0 - denominator) & denominator;\n            // Divide denominator by power of two\n            assembly {\n                denominator := div(denominator, twos)\n            }\n\n            // Divide [prod1 prod0] by the factors of two\n            assembly {\n                prod0 := div(prod0, twos)\n            }\n            // Shift in bits from prod1 into prod0. For this we need\n            // to flip `twos` such that it is 2**256 / twos.\n            // If twos is zero, then it becomes one\n            assembly {\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2**256\n            // Now that denominator is an odd number, it has an inverse\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n            // Compute the inverse by starting with a seed that is correct\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\n            uint256 inv = (3 * denominator) ^ 2;\n            // Now use Newton-Raphson iteration to improve the precision.\n            // Thanks to Hensel's lifting lemma, this also works in modular\n            // arithmetic, doubling the correct bits in each step.\n            inv *= 2 - denominator * inv; // inverse mod 2**8\n            inv *= 2 - denominator * inv; // inverse mod 2**16\n            inv *= 2 - denominator * inv; // inverse mod 2**32\n            inv *= 2 - denominator * inv; // inverse mod 2**64\n            inv *= 2 - denominator * inv; // inverse mod 2**128\n            inv *= 2 - denominator * inv; // inverse mod 2**256\n\n            // Because the division is now exact we can divide by multiplying\n            // with the modular inverse of denominator. This will give us the\n            // correct result modulo 2**256. Since the preconditions guarantee\n            // that the outcome is less than 2**256, this is the final result.\n            // We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inv;\n            return result;\n        }\n    }\n\n    /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    function mulDivRoundingUp(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            result = mulDiv(a, b, denominator);\n            if (mulmod(a, b, denominator) > 0) {\n                require(result < type(uint256).max);\n                result++;\n            }\n        }\n    }\n}\n"
    },
    "contracts/Uniswap/V4-Core/libraries/Hooks.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {PoolKey} from \"../types/PoolKey.sol\";\nimport {IHooks} from \"../interfaces/IHooks.sol\";\nimport {FeeLibrary} from \"./FeeLibrary.sol\";\nimport {BalanceDelta} from \"../types/BalanceDelta.sol\";\nimport {IPoolManager} from \"../interfaces/IPoolManager.sol\";\nimport {Locker} from \"./Locker.sol\";\n\n/// @notice V4 decides whether to invoke specific hooks by inspecting the leading bits of the address that\n/// the hooks contract is deployed to.\n/// For example, a hooks contract deployed to address: 0x9000000000000000000000000000000000000000\n/// has leading bits '1001' which would cause the 'before initialize' and 'after add liquidity' hooks to be used.\nlibrary Hooks {\n    using FeeLibrary for uint24;\n    using Hooks for IHooks;\n\n    uint256 internal constant BEFORE_INITIALIZE_FLAG = 1 << 159; //1\n    uint256 internal constant AFTER_INITIALIZE_FLAG = 1 << 158; //2\n    uint256 internal constant BEFORE_ADD_LIQUIDITY_FLAG = 1 << 157; //3\n    uint256 internal constant AFTER_ADD_LIQUIDITY_FLAG = 1 << 156; //4\n    uint256 internal constant BEFORE_REMOVE_LIQUIDITY_FLAG = 1 << 155; //5\n    uint256 internal constant AFTER_REMOVE_LIQUIDITY_FLAG = 1 << 154; //6\n    uint256 internal constant BEFORE_SWAP_FLAG = 1 << 153; //7\n    uint256 internal constant AFTER_SWAP_FLAG = 1 << 152; //8\n    uint256 internal constant BEFORE_DONATE_FLAG = 1 << 151; //9\n    uint256 internal constant AFTER_DONATE_FLAG = 1 << 150; //10\n    uint256 internal constant NO_OP_FLAG = 1 << 149; //11\n\n    bytes4 public constant NO_OP_SELECTOR =\n        bytes4(keccak256(abi.encodePacked(\"NoOp\")));\n\n    struct Permissions {\n        bool beforeInitialize;\n        bool afterInitialize;\n        bool beforeAddLiquidity;\n        bool afterAddLiquidity;\n        bool beforeRemoveLiquidity;\n        bool afterRemoveLiquidity;\n        bool beforeSwap;\n        bool afterSwap;\n        bool beforeDonate;\n        bool afterDonate;\n        bool noOp;\n    }\n\n    /// @notice Thrown if the address will not lead to the specified hook calls being called\n    /// @param hooks The address of the hooks contract\n    error HookAddressNotValid(address hooks);\n\n    /// @notice Hook did not return its selector\n    error InvalidHookResponse();\n\n    /// @notice thrown when a hook call fails\n    error FailedHookCall();\n\n    /// @notice Utility function intended to be used in hook constructors to ensure\n    /// the deployed hooks address causes the intended hooks to be called\n    /// @param permissions The hooks that are intended to be called\n    /// @dev permissions param is memory as the function will be called from constructors\n    function validateHookPermissions(\n        IHooks self,\n        Permissions memory permissions\n    ) internal pure {\n        if (\n            permissions.beforeInitialize !=\n            self.hasPermission(BEFORE_INITIALIZE_FLAG) ||\n            permissions.afterInitialize !=\n            self.hasPermission(AFTER_INITIALIZE_FLAG) ||\n            permissions.beforeAddLiquidity !=\n            self.hasPermission(BEFORE_ADD_LIQUIDITY_FLAG) ||\n            permissions.afterAddLiquidity !=\n            self.hasPermission(AFTER_ADD_LIQUIDITY_FLAG) ||\n            permissions.beforeRemoveLiquidity !=\n            self.hasPermission(BEFORE_REMOVE_LIQUIDITY_FLAG) ||\n            permissions.afterRemoveLiquidity !=\n            self.hasPermission(AFTER_REMOVE_LIQUIDITY_FLAG) ||\n            permissions.beforeSwap != self.hasPermission(BEFORE_SWAP_FLAG) ||\n            permissions.afterSwap != self.hasPermission(AFTER_SWAP_FLAG) ||\n            permissions.beforeDonate !=\n            self.hasPermission(BEFORE_DONATE_FLAG) ||\n            permissions.afterDonate != self.hasPermission(AFTER_DONATE_FLAG) ||\n            permissions.noOp != self.hasPermission(NO_OP_FLAG)\n        ) {\n            revert HookAddressNotValid(address(self));\n        }\n    }\n\n    /// @notice Ensures that the hook address includes at least one hook flag or dynamic fees, or is the 0 address\n    /// @param hook The hook to verify\n    function isValidHookAddress(\n        IHooks hook,\n        uint24 fee\n    ) internal pure returns (bool) {\n        // if NoOp is allowed, at least one of beforeRemoveLiquidity, beforeAddLiquidity, beforeSwap and beforeDonate should be allowed\n        if (\n            hook.hasPermission(NO_OP_FLAG) &&\n            !hook.hasPermission(BEFORE_ADD_LIQUIDITY_FLAG) &&\n            !hook.hasPermission(BEFORE_REMOVE_LIQUIDITY_FLAG) &&\n            !hook.hasPermission(BEFORE_SWAP_FLAG) &&\n            !hook.hasPermission(BEFORE_DONATE_FLAG)\n        ) {\n            return false;\n        }\n        // If there is no hook contract set, then fee cannot be dynamic\n        // If a hook contract is set, it must have at least 1 flag set, or have a dynamic fee\n        return\n            address(hook) == address(0)\n                ? !fee.isDynamicFee()\n                : (uint160(address(hook)) >= NO_OP_FLAG || fee.isDynamicFee());\n    }\n\n    /// @notice performs a hook call using the given calldata on the given hook\n    /// @return expectedSelector The selector that the hook is expected to return\n    /// @return selector The selector that the hook actually returned\n    function _callHook(\n        IHooks self,\n        bytes memory data\n    ) private returns (bytes4 expectedSelector, bytes4 selector) {\n        assembly {\n            expectedSelector := mload(add(data, 0x20))\n        }\n\n        (bool success, bytes memory result) = address(self).call(data);\n        if (!success) _revert(result);\n\n        selector = abi.decode(result, (bytes4));\n    }\n\n    /// @notice performs a hook call using the given calldata on the given hook\n    function callHook(IHooks self, bytes memory data) internal {\n        (bytes4 expectedSelector, bytes4 selector) = _callHook(self, data);\n\n        if (selector != expectedSelector) {\n            revert InvalidHookResponse();\n        }\n    }\n\n    /// @notice performs a hook call using the given calldata on the given hook\n    /// @return shouldExecute Whether the operation should be executed or nooped\n    function callHookNoopable(\n        IHooks self,\n        bytes memory data\n    ) internal returns (bool shouldExecute) {\n        (bytes4 expectedSelector, bytes4 selector) = _callHook(self, data);\n\n        if (selector == expectedSelector) {\n            shouldExecute = true;\n        } else if (\n            selector == NO_OP_SELECTOR && self.hasPermission(NO_OP_FLAG)\n        ) {\n            shouldExecute = false;\n        } else {\n            revert InvalidHookResponse();\n        }\n    }\n\n    /// @notice calls beforeInitialize hook if permissioned and validates return value\n    function beforeInitialize(\n        IHooks self,\n        PoolKey memory key,\n        uint160 sqrtPriceX96,\n        bytes calldata hookData\n    ) internal {\n        if (self.hasPermission(BEFORE_INITIALIZE_FLAG)) {\n            self.callHook(\n                abi.encodeWithSelector(\n                    IHooks.beforeInitialize.selector,\n                    msg.sender,\n                    key,\n                    sqrtPriceX96,\n                    hookData\n                )\n            );\n        }\n    }\n\n    /// @notice calls afterInitialize hook if permissioned and validates return value\n    function afterInitialize(\n        IHooks self,\n        PoolKey memory key,\n        uint160 sqrtPriceX96,\n        int24 tick,\n        bytes calldata hookData\n    ) internal {\n        if (self.hasPermission(AFTER_INITIALIZE_FLAG)) {\n            self.callHook(\n                abi.encodeWithSelector(\n                    IHooks.afterInitialize.selector,\n                    msg.sender,\n                    key,\n                    sqrtPriceX96,\n                    tick,\n                    hookData\n                )\n            );\n        }\n    }\n\n    /// @notice calls beforeModifyLiquidity hook if permissioned and validates return value\n    function beforeModifyLiquidity(\n        IHooks self,\n        PoolKey memory key,\n        IPoolManager.ModifyLiquidityParams memory params,\n        bytes calldata hookData\n    ) internal returns (bool shouldExecute) {\n        if (\n            params.liquidityDelta > 0 &&\n            key.hooks.hasPermission(BEFORE_ADD_LIQUIDITY_FLAG)\n        ) {\n            shouldExecute = self.callHookNoopable(\n                abi.encodeWithSelector(\n                    IHooks.beforeAddLiquidity.selector,\n                    msg.sender,\n                    key,\n                    params,\n                    hookData\n                )\n            );\n        } else if (\n            params.liquidityDelta <= 0 &&\n            key.hooks.hasPermission(BEFORE_REMOVE_LIQUIDITY_FLAG)\n        ) {\n            shouldExecute = self.callHookNoopable(\n                abi.encodeWithSelector(\n                    IHooks.beforeRemoveLiquidity.selector,\n                    msg.sender,\n                    key,\n                    params,\n                    hookData\n                )\n            );\n        } else {\n            shouldExecute = true;\n        }\n    }\n\n    /// @notice calls afterModifyLiquidity hook if permissioned and validates return value\n    function afterModifyLiquidity(\n        IHooks self,\n        PoolKey memory key,\n        IPoolManager.ModifyLiquidityParams memory params,\n        BalanceDelta delta,\n        bytes calldata hookData\n    ) internal {\n        if (\n            params.liquidityDelta > 0 &&\n            key.hooks.hasPermission(AFTER_ADD_LIQUIDITY_FLAG)\n        ) {\n            self.callHook(\n                abi.encodeWithSelector(\n                    IHooks.afterAddLiquidity.selector,\n                    msg.sender,\n                    key,\n                    params,\n                    delta,\n                    hookData\n                )\n            );\n        } else if (\n            params.liquidityDelta <= 0 &&\n            key.hooks.hasPermission(AFTER_REMOVE_LIQUIDITY_FLAG)\n        ) {\n            self.callHook(\n                abi.encodeWithSelector(\n                    IHooks.afterRemoveLiquidity.selector,\n                    msg.sender,\n                    key,\n                    params,\n                    delta,\n                    hookData\n                )\n            );\n        }\n    }\n\n    /// @notice calls beforeSwap hook if permissioned and validates return value\n    function beforeSwap(\n        IHooks self,\n        PoolKey memory key,\n        IPoolManager.SwapParams memory params,\n        bytes calldata hookData\n    ) internal returns (bool shouldExecute) {\n        if (key.hooks.hasPermission(BEFORE_SWAP_FLAG)) {\n            shouldExecute = self.callHookNoopable(\n                abi.encodeWithSelector(\n                    IHooks.beforeSwap.selector,\n                    msg.sender,\n                    key,\n                    params,\n                    hookData\n                )\n            );\n        } else {\n            return true;\n        }\n    }\n\n    /// @notice calls afterSwap hook if permissioned and validates return value\n    function afterSwap(\n        IHooks self,\n        PoolKey memory key,\n        IPoolManager.SwapParams memory params,\n        BalanceDelta delta,\n        bytes calldata hookData\n    ) internal {\n        if (key.hooks.hasPermission(AFTER_SWAP_FLAG)) {\n            self.callHook(\n                abi.encodeWithSelector(\n                    IHooks.afterSwap.selector,\n                    msg.sender,\n                    key,\n                    params,\n                    delta,\n                    hookData\n                )\n            );\n        }\n    }\n\n    /// @notice calls beforeDonate hook if permissioned and validates return value\n    function beforeDonate(\n        IHooks self,\n        PoolKey memory key,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata hookData\n    ) internal returns (bool shouldExecute) {\n        if (key.hooks.hasPermission(BEFORE_DONATE_FLAG)) {\n            shouldExecute = self.callHookNoopable(\n                abi.encodeWithSelector(\n                    IHooks.beforeDonate.selector,\n                    msg.sender,\n                    key,\n                    amount0,\n                    amount1,\n                    hookData\n                )\n            );\n        } else {\n            return true;\n        }\n    }\n\n    /// @notice calls afterDonate hook if permissioned and validates return value\n    function afterDonate(\n        IHooks self,\n        PoolKey memory key,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata hookData\n    ) internal {\n        if (key.hooks.hasPermission(AFTER_DONATE_FLAG)) {\n            self.callHook(\n                abi.encodeWithSelector(\n                    IHooks.afterDonate.selector,\n                    msg.sender,\n                    key,\n                    amount0,\n                    amount1,\n                    hookData\n                )\n            );\n        }\n    }\n\n    function hasPermission(\n        IHooks self,\n        uint256 flag\n    ) internal pure returns (bool) {\n        return uint256(uint160(address(self))) & flag != 0;\n    }\n\n    /// @notice bubble up revert if present. Else throw FailedHookCall\n    function _revert(bytes memory result) private pure {\n        if (result.length > 0) {\n            assembly {\n                revert(add(0x20, result), mload(result))\n            }\n        } else {\n            revert FailedHookCall();\n        }\n    }\n}\n"
    },
    "contracts/Uniswap/V4-Core/libraries/Locker.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {IHooks} from \"../interfaces/IHooks.sol\";\n\n/// @notice This is a temporary library that allows us to use transient storage (tstore/tload)\n/// for the lockers array\n/// TODO: This library can be deleted when we have the transient keyword support in solidity.\nlibrary Locker {\n    // The slot holding the locker, transiently, and the lock caller in the next slot\n    uint256 constant LOCKER_SLOT = uint256(keccak256(\"Locker\")) - 1;\n\n    /// @notice Thrown when trying to set the lock target as address(0)\n    /// we use locker==address(0) to signal that the pool is not locked\n    error InvalidLocker();\n\n    function setLocker(address locker) internal {\n        if (locker == address(0)) revert InvalidLocker();\n        uint256 slot = LOCKER_SLOT;\n\n        assembly {\n            // set the locker\n            tstore(slot, locker)\n        }\n    }\n\n    function clearLocker() internal {\n        uint256 slot = LOCKER_SLOT;\n        assembly {\n            tstore(slot, 0)\n        }\n    }\n\n    function getLocker() internal view returns (address locker) {\n        uint256 slot = LOCKER_SLOT;\n        assembly {\n            locker := tload(slot)\n        }\n    }\n\n    function isLocked() internal view returns (bool) {\n        return getLocker() != address(0);\n    }\n}\n"
    },
    "contracts/Uniswap/V4-Core/libraries/NonZeroDeltaCount.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {IHooks} from \"../interfaces/IHooks.sol\";\n\n/// @notice This is a temporary library that allows us to use transient storage (tstore/tload)\n/// for the nonzero delta count.\n/// TODO: This library can be deleted when we have the transient keyword support in solidity.\nlibrary NonZeroDeltaCount {\n    // The slot holding the number of nonzero deltas.\n    uint256 constant NONZERO_DELTA_COUNT = uint256(keccak256(\"NonzeroDeltaCount\")) - 1;\n\n    function read() internal view returns (uint256 count) {\n        uint256 slot = NONZERO_DELTA_COUNT;\n        assembly {\n            count := tload(slot)\n        }\n    }\n\n    function increment() internal {\n        uint256 slot = NONZERO_DELTA_COUNT;\n        assembly {\n            let count := tload(slot)\n            count := add(count, 1)\n            tstore(slot, count)\n        }\n    }\n\n    /// @notice Potential to underflow.\n    /// Current usage ensures this will not happen because we call decrement with known boundaries (only up to the number of times we call increment).\n    function decrement() internal {\n        uint256 slot = NONZERO_DELTA_COUNT;\n        assembly {\n            let count := tload(slot)\n            count := sub(count, 1)\n            tstore(slot, count)\n        }\n    }\n}\n"
    },
    "contracts/Uniswap/V4-Core/libraries/Pool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {SafeCast} from \"./SafeCast.sol\";\nimport {TickBitmap} from \"./TickBitmap.sol\";\nimport {Position} from \"./Position.sol\";\nimport {FullMath} from \"./FullMath.sol\";\nimport {FixedPoint128} from \"./FixedPoint128.sol\";\nimport {TickMath} from \"./TickMath.sol\";\nimport {SqrtPriceMath} from \"./SqrtPriceMath.sol\";\nimport {SwapMath} from \"./SwapMath.sol\";\nimport {BalanceDelta, toBalanceDelta} from \"../types/BalanceDelta.sol\";\n\n// import {PoolNotInitialized} from \"../interfaces/IPoolManager.sol\";\n\nlibrary Pool {\n    using SafeCast for *;\n    using TickBitmap for mapping(int16 => uint256);\n    using Position for mapping(bytes32 => Position.Info);\n    using Position for Position.Info;\n    using Pool for State;\n\n    /// @notice Thrown when tickLower is not below tickUpper\n    /// @param tickLower The invalid tickLower\n    /// @param tickUpper The invalid tickUpper\n    error TicksMisordered(int24 tickLower, int24 tickUpper);\n\n    /// @notice Thrown when tickLower is less than min tick\n    /// @param tickLower The invalid tickLower\n    error TickLowerOutOfBounds(int24 tickLower);\n\n    /// @notice Thrown when tickUpper exceeds max tick\n    /// @param tickUpper The invalid tickUpper\n    error TickUpperOutOfBounds(int24 tickUpper);\n\n    /// @notice For the tick spacing, the tick has too much liquidity\n    error TickLiquidityOverflow(int24 tick);\n\n    /// @notice Thrown when interacting with an uninitialized tick that must be initialized\n    /// @param tick The uninitialized tick\n    error TickNotInitialized(int24 tick);\n\n    /// @notice Thrown when trying to initialize an already initialized pool\n    error PoolAlreadyInitialized();\n\n    /// @notice Thrown when trying to interact with a non-initialized pool\n    error PoolNotInitialized1();\n\n    /// @notice Thrown when trying to swap amount of 0\n    error SwapAmountCannotBeZero();\n\n    /// @notice Thrown when sqrtPriceLimitX96 on a swap has already exceeded its limit\n    /// @param sqrtPriceCurrentX96 The invalid, already surpassed sqrtPriceLimitX96\n    /// @param sqrtPriceLimitX96 The surpassed price limit\n    error PriceLimitAlreadyExceeded(\n        uint160 sqrtPriceCurrentX96,\n        uint160 sqrtPriceLimitX96\n    );\n\n    /// @notice Thrown when sqrtPriceLimitX96 lies outside of valid tick/price range\n    /// @param sqrtPriceLimitX96 The invalid, out-of-bounds sqrtPriceLimitX96\n    error PriceLimitOutOfBounds(uint160 sqrtPriceLimitX96);\n\n    /// @notice Thrown by donate if there is currently 0 liquidity, since the fees will not go to any liquidity providers\n    error NoLiquidityToReceiveFees();\n\n    struct Slot0 {\n        // the current price\n        uint160 sqrtPriceX96;\n        // the current tick\n        int24 tick;\n        // protocol swap fee represented as integer denominator (1/x), taken as a % of the LP swap fee\n        // upper 8 bits are for 1->0, and the lower 8 are for 0->1\n        // the minimum permitted denominator is 4 - meaning the maximum protocol fee is 25%\n        // granularity is increments of 0.38% (100/type(uint8).max)\n        uint16 protocolFee;\n        // used for the swap fee, either static at initialize or dynamic via hook\n        uint24 swapFee;\n    }\n\n    // info stored for each initialized individual tick\n    struct TickInfo {\n        // the total position liquidity that references this tick\n        uint128 liquidityGross;\n        // amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left),\n        int128 liquidityNet;\n        // fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)\n        // only has relative meaning, not absolute — the value depends on when the tick is initialized\n        uint256 feeGrowthOutside0X128;\n        uint256 feeGrowthOutside1X128;\n    }\n\n    /// @dev The state of a pool\n    struct State {\n        Slot0 slot0;\n        uint256 feeGrowthGlobal0X128;\n        uint256 feeGrowthGlobal1X128;\n        uint128 liquidity;\n        mapping(int24 => TickInfo) ticks;\n        mapping(int16 => uint256) tickBitmap;\n        mapping(bytes32 => Position.Info) positions;\n    }\n\n    /// @dev Common checks for valid tick inputs.\n    function checkTicks(int24 tickLower, int24 tickUpper) private pure {\n        if (tickLower >= tickUpper)\n            revert TicksMisordered(tickLower, tickUpper);\n        if (tickLower < TickMath.MIN_TICK)\n            revert TickLowerOutOfBounds(tickLower);\n        if (tickUpper > TickMath.MAX_TICK)\n            revert TickUpperOutOfBounds(tickUpper);\n    }\n\n    function initialize(\n        State storage self,\n        uint160 sqrtPriceX96,\n        uint16 protocolFee,\n        uint24 swapFee\n    ) internal returns (int24 tick) {\n        if (self.slot0.sqrtPriceX96 != 0) revert PoolAlreadyInitialized();\n\n        tick = TickMath.getTickAtSqrtRatio(sqrtPriceX96);\n\n        self.slot0 = Slot0({\n            sqrtPriceX96: sqrtPriceX96,\n            tick: tick,\n            protocolFee: protocolFee,\n            swapFee: swapFee\n        });\n    }\n\n    function setProtocolFee(State storage self, uint16 protocolFee) internal {\n        if (self.isNotInitialized()) revert PoolNotInitialized1();\n\n        self.slot0.protocolFee = protocolFee;\n    }\n\n    /// @notice Only dynamic fee pools may update the swap fee.\n    function setSwapFee(State storage self, uint24 swapFee) internal {\n        if (self.isNotInitialized()) revert PoolNotInitialized1();\n        self.slot0.swapFee = swapFee;\n    }\n\n    struct ModifyPositionParams {\n        // the address that owns the position\n        address owner;\n        // the lower and upper tick of the position\n        int24 tickLower;\n        int24 tickUpper;\n        // any change in liquidity\n        int128 liquidityDelta;\n        // the spacing between ticks\n        int24 tickSpacing;\n    }\n\n    struct ModifyPositionState {\n        bool flippedLower;\n        uint128 liquidityGrossAfterLower;\n        bool flippedUpper;\n        uint128 liquidityGrossAfterUpper;\n        uint256 feeGrowthInside0X128;\n        uint256 feeGrowthInside1X128;\n    }\n\n    /// @notice Effect changes to a position in a pool\n    /// @dev PoolManager checks that the pool is initialized before calling\n    /// @param params the position details and the change to the position's liquidity to effect\n    /// @return result the deltas of the token balances of the pool\n    function modifyPosition(\n        State storage self,\n        ModifyPositionParams memory params\n    ) internal returns (BalanceDelta result) {\n        checkTicks(params.tickLower, params.tickUpper);\n\n        uint256 feesOwed0;\n        uint256 feesOwed1;\n        {\n            ModifyPositionState memory state;\n\n            // if we need to update the ticks, do it\n            if (params.liquidityDelta != 0) {\n                (\n                    state.flippedLower,\n                    state.liquidityGrossAfterLower\n                ) = updateTick(\n                    self,\n                    params.tickLower,\n                    params.liquidityDelta,\n                    false\n                );\n                (\n                    state.flippedUpper,\n                    state.liquidityGrossAfterUpper\n                ) = updateTick(\n                    self,\n                    params.tickUpper,\n                    params.liquidityDelta,\n                    true\n                );\n\n                if (params.liquidityDelta > 0) {\n                    uint128 maxLiquidityPerTick = tickSpacingToMaxLiquidityPerTick(\n                            params.tickSpacing\n                        );\n                    if (state.liquidityGrossAfterLower > maxLiquidityPerTick) {\n                        revert TickLiquidityOverflow(params.tickLower);\n                    }\n                    if (state.liquidityGrossAfterUpper > maxLiquidityPerTick) {\n                        revert TickLiquidityOverflow(params.tickUpper);\n                    }\n                }\n\n                if (state.flippedLower) {\n                    self.tickBitmap.flipTick(\n                        params.tickLower,\n                        params.tickSpacing\n                    );\n                }\n                if (state.flippedUpper) {\n                    self.tickBitmap.flipTick(\n                        params.tickUpper,\n                        params.tickSpacing\n                    );\n                }\n            }\n\n            (\n                state.feeGrowthInside0X128,\n                state.feeGrowthInside1X128\n            ) = getFeeGrowthInside(self, params.tickLower, params.tickUpper);\n\n            (feesOwed0, feesOwed1) = self\n                .positions\n                .get(params.owner, params.tickLower, params.tickUpper)\n                .update(\n                    params.liquidityDelta,\n                    state.feeGrowthInside0X128,\n                    state.feeGrowthInside1X128\n                );\n\n            // clear any tick data that is no longer needed\n            if (params.liquidityDelta < 0) {\n                if (state.flippedLower) {\n                    clearTick(self, params.tickLower);\n                }\n                if (state.flippedUpper) {\n                    clearTick(self, params.tickUpper);\n                }\n            }\n        }\n\n        if (params.liquidityDelta != 0) {\n            if (self.slot0.tick < params.tickLower) {\n                // current tick is below the passed range; liquidity can only become in range by crossing from left to\n                // right, when we'll need _more_ currency0 (it's becoming more valuable) so user must provide it\n                result =\n                    result +\n                    toBalanceDelta(\n                        SqrtPriceMath\n                            .getAmount0Delta(\n                                TickMath.getSqrtRatioAtTick(params.tickLower),\n                                TickMath.getSqrtRatioAtTick(params.tickUpper),\n                                params.liquidityDelta\n                            )\n                            .toInt128(),\n                        0\n                    );\n            } else if (self.slot0.tick < params.tickUpper) {\n                result =\n                    result +\n                    toBalanceDelta(\n                        SqrtPriceMath\n                            .getAmount0Delta(\n                                self.slot0.sqrtPriceX96,\n                                TickMath.getSqrtRatioAtTick(params.tickUpper),\n                                params.liquidityDelta\n                            )\n                            .toInt128(),\n                        SqrtPriceMath\n                            .getAmount1Delta(\n                                TickMath.getSqrtRatioAtTick(params.tickLower),\n                                self.slot0.sqrtPriceX96,\n                                params.liquidityDelta\n                            )\n                            .toInt128()\n                    );\n\n                self.liquidity = params.liquidityDelta < 0\n                    ? self.liquidity - uint128(-params.liquidityDelta)\n                    : self.liquidity + uint128(params.liquidityDelta);\n            } else {\n                // current tick is above the passed range; liquidity can only become in range by crossing from right to\n                // left, when we'll need _more_ currency1 (it's becoming more valuable) so user must provide it\n                result =\n                    result +\n                    toBalanceDelta(\n                        0,\n                        SqrtPriceMath\n                            .getAmount1Delta(\n                                TickMath.getSqrtRatioAtTick(params.tickLower),\n                                TickMath.getSqrtRatioAtTick(params.tickUpper),\n                                params.liquidityDelta\n                            )\n                            .toInt128()\n                    );\n            }\n        }\n\n        // Fees earned from LPing are removed from the pool balance.\n        result =\n            result -\n            toBalanceDelta(feesOwed0.toInt128(), feesOwed1.toInt128());\n    }\n\n    struct SwapCache {\n        // liquidity at the beginning of the swap\n        uint128 liquidityStart;\n        // the protocol fee for the input token\n        uint8 protocolFee;\n    }\n\n    // the top level state of the swap, the results of which are recorded in storage at the end\n    struct SwapState {\n        // the amount remaining to be swapped in/out of the input/output asset\n        int256 amountSpecifiedRemaining;\n        // the amount already swapped out/in of the output/input asset\n        int256 amountCalculated;\n        // current sqrt(price)\n        uint160 sqrtPriceX96;\n        // the tick associated with the current price\n        int24 tick;\n        // the global fee growth of the input token\n        uint256 feeGrowthGlobalX128;\n        // the current liquidity in range\n        uint128 liquidity;\n    }\n\n    struct StepComputations {\n        // the price at the beginning of the step\n        uint160 sqrtPriceStartX96;\n        // the next tick to swap to from the current tick in the swap direction\n        int24 tickNext;\n        // whether tickNext is initialized or not\n        bool initialized;\n        // sqrt(price) for the next tick (1/0)\n        uint160 sqrtPriceNextX96;\n        // how much is being swapped in in this step\n        uint256 amountIn;\n        // how much is being swapped out\n        uint256 amountOut;\n        // how much fee is being paid in\n        uint256 feeAmount;\n    }\n\n    struct SwapParams {\n        int24 tickSpacing;\n        bool zeroForOne;\n        int256 amountSpecified;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Executes a swap against the state, and returns the amount deltas of the pool\n    /// @dev PoolManager checks that the pool is initialized before calling\n    function swap(\n        State storage self,\n        SwapParams memory params\n    )\n        internal\n        returns (\n            BalanceDelta result,\n            uint256 feeForProtocol,\n            uint24 swapFee,\n            SwapState memory state\n        )\n    {\n        if (params.amountSpecified == 0) revert SwapAmountCannotBeZero();\n\n        Slot0 memory slot0Start = self.slot0;\n        swapFee = slot0Start.swapFee;\n        if (params.zeroForOne) {\n            if (params.sqrtPriceLimitX96 >= slot0Start.sqrtPriceX96) {\n                revert PriceLimitAlreadyExceeded(\n                    slot0Start.sqrtPriceX96,\n                    params.sqrtPriceLimitX96\n                );\n            }\n            if (params.sqrtPriceLimitX96 <= TickMath.MIN_SQRT_RATIO) {\n                revert PriceLimitOutOfBounds(params.sqrtPriceLimitX96);\n            }\n        } else {\n            if (params.sqrtPriceLimitX96 <= slot0Start.sqrtPriceX96) {\n                revert PriceLimitAlreadyExceeded(\n                    slot0Start.sqrtPriceX96,\n                    params.sqrtPriceLimitX96\n                );\n            }\n            if (params.sqrtPriceLimitX96 >= TickMath.MAX_SQRT_RATIO) {\n                revert PriceLimitOutOfBounds(params.sqrtPriceLimitX96);\n            }\n        }\n\n        SwapCache memory cache = SwapCache({\n            liquidityStart: self.liquidity,\n            protocolFee: params.zeroForOne\n                ? uint8(slot0Start.protocolFee % 256)\n                : uint8(slot0Start.protocolFee >> 8)\n        });\n\n        bool exactInput = params.amountSpecified > 0;\n\n        state = SwapState({\n            amountSpecifiedRemaining: params.amountSpecified,\n            amountCalculated: 0,\n            sqrtPriceX96: slot0Start.sqrtPriceX96,\n            tick: slot0Start.tick,\n            feeGrowthGlobalX128: params.zeroForOne\n                ? self.feeGrowthGlobal0X128\n                : self.feeGrowthGlobal1X128,\n            liquidity: cache.liquidityStart\n        });\n\n        StepComputations memory step;\n        // continue swapping as long as we haven't used the entire input/output and haven't reached the price limit\n        while (\n            state.amountSpecifiedRemaining != 0 &&\n            state.sqrtPriceX96 != params.sqrtPriceLimitX96\n        ) {\n            step.sqrtPriceStartX96 = state.sqrtPriceX96;\n\n            (step.tickNext, step.initialized) = self\n                .tickBitmap\n                .nextInitializedTickWithinOneWord(\n                    state.tick,\n                    params.tickSpacing,\n                    params.zeroForOne\n                );\n\n            // ensure that we do not overshoot the min/max tick, as the tick bitmap is not aware of these bounds\n            if (step.tickNext < TickMath.MIN_TICK) {\n                step.tickNext = TickMath.MIN_TICK;\n            } else if (step.tickNext > TickMath.MAX_TICK) {\n                step.tickNext = TickMath.MAX_TICK;\n            }\n\n            // get the price for the next tick\n            step.sqrtPriceNextX96 = TickMath.getSqrtRatioAtTick(step.tickNext);\n\n            // compute values to swap to the target tick, price limit, or point where input/output amount is exhausted\n            (\n                state.sqrtPriceX96,\n                step.amountIn,\n                step.amountOut,\n                step.feeAmount\n            ) = SwapMath.computeSwapStep(\n                state.sqrtPriceX96,\n                (\n                    params.zeroForOne\n                        ? step.sqrtPriceNextX96 < params.sqrtPriceLimitX96\n                        : step.sqrtPriceNextX96 > params.sqrtPriceLimitX96\n                )\n                    ? params.sqrtPriceLimitX96\n                    : step.sqrtPriceNextX96,\n                state.liquidity,\n                state.amountSpecifiedRemaining,\n                swapFee\n            );\n\n            if (exactInput) {\n                // safe because we test that amountSpecified > amountIn + feeAmount in SwapMath\n                unchecked {\n                    state.amountSpecifiedRemaining -= (step.amountIn +\n                        step.feeAmount).toInt256();\n                }\n                state.amountCalculated =\n                    state.amountCalculated -\n                    step.amountOut.toInt256();\n            } else {\n                unchecked {\n                    state.amountSpecifiedRemaining += step.amountOut.toInt256();\n                }\n                state.amountCalculated =\n                    state.amountCalculated +\n                    (step.amountIn + step.feeAmount).toInt256();\n            }\n\n            // if the protocol fee is on, calculate how much is owed, decrement feeAmount, and increment protocolFee\n            if (cache.protocolFee > 0) {\n                // A: calculate the amount of the fee that should go to the protocol\n                uint256 delta = step.feeAmount / cache.protocolFee;\n                // A: subtract it from the regular fee and add it to the protocol fee\n                unchecked {\n                    step.feeAmount -= delta;\n                    feeForProtocol += delta;\n                }\n            }\n\n            // update global fee tracker\n            if (state.liquidity > 0) {\n                unchecked {\n                    state.feeGrowthGlobalX128 += FullMath.mulDiv(\n                        step.feeAmount,\n                        FixedPoint128.Q128,\n                        state.liquidity\n                    );\n                }\n            }\n\n            // shift tick if we reached the next price\n            if (state.sqrtPriceX96 == step.sqrtPriceNextX96) {\n                // if the tick is initialized, run the tick transition\n                if (step.initialized) {\n                    int128 liquidityNet = Pool.crossTick(\n                        self,\n                        step.tickNext,\n                        (\n                            params.zeroForOne\n                                ? state.feeGrowthGlobalX128\n                                : self.feeGrowthGlobal0X128\n                        ),\n                        (\n                            params.zeroForOne\n                                ? self.feeGrowthGlobal1X128\n                                : state.feeGrowthGlobalX128\n                        )\n                    );\n                    // if we're moving leftward, we interpret liquidityNet as the opposite sign\n                    // safe because liquidityNet cannot be type(int128).min\n                    unchecked {\n                        if (params.zeroForOne) liquidityNet = -liquidityNet;\n                    }\n\n                    state.liquidity = liquidityNet < 0\n                        ? state.liquidity - uint128(-liquidityNet)\n                        : state.liquidity + uint128(liquidityNet);\n                }\n\n                unchecked {\n                    state.tick = params.zeroForOne\n                        ? step.tickNext - 1\n                        : step.tickNext;\n                }\n            } else if (state.sqrtPriceX96 != step.sqrtPriceStartX96) {\n                // recompute unless we're on a lower tick boundary (i.e. already transitioned ticks), and haven't moved\n                state.tick = TickMath.getTickAtSqrtRatio(state.sqrtPriceX96);\n            }\n        }\n\n        (self.slot0.sqrtPriceX96, self.slot0.tick) = (\n            state.sqrtPriceX96,\n            state.tick\n        );\n\n        // update liquidity if it changed\n        if (cache.liquidityStart != state.liquidity)\n            self.liquidity = state.liquidity;\n\n        // update fee growth global\n        if (params.zeroForOne) {\n            self.feeGrowthGlobal0X128 = state.feeGrowthGlobalX128;\n        } else {\n            self.feeGrowthGlobal1X128 = state.feeGrowthGlobalX128;\n        }\n\n        unchecked {\n            if (params.zeroForOne == exactInput) {\n                result = toBalanceDelta(\n                    (params.amountSpecified - state.amountSpecifiedRemaining)\n                        .toInt128(),\n                    state.amountCalculated.toInt128()\n                );\n            } else {\n                result = toBalanceDelta(\n                    state.amountCalculated.toInt128(),\n                    (params.amountSpecified - state.amountSpecifiedRemaining)\n                        .toInt128()\n                );\n            }\n        }\n    }\n\n    /// @notice Donates the given amount of currency0 and currency1 to the pool\n    function donate(\n        State storage state,\n        uint256 amount0,\n        uint256 amount1\n    ) internal returns (BalanceDelta delta) {\n        if (state.liquidity == 0) revert NoLiquidityToReceiveFees();\n        delta = toBalanceDelta(amount0.toInt128(), amount1.toInt128());\n        unchecked {\n            if (amount0 > 0) {\n                state.feeGrowthGlobal0X128 += FullMath.mulDiv(\n                    amount0,\n                    FixedPoint128.Q128,\n                    state.liquidity\n                );\n            }\n            if (amount1 > 0) {\n                state.feeGrowthGlobal1X128 += FullMath.mulDiv(\n                    amount1,\n                    FixedPoint128.Q128,\n                    state.liquidity\n                );\n            }\n        }\n    }\n\n    /// @notice Retrieves fee growth data\n    /// @param self The Pool state struct\n    /// @param tickLower The lower tick boundary of the position\n    /// @param tickUpper The upper tick boundary of the position\n    /// @return feeGrowthInside0X128 The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries\n    /// @return feeGrowthInside1X128 The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries\n    function getFeeGrowthInside(\n        State storage self,\n        int24 tickLower,\n        int24 tickUpper\n    )\n        internal\n        view\n        returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128)\n    {\n        TickInfo storage lower = self.ticks[tickLower];\n        TickInfo storage upper = self.ticks[tickUpper];\n        int24 tickCurrent = self.slot0.tick;\n\n        unchecked {\n            if (tickCurrent < tickLower) {\n                feeGrowthInside0X128 =\n                    lower.feeGrowthOutside0X128 -\n                    upper.feeGrowthOutside0X128;\n                feeGrowthInside1X128 =\n                    lower.feeGrowthOutside1X128 -\n                    upper.feeGrowthOutside1X128;\n            } else if (tickCurrent >= tickUpper) {\n                feeGrowthInside0X128 =\n                    upper.feeGrowthOutside0X128 -\n                    lower.feeGrowthOutside0X128;\n                feeGrowthInside1X128 =\n                    upper.feeGrowthOutside1X128 -\n                    lower.feeGrowthOutside1X128;\n            } else {\n                feeGrowthInside0X128 =\n                    self.feeGrowthGlobal0X128 -\n                    lower.feeGrowthOutside0X128 -\n                    upper.feeGrowthOutside0X128;\n                feeGrowthInside1X128 =\n                    self.feeGrowthGlobal1X128 -\n                    lower.feeGrowthOutside1X128 -\n                    upper.feeGrowthOutside1X128;\n            }\n        }\n    }\n\n    /// @notice Updates a tick and returns true if the tick was flipped from initialized to uninitialized, or vice versa\n    /// @param self The mapping containing all tick information for initialized ticks\n    /// @param tick The tick that will be updated\n    /// @param liquidityDelta A new amount of liquidity to be added (subtracted) when tick is crossed from left to right (right to left)\n    /// @param upper true for updating a position's upper tick, or false for updating a position's lower tick\n    /// @return flipped Whether the tick was flipped from initialized to uninitialized, or vice versa\n    /// @return liquidityGrossAfter The total amount of  liquidity for all positions that references the tick after the update\n    function updateTick(\n        State storage self,\n        int24 tick,\n        int128 liquidityDelta,\n        bool upper\n    ) internal returns (bool flipped, uint128 liquidityGrossAfter) {\n        TickInfo storage info = self.ticks[tick];\n\n        uint128 liquidityGrossBefore;\n        int128 liquidityNetBefore;\n        assembly {\n            // load first slot of info which contains liquidityGross and liquidityNet packed\n            // where the top 128 bits are liquidityNet and the bottom 128 bits are liquidityGross\n            let liquidity := sload(info.slot)\n            // slice off top 128 bits of liquidity (liquidityNet) to get just liquidityGross\n            liquidityGrossBefore := shr(128, shl(128, liquidity))\n            // shift right 128 bits to get just liquidityNet\n            liquidityNetBefore := shr(128, liquidity)\n        }\n\n        liquidityGrossAfter = liquidityDelta < 0\n            ? liquidityGrossBefore - uint128(-liquidityDelta)\n            : liquidityGrossBefore + uint128(liquidityDelta);\n\n        flipped = (liquidityGrossAfter == 0) != (liquidityGrossBefore == 0);\n\n        if (liquidityGrossBefore == 0) {\n            // by convention, we assume that all growth before a tick was initialized happened _below_ the tick\n            if (tick <= self.slot0.tick) {\n                info.feeGrowthOutside0X128 = self.feeGrowthGlobal0X128;\n                info.feeGrowthOutside1X128 = self.feeGrowthGlobal1X128;\n            }\n        }\n\n        // when the lower (upper) tick is crossed left to right (right to left), liquidity must be added (removed)\n        int128 liquidityNet = upper\n            ? liquidityNetBefore - liquidityDelta\n            : liquidityNetBefore + liquidityDelta;\n        assembly {\n            // liquidityGrossAfter and liquidityNet are packed in the first slot of `info`\n            // So we can store them with a single sstore by packing them ourselves first\n            sstore(\n                info.slot,\n                // bitwise OR to pack liquidityGrossAfter and liquidityNet\n                or(\n                    // liquidityGross is in the low bits, upper bits are already 0\n                    liquidityGrossAfter,\n                    // shift liquidityNet to take the upper bits and lower bits get filled with 0\n                    shl(128, liquidityNet)\n                )\n            )\n        }\n    }\n\n    /// @notice Derives max liquidity per tick from given tick spacing\n    /// @dev Executed within the pool constructor\n    /// @param tickSpacing The amount of required tick separation, realized in multiples of `tickSpacing`\n    ///     e.g., a tickSpacing of 3 requires ticks to be initialized every 3rd tick i.e., ..., -6, -3, 0, 3, 6, ...\n    /// @return The max liquidity per tick\n    function tickSpacingToMaxLiquidityPerTick(\n        int24 tickSpacing\n    ) internal pure returns (uint128) {\n        unchecked {\n            return\n                uint128(\n                    (type(uint128).max * uint256(int256(tickSpacing))) /\n                        uint256(int256(TickMath.MAX_TICK * 2 + tickSpacing))\n                );\n        }\n    }\n\n    function isNotInitialized(State storage self) internal view returns (bool) {\n        return self.slot0.sqrtPriceX96 == 0;\n    }\n\n    /// @notice Clears tick data\n    /// @param self The mapping containing all initialized tick information for initialized ticks\n    /// @param tick The tick that will be cleared\n    function clearTick(State storage self, int24 tick) internal {\n        delete self.ticks[tick];\n    }\n\n    /// @notice Transitions to next tick as needed by price movement\n    /// @param self The Pool state struct\n    /// @param tick The destination tick of the transition\n    /// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0\n    /// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1\n    /// @return liquidityNet The amount of liquidity added (subtracted) when tick is crossed from left to right (right to left)\n    function crossTick(\n        State storage self,\n        int24 tick,\n        uint256 feeGrowthGlobal0X128,\n        uint256 feeGrowthGlobal1X128\n    ) internal returns (int128 liquidityNet) {\n        unchecked {\n            TickInfo storage info = self.ticks[tick];\n            info.feeGrowthOutside0X128 =\n                feeGrowthGlobal0X128 -\n                info.feeGrowthOutside0X128;\n            info.feeGrowthOutside1X128 =\n                feeGrowthGlobal1X128 -\n                info.feeGrowthOutside1X128;\n            liquidityNet = info.liquidityNet;\n        }\n    }\n}\n"
    },
    "contracts/Uniswap/V4-Core/libraries/PoolGetters.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {Pool} from \"./Pool.sol\";\n\nlibrary PoolGetters {\n    function getPoolTickInfo(Pool.State storage pool, int24 tick) internal view returns (Pool.TickInfo memory) {\n        return pool.ticks[tick];\n    }\n\n    function getPoolBitmapInfo(Pool.State storage pool, int16 word) internal view returns (uint256 tickBitmap) {\n        return pool.tickBitmap[word];\n    }\n}\n"
    },
    "contracts/Uniswap/V4-Core/libraries/Position.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {FullMath} from \"./FullMath.sol\";\nimport {FixedPoint128} from \"./FixedPoint128.sol\";\n\n/// @title Position\n/// @notice Positions represent an owner address' liquidity between a lower and upper tick boundary\n/// @dev Positions store additional state for tracking fees owed to the position\nlibrary Position {\n    /// @notice Cannot update a position with no liquidity\n    error CannotUpdateEmptyPosition();\n\n    // info stored for each user's position\n    struct Info {\n        // the amount of liquidity owned by this position\n        uint128 liquidity;\n        // fee growth per unit of liquidity as of the last update to liquidity or fees owed\n        uint256 feeGrowthInside0LastX128;\n        uint256 feeGrowthInside1LastX128;\n    }\n\n    /// @notice Returns the Info struct of a position, given an owner and position boundaries\n    /// @param self The mapping containing all user positions\n    /// @param owner The address of the position owner\n    /// @param tickLower The lower tick boundary of the position\n    /// @param tickUpper The upper tick boundary of the position\n    /// @return position The position info struct of the given owners' position\n    function get(mapping(bytes32 => Info) storage self, address owner, int24 tickLower, int24 tickUpper)\n        internal\n        view\n        returns (Position.Info storage position)\n    {\n        position = self[keccak256(abi.encodePacked(owner, tickLower, tickUpper))];\n    }\n\n    /// @notice Credits accumulated fees to a user's position\n    /// @param self The individual position to update\n    /// @param liquidityDelta The change in pool liquidity as a result of the position update\n    /// @param feeGrowthInside0X128 The all-time fee growth in currency0, per unit of liquidity, inside the position's tick boundaries\n    /// @param feeGrowthInside1X128 The all-time fee growth in currency1, per unit of liquidity, inside the position's tick boundaries\n    /// @return feesOwed0 The amount of currency0 owed to the position owner\n    /// @return feesOwed1 The amount of currency1 owed to the position owner\n    function update(\n        Info storage self,\n        int128 liquidityDelta,\n        uint256 feeGrowthInside0X128,\n        uint256 feeGrowthInside1X128\n    ) internal returns (uint256 feesOwed0, uint256 feesOwed1) {\n        Info memory _self = self;\n\n        uint128 liquidityNext;\n        if (liquidityDelta == 0) {\n            if (_self.liquidity == 0) revert CannotUpdateEmptyPosition(); // disallow pokes for 0 liquidity positions\n            liquidityNext = _self.liquidity;\n        } else {\n            liquidityNext = liquidityDelta < 0\n                ? _self.liquidity - uint128(-liquidityDelta)\n                : _self.liquidity + uint128(liquidityDelta);\n        }\n\n        // calculate accumulated fees. overflow in the subtraction of fee growth is expected\n        unchecked {\n            feesOwed0 = FullMath.mulDiv(\n                feeGrowthInside0X128 - _self.feeGrowthInside0LastX128, _self.liquidity, FixedPoint128.Q128\n            );\n            feesOwed1 = FullMath.mulDiv(\n                feeGrowthInside1X128 - _self.feeGrowthInside1LastX128, _self.liquidity, FixedPoint128.Q128\n            );\n        }\n\n        // update the position\n        if (liquidityDelta != 0) self.liquidity = liquidityNext;\n        self.feeGrowthInside0LastX128 = feeGrowthInside0X128;\n        self.feeGrowthInside1LastX128 = feeGrowthInside1X128;\n    }\n}\n"
    },
    "contracts/Uniswap/V4-Core/libraries/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\n/// @title Safe casting methods\n/// @notice Contains methods for safely casting between types\nlibrary SafeCast {\n    error SafeCastOverflow();\n\n    /// @notice Cast a uint256 to a uint160, revert on overflow\n    /// @param y The uint256 to be downcasted\n    /// @return z The downcasted integer, now type uint160\n    function toUint160(uint256 y) internal pure returns (uint160 z) {\n        z = uint160(y);\n        if (z != y) revert SafeCastOverflow();\n    }\n\n    /// @notice Cast a int256 to a int128, revert on overflow or underflow\n    /// @param y The int256 to be downcasted\n    /// @return z The downcasted integer, now type int128\n    function toInt128(int256 y) internal pure returns (int128 z) {\n        z = int128(y);\n        if (z != y) revert SafeCastOverflow();\n    }\n\n    /// @notice Cast a uint256 to a int256, revert on overflow\n    /// @param y The uint256 to be casted\n    /// @return z The casted integer, now type int256\n    function toInt256(uint256 y) internal pure returns (int256 z) {\n        if (y > uint256(type(int256).max)) revert SafeCastOverflow();\n        z = int256(y);\n    }\n\n    /// @notice Cast a uint256 to a int128, revert on overflow\n    /// @param y The uint256 to be downcasted\n    /// @return z The downcasted integer, now type int128\n    function toInt128(uint256 y) internal pure returns (int128 z) {\n        if (y > uint128(type(int128).max)) revert SafeCastOverflow();\n        z = int128(int256(y));\n    }\n}\n"
    },
    "contracts/Uniswap/V4-Core/libraries/SqrtPriceMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\nimport {SafeCast} from \"./SafeCast.sol\";\n\nimport {FullMath} from \"./FullMath.sol\";\nimport {UnsafeMath} from \"./UnsafeMath.sol\";\nimport {FixedPoint96} from \"./FixedPoint96.sol\";\n\n/// @title Functions based on Q64.96 sqrt price and liquidity\n/// @notice Contains the math that uses square root of price as a Q64.96 and liquidity to compute deltas\nlibrary SqrtPriceMath {\n    using SafeCast for uint256;\n\n    error InvalidPriceOrLiquidity();\n    error InvalidPrice();\n    error NotEnoughLiquidity();\n    error PriceOverflow();\n\n    /// @notice Gets the next sqrt price given a delta of currency0\n    /// @dev Always rounds up, because in the exact output case (increasing price) we need to move the price at least\n    /// far enough to get the desired output amount, and in the exact input case (decreasing price) we need to move the\n    /// price less in order to not send too much output.\n    /// The most precise formula for this is liquidity * sqrtPX96 / (liquidity +- amount * sqrtPX96),\n    /// if this is impossible because of overflow, we calculate liquidity / (liquidity / sqrtPX96 +- amount).\n    /// @param sqrtPX96 The starting price, i.e. before accounting for the currency0 delta\n    /// @param liquidity The amount of usable liquidity\n    /// @param amount How much of currency0 to add or remove from virtual reserves\n    /// @param add Whether to add or remove the amount of currency0\n    /// @return The price after adding or removing amount, depending on add\n    function getNextSqrtPriceFromAmount0RoundingUp(uint160 sqrtPX96, uint128 liquidity, uint256 amount, bool add)\n        internal\n        pure\n        returns (uint160)\n    {\n        // we short circuit amount == 0 because the result is otherwise not guaranteed to equal the input price\n        if (amount == 0) return sqrtPX96;\n        uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;\n\n        if (add) {\n            unchecked {\n                uint256 product = amount * sqrtPX96;\n                if (product / amount == sqrtPX96) {\n                    uint256 denominator = numerator1 + product;\n                    if (denominator >= numerator1) {\n                        // always fits in 160 bits\n                        return uint160(FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator));\n                    }\n                }\n            }\n            // denominator is checked for overflow\n            return uint160(UnsafeMath.divRoundingUp(numerator1, (numerator1 / sqrtPX96) + amount));\n        } else {\n            unchecked {\n                uint256 product = amount * sqrtPX96;\n                // if the product overflows, we know the denominator underflows\n                // in addition, we must check that the denominator does not underflow\n                if (product / amount != sqrtPX96 || numerator1 <= product) revert PriceOverflow();\n                uint256 denominator = numerator1 - product;\n                return FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator).toUint160();\n            }\n        }\n    }\n\n    /// @notice Gets the next sqrt price given a delta of currency1\n    /// @dev Always rounds down, because in the exact output case (decreasing price) we need to move the price at least\n    /// far enough to get the desired output amount, and in the exact input case (increasing price) we need to move the\n    /// price less in order to not send too much output.\n    /// The formula we compute is within <1 wei of the lossless version: sqrtPX96 +- amount / liquidity\n    /// @param sqrtPX96 The starting price, i.e., before accounting for the currency1 delta\n    /// @param liquidity The amount of usable liquidity\n    /// @param amount How much of currency1 to add, or remove, from virtual reserves\n    /// @param add Whether to add, or remove, the amount of currency1\n    /// @return The price after adding or removing `amount`\n    function getNextSqrtPriceFromAmount1RoundingDown(uint160 sqrtPX96, uint128 liquidity, uint256 amount, bool add)\n        internal\n        pure\n        returns (uint160)\n    {\n        // if we're adding (subtracting), rounding down requires rounding the quotient down (up)\n        // in both cases, avoid a mulDiv for most inputs\n        if (add) {\n            uint256 quotient = (\n                amount <= type(uint160).max\n                    ? (amount << FixedPoint96.RESOLUTION) / liquidity\n                    : FullMath.mulDiv(amount, FixedPoint96.Q96, liquidity)\n            );\n\n            return (uint256(sqrtPX96) + quotient).toUint160();\n        } else {\n            uint256 quotient = (\n                amount <= type(uint160).max\n                    ? UnsafeMath.divRoundingUp(amount << FixedPoint96.RESOLUTION, liquidity)\n                    : FullMath.mulDivRoundingUp(amount, FixedPoint96.Q96, liquidity)\n            );\n\n            if (sqrtPX96 <= quotient) revert NotEnoughLiquidity();\n            // always fits 160 bits\n            unchecked {\n                return uint160(sqrtPX96 - quotient);\n            }\n        }\n    }\n\n    /// @notice Gets the next sqrt price given an input amount of currency0 or currency1\n    /// @dev Throws if price or liquidity are 0, or if the next price is out of bounds\n    /// @param sqrtPX96 The starting price, i.e., before accounting for the input amount\n    /// @param liquidity The amount of usable liquidity\n    /// @param amountIn How much of currency0, or currency1, is being swapped in\n    /// @param zeroForOne Whether the amount in is currency0 or currency1\n    /// @return sqrtQX96 The price after adding the input amount to currency0 or currency1\n    function getNextSqrtPriceFromInput(uint160 sqrtPX96, uint128 liquidity, uint256 amountIn, bool zeroForOne)\n        internal\n        pure\n        returns (uint160 sqrtQX96)\n    {\n        if (sqrtPX96 == 0 || liquidity == 0) revert InvalidPriceOrLiquidity();\n\n        // round to make sure that we don't pass the target price\n        return zeroForOne\n            ? getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountIn, true)\n            : getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountIn, true);\n    }\n\n    /// @notice Gets the next sqrt price given an output amount of currency0 or currency1\n    /// @dev Throws if price or liquidity are 0 or the next price is out of bounds\n    /// @param sqrtPX96 The starting price before accounting for the output amount\n    /// @param liquidity The amount of usable liquidity\n    /// @param amountOut How much of currency0, or currency1, is being swapped out\n    /// @param zeroForOne Whether the amount out is currency0 or currency1\n    /// @return sqrtQX96 The price after removing the output amount of currency0 or currency1\n    function getNextSqrtPriceFromOutput(uint160 sqrtPX96, uint128 liquidity, uint256 amountOut, bool zeroForOne)\n        internal\n        pure\n        returns (uint160 sqrtQX96)\n    {\n        if (sqrtPX96 == 0 || liquidity == 0) revert InvalidPriceOrLiquidity();\n\n        // round to make sure that we pass the target price\n        return zeroForOne\n            ? getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountOut, false)\n            : getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountOut, false);\n    }\n\n    /// @notice Gets the amount0 delta between two prices\n    /// @dev Calculates liquidity / sqrt(lower) - liquidity / sqrt(upper),\n    /// i.e. liquidity * (sqrt(upper) - sqrt(lower)) / (sqrt(upper) * sqrt(lower))\n    /// @param sqrtRatioAX96 A sqrt price\n    /// @param sqrtRatioBX96 Another sqrt price\n    /// @param liquidity The amount of usable liquidity\n    /// @param roundUp Whether to round the amount up or down\n    /// @return amount0 Amount of currency0 required to cover a position of size liquidity between the two passed prices\n    function getAmount0Delta(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity, bool roundUp)\n        internal\n        pure\n        returns (uint256 amount0)\n    {\n        unchecked {\n            if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n            uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;\n            uint256 numerator2 = sqrtRatioBX96 - sqrtRatioAX96;\n\n            if (sqrtRatioAX96 == 0) revert InvalidPrice();\n\n            return roundUp\n                ? UnsafeMath.divRoundingUp(FullMath.mulDivRoundingUp(numerator1, numerator2, sqrtRatioBX96), sqrtRatioAX96)\n                : FullMath.mulDiv(numerator1, numerator2, sqrtRatioBX96) / sqrtRatioAX96;\n        }\n    }\n\n    /// @notice Gets the amount1 delta between two prices\n    /// @dev Calculates liquidity * (sqrt(upper) - sqrt(lower))\n    /// @param sqrtRatioAX96 A sqrt price\n    /// @param sqrtRatioBX96 Another sqrt price\n    /// @param liquidity The amount of usable liquidity\n    /// @param roundUp Whether to round the amount up, or down\n    /// @return amount1 Amount of currency1 required to cover a position of size liquidity between the two passed prices\n    function getAmount1Delta(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity, bool roundUp)\n        internal\n        pure\n        returns (uint256 amount1)\n    {\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n        return roundUp\n            ? FullMath.mulDivRoundingUp(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96)\n            : FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);\n    }\n\n    /// @notice Helper that gets signed currency0 delta\n    /// @param sqrtRatioAX96 A sqrt price\n    /// @param sqrtRatioBX96 Another sqrt price\n    /// @param liquidity The change in liquidity for which to compute the amount0 delta\n    /// @return amount0 Amount of currency0 corresponding to the passed liquidityDelta between the two prices\n    function getAmount0Delta(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, int128 liquidity)\n        internal\n        pure\n        returns (int256 amount0)\n    {\n        unchecked {\n            return liquidity < 0\n                ? -getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()\n                : getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();\n        }\n    }\n\n    /// @notice Helper that gets signed currency1 delta\n    /// @param sqrtRatioAX96 A sqrt price\n    /// @param sqrtRatioBX96 Another sqrt price\n    /// @param liquidity The change in liquidity for which to compute the amount1 delta\n    /// @return amount1 Amount of currency1 corresponding to the passed liquidityDelta between the two prices\n    function getAmount1Delta(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, int128 liquidity)\n        internal\n        pure\n        returns (int256 amount1)\n    {\n        unchecked {\n            return liquidity < 0\n                ? -getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()\n                : getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();\n        }\n    }\n}\n"
    },
    "contracts/Uniswap/V4-Core/libraries/SwapMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\nimport {FullMath} from \"./FullMath.sol\";\nimport {SqrtPriceMath} from \"./SqrtPriceMath.sol\";\n\n/// @title Computes the result of a swap within ticks\n/// @notice Contains methods for computing the result of a swap within a single tick price range, i.e., a single tick.\nlibrary SwapMath {\n    /// @notice Computes the result of swapping some amount in, or amount out, given the parameters of the swap\n    /// @dev The fee, plus the amount in, will never exceed the amount remaining if the swap's `amountSpecified` is positive\n    /// @param sqrtRatioCurrentX96 The current sqrt price of the pool\n    /// @param sqrtRatioTargetX96 The price that cannot be exceeded, from which the direction of the swap is inferred\n    /// @param liquidity The usable liquidity\n    /// @param amountRemaining How much input or output amount is remaining to be swapped in/out\n    /// @param feePips The fee taken from the input amount, expressed in hundredths of a bip\n    /// @return sqrtRatioNextX96 The price after swapping the amount in/out, not to exceed the price target\n    /// @return amountIn The amount to be swapped in, of either currency0 or currency1, based on the direction of the swap\n    /// @return amountOut The amount to be received, of either currency0 or currency1, based on the direction of the swap\n    /// @return feeAmount The amount of input that will be taken as a fee\n    function computeSwapStep(\n        uint160 sqrtRatioCurrentX96,\n        uint160 sqrtRatioTargetX96,\n        uint128 liquidity,\n        int256 amountRemaining,\n        uint24 feePips\n    ) internal pure returns (uint160 sqrtRatioNextX96, uint256 amountIn, uint256 amountOut, uint256 feeAmount) {\n        unchecked {\n            bool zeroForOne = sqrtRatioCurrentX96 >= sqrtRatioTargetX96;\n            bool exactIn = amountRemaining >= 0;\n\n            if (exactIn) {\n                uint256 amountRemainingLessFee = FullMath.mulDiv(uint256(amountRemaining), 1e6 - feePips, 1e6);\n                amountIn = zeroForOne\n                    ? SqrtPriceMath.getAmount0Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, true)\n                    : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, true);\n                if (amountRemainingLessFee >= amountIn) {\n                    sqrtRatioNextX96 = sqrtRatioTargetX96;\n                } else {\n                    sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromInput(\n                        sqrtRatioCurrentX96, liquidity, amountRemainingLessFee, zeroForOne\n                    );\n                }\n            } else {\n                amountOut = zeroForOne\n                    ? SqrtPriceMath.getAmount1Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, false)\n                    : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, false);\n                if (uint256(-amountRemaining) >= amountOut) {\n                    sqrtRatioNextX96 = sqrtRatioTargetX96;\n                } else {\n                    sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromOutput(\n                        sqrtRatioCurrentX96, liquidity, uint256(-amountRemaining), zeroForOne\n                    );\n                }\n            }\n\n            bool max = sqrtRatioTargetX96 == sqrtRatioNextX96;\n\n            // get the input/output amounts\n            if (zeroForOne) {\n                amountIn = max && exactIn\n                    ? amountIn\n                    : SqrtPriceMath.getAmount0Delta(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, true);\n                amountOut = max && !exactIn\n                    ? amountOut\n                    : SqrtPriceMath.getAmount1Delta(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, false);\n            } else {\n                amountIn = max && exactIn\n                    ? amountIn\n                    : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioNextX96, liquidity, true);\n                amountOut = max && !exactIn\n                    ? amountOut\n                    : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioNextX96, liquidity, false);\n            }\n\n            // cap the output amount to not exceed the remaining output amount\n            if (!exactIn && amountOut > uint256(-amountRemaining)) {\n                amountOut = uint256(-amountRemaining);\n            }\n\n            if (exactIn && sqrtRatioNextX96 != sqrtRatioTargetX96) {\n                // we didn't reach the target, so take the remainder of the maximum input as fee\n                feeAmount = uint256(amountRemaining) - amountIn;\n            } else {\n                feeAmount = FullMath.mulDivRoundingUp(amountIn, feePips, 1e6 - feePips);\n            }\n        }\n    }\n}\n"
    },
    "contracts/Uniswap/V4-Core/libraries/TickBitmap.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\nimport {BitMath} from \"./BitMath.sol\";\n\n/// @title Packed tick initialized state library\n/// @notice Stores a packed mapping of tick index to its initialized state\n/// @dev The mapping uses int16 for keys since ticks are represented as int24 and there are 256 (2^8) values per word.\nlibrary TickBitmap {\n    /// @notice Thrown when the tick is not enumerated by the tick spacing\n    /// @param tick the invalid tick\n    /// @param tickSpacing The tick spacing of the pool\n    error TickMisaligned(int24 tick, int24 tickSpacing);\n\n    /// @notice Computes the position in the mapping where the initialized bit for a tick lives\n    /// @param tick The tick for which to compute the position\n    /// @return wordPos The key in the mapping containing the word in which the bit is stored\n    /// @return bitPos The bit position in the word where the flag is stored\n    function position(int24 tick) internal pure returns (int16 wordPos, uint8 bitPos) {\n        unchecked {\n            wordPos = int16(tick >> 8);\n            bitPos = uint8(int8(tick % 256));\n        }\n    }\n\n    /// @notice Flips the initialized state for a given tick from false to true, or vice versa\n    /// @param self The mapping in which to flip the tick\n    /// @param tick The tick to flip\n    /// @param tickSpacing The spacing between usable ticks\n    function flipTick(mapping(int16 => uint256) storage self, int24 tick, int24 tickSpacing) internal {\n        unchecked {\n            if (tick % tickSpacing != 0) revert TickMisaligned(tick, tickSpacing); // ensure that the tick is spaced\n            (int16 wordPos, uint8 bitPos) = position(tick / tickSpacing);\n            uint256 mask = 1 << bitPos;\n            self[wordPos] ^= mask;\n        }\n    }\n\n    /// @notice Returns the next initialized tick contained in the same word (or adjacent word) as the tick that is either\n    /// to the left (less than or equal to) or right (greater than) of the given tick\n    /// @param self The mapping in which to compute the next initialized tick\n    /// @param tick The starting tick\n    /// @param tickSpacing The spacing between usable ticks\n    /// @param lte Whether to search for the next initialized tick to the left (less than or equal to the starting tick)\n    /// @return next The next initialized or uninitialized tick up to 256 ticks away from the current tick\n    /// @return initialized Whether the next tick is initialized, as the function only searches within up to 256 ticks\n    function nextInitializedTickWithinOneWord(\n        mapping(int16 => uint256) storage self,\n        int24 tick,\n        int24 tickSpacing,\n        bool lte\n    ) internal view returns (int24 next, bool initialized) {\n        unchecked {\n            int24 compressed = tick / tickSpacing;\n            if (tick < 0 && tick % tickSpacing != 0) compressed--; // round towards negative infinity\n\n            if (lte) {\n                (int16 wordPos, uint8 bitPos) = position(compressed);\n                // all the 1s at or to the right of the current bitPos\n                uint256 mask = (1 << bitPos) - 1 + (1 << bitPos);\n                uint256 masked = self[wordPos] & mask;\n\n                // if there are no initialized ticks to the right of or at the current tick, return rightmost in the word\n                initialized = masked != 0;\n                // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick\n                next = initialized\n                    ? (compressed - int24(uint24(bitPos - BitMath.mostSignificantBit(masked)))) * tickSpacing\n                    : (compressed - int24(uint24(bitPos))) * tickSpacing;\n            } else {\n                // start from the word of the next tick, since the current tick state doesn't matter\n                (int16 wordPos, uint8 bitPos) = position(compressed + 1);\n                // all the 1s at or to the left of the bitPos\n                uint256 mask = ~((1 << bitPos) - 1);\n                uint256 masked = self[wordPos] & mask;\n\n                // if there are no initialized ticks to the left of the current tick, return leftmost in the word\n                initialized = masked != 0;\n                // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick\n                next = initialized\n                    ? (compressed + 1 + int24(uint24(BitMath.leastSignificantBit(masked) - bitPos))) * tickSpacing\n                    : (compressed + 1 + int24(uint24(type(uint8).max - bitPos))) * tickSpacing;\n            }\n        }\n    }\n}\n"
    },
    "contracts/Uniswap/V4-Core/libraries/TickMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\n/// @title Math library for computing sqrt prices from ticks and vice versa\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\n/// prices between 2**-128 and 2**128\nlibrary TickMath {\n    /// @notice Thrown when the tick passed to #getSqrtRatioAtTick is not between MIN_TICK and MAX_TICK\n    error InvalidTick();\n    /// @notice Thrown when the ratio passed to #getTickAtSqrtRatio does not correspond to a price between MIN_TICK and MAX_TICK\n    error InvalidSqrtRatio();\n\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\n    int24 internal constant MIN_TICK = -887272;\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\n    int24 internal constant MAX_TICK = -MIN_TICK;\n\n    /// @dev The minimum tick spacing value drawn from the range of type int16 that is greater than 0, i.e. min from the range [1, 32767]\n    int24 internal constant MIN_TICK_SPACING = 1;\n    /// @dev The maximum tick spacing value drawn from the range of type int16, i.e. max from the range [1, 32767]\n    int24 internal constant MAX_TICK_SPACING = type(int16).max;\n\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n\n    /// @notice Given a tickSpacing, compute the maximum usable tick\n    function maxUsableTick(int24 tickSpacing) internal pure returns (int24) {\n        unchecked {\n            return (MAX_TICK / tickSpacing) * tickSpacing;\n        }\n    }\n\n    /// @notice Given a tickSpacing, compute the minimum usable tick\n    function minUsableTick(int24 tickSpacing) internal pure returns (int24) {\n        unchecked {\n            return (MIN_TICK / tickSpacing) * tickSpacing;\n        }\n    }\n\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\n    /// @dev Throws if |tick| > max tick\n    /// @param tick The input tick for the above formula\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (currency1/currency0)\n    /// at the given tick\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n        unchecked {\n            uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\n            if (absTick > uint256(int256(MAX_TICK))) revert InvalidTick();\n\n            uint256 ratio =\n                absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\n            if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n            if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n            if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n            if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n            if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n            if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n            if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n            if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n            if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n            if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n            if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n            if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n            if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n            if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n            if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n            if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n            if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n            if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n            if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n            if (tick > 0) ratio = type(uint256).max / ratio;\n\n            // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n            // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n            // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n            sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\n        }\n    }\n\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n    /// ever return.\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n        unchecked {\n            // second inequality must be < because the price can never reach the price at the max tick\n            if (sqrtPriceX96 < MIN_SQRT_RATIO || sqrtPriceX96 >= MAX_SQRT_RATIO) revert InvalidSqrtRatio();\n            uint256 ratio = uint256(sqrtPriceX96) << 32;\n\n            uint256 r = ratio;\n            uint256 msb = 0;\n\n            assembly {\n                let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(5, gt(r, 0xFFFFFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(4, gt(r, 0xFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(3, gt(r, 0xFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(2, gt(r, 0xF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(1, gt(r, 0x3))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := gt(r, 0x1)\n                msb := or(msb, f)\n            }\n\n            if (msb >= 128) r = ratio >> (msb - 127);\n            else r = ratio << (127 - msb);\n\n            int256 log_2 = (int256(msb) - 128) << 64;\n\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(63, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(62, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(61, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(60, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(59, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(58, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(57, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(56, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(55, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(54, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(53, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(52, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(51, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(50, f))\n            }\n\n            int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\n\n            int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\n            int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\n\n            tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\n        }\n    }\n}\n"
    },
    "contracts/Uniswap/V4-Core/libraries/UnsafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\n/// @title Math functions that do not check inputs or outputs\n/// @notice Contains methods that perform common math functions but do not do any overflow or underflow checks\nlibrary UnsafeMath {\n    /// @notice Returns ceil(x / y)\n    /// @dev division by 0 has unspecified behavior, and must be checked externally\n    /// @param x The dividend\n    /// @param y The divisor\n    /// @return z The quotient, ceil(x / y)\n    function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            assembly {\n                z := add(div(x, y), gt(mod(x, y), 0))\n            }\n        }\n    }\n}\n"
    },
    "contracts/Uniswap/V4-Core/NoDelegateCall.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\n/// @title Prevents delegatecall to a contract\n/// @notice Base contract that provides a modifier for preventing delegatecall to methods in a child contract\nabstract contract NoDelegateCall {\n    error DelegateCallNotAllowed();\n\n    /// @dev The original address of this contract\n    address private immutable original;\n\n    constructor() {\n        // Immutables are computed in the init code of the contract, and then inlined into the deployed bytecode.\n        // In other words, this variable won't change when it's checked at runtime.\n        original = address(this);\n    }\n\n    /// @dev Private method is used instead of inlining into modifier because modifiers are copied into each method,\n    ///     and the use of immutable means the address bytes are copied in every place the modifier is used.\n    function checkNotDelegateCall() private view {\n        if (address(this) != original) revert DelegateCallNotAllowed();\n    }\n\n    /// @notice Prevents delegatecall into the modified method\n    modifier noDelegateCall() {\n        checkNotDelegateCall();\n        _;\n    }\n}\n"
    },
    "contracts/Uniswap/V4-Core/Owned.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\ncontract Owned {\n    address public owner;\n    bytes12 private STORAGE_PLACEHOLDER;\n\n    error InvalidCaller();\n\n    /// @notice Emitted when the owner of the factory is changed\n    /// @param oldOwner The owner before the owner was changed\n    /// @param newOwner The owner after the owner was changed\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\n\n    modifier onlyOwner() {\n        if (msg.sender != owner) revert InvalidCaller();\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n        emit OwnerChanged(address(0), msg.sender);\n    }\n\n    function setOwner(address _owner) external onlyOwner {\n        emit OwnerChanged(owner, _owner);\n        owner = _owner;\n    }\n}\n"
    },
    "contracts/Uniswap/V4-Core/PoolManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.24;\n\nimport {Hooks} from \"./libraries/Hooks.sol\";\nimport {Pool} from \"./libraries/Pool.sol\";\nimport {SafeCast} from \"./libraries/SafeCast.sol\";\nimport {Position} from \"./libraries/Position.sol\";\nimport {FeeLibrary} from \"./libraries/FeeLibrary.sol\";\nimport {Currency, CurrencyLibrary} from \"./types/Currency.sol\";\nimport {PoolKey} from \"./types/PoolKey.sol\";\nimport {TickMath} from \"./libraries/TickMath.sol\";\nimport {NoDelegateCall} from \"./NoDelegateCall.sol\";\nimport {Owned} from \"./Owned.sol\";\nimport {IHooks} from \"./interfaces/IHooks.sol\";\nimport {IDynamicFeeManager} from \"./interfaces/IDynamicFeeManager.sol\";\nimport {IPoolManager} from \"./interfaces/IPoolManager.sol\";\nimport {ILockCallback} from \"./interfaces/callback/ILockCallback.sol\";\nimport {Fees} from \"./Fees.sol\";\nimport {ERC6909Claims} from \"./ERC6909Claims.sol\";\nimport {PoolId, PoolIdLibrary} from \"./types/PoolId.sol\";\nimport {BalanceDelta, BalanceDeltaLibrary} from \"./types/BalanceDelta.sol\";\nimport {Locker} from \"./libraries/Locker.sol\";\nimport {NonZeroDeltaCount} from \"./libraries/NonZeroDeltaCount.sol\";\nimport {PoolGetters} from \"./libraries/PoolGetters.sol\";\n\n/// @notice Holds the state for all pools\ncontract PoolManager is IPoolManager, Fees, NoDelegateCall, ERC6909Claims {\n    using PoolIdLibrary for PoolKey;\n    using SafeCast for *;\n    using Pool for *;\n    using Hooks for IHooks;\n    using Position for mapping(bytes32 => Position.Info);\n    using CurrencyLibrary for Currency;\n    using FeeLibrary for uint24;\n    using PoolGetters for Pool.State;\n\n    /// @inheritdoc IPoolManager\n    int24 public constant MAX_TICK_SPACING = TickMath.MAX_TICK_SPACING;\n\n    /// @inheritdoc IPoolManager\n    int24 public constant MIN_TICK_SPACING = TickMath.MIN_TICK_SPACING;\n\n    /// @dev Represents the currencies due/owed to each locker.\n    /// Must all net to zero when the last lock is released.\n    /// TODO this needs to be transient\n    mapping(address locker => mapping(Currency currency => int256 currencyDelta))\n        public currencyDelta;\n\n    /// @inheritdoc IPoolManager\n    mapping(Currency currency => uint256) public override reservesOf;\n\n    mapping(PoolId id => Pool.State) public pools;\n\n    constructor(uint256 controllerGasLimit) Fees(controllerGasLimit) {}\n\n    /// @inheritdoc IPoolManager\n    function getSlot0(\n        PoolId id\n    )\n        external\n        view\n        override\n        returns (uint160 sqrtPriceX96, int24 tick, uint16 protocolFee)\n    {\n        Pool.Slot0 memory slot0 = pools[id].slot0;\n\n        return (slot0.sqrtPriceX96, slot0.tick, slot0.protocolFee);\n    }\n\n    /// @inheritdoc IPoolManager\n    function getLiquidity(\n        PoolId id\n    ) external view override returns (uint128 liquidity) {\n        return pools[id].liquidity;\n    }\n\n    /// @inheritdoc IPoolManager\n    function getLiquidity(\n        PoolId id,\n        address _owner,\n        int24 tickLower,\n        int24 tickUpper\n    ) external view override returns (uint128 liquidity) {\n        return pools[id].positions.get(_owner, tickLower, tickUpper).liquidity;\n    }\n\n    function getPosition(\n        PoolId id,\n        address _owner,\n        int24 tickLower,\n        int24 tickUpper\n    ) external view override returns (Position.Info memory position) {\n        return pools[id].positions.get(_owner, tickLower, tickUpper);\n    }\n\n    /// @inheritdoc IPoolManager\n    function getLocker() external view override returns (address locker) {\n        return Locker.getLocker();\n    }\n\n    /// @notice This will revert if a function is called by any address other than the current locker OR the most recently called, pre-permissioned hook.\n    modifier isLocked() {\n        if (!Locker.isLocked()) revert ManagerNotLocked();\n        _;\n    }\n\n    /// @inheritdoc IPoolManager\n    function initialize(\n        PoolKey memory key,\n        uint160 sqrtPriceX96,\n        bytes calldata hookData\n    ) external override isLocked returns (int24 tick) {\n        if (key.fee.isStaticFeeTooLarge()) revert FeeTooLarge();\n\n        // see TickBitmap.sol for overflow conditions that can arise from tick spacing being too large\n        if (key.tickSpacing > MAX_TICK_SPACING) revert TickSpacingTooLarge();\n        if (key.tickSpacing < MIN_TICK_SPACING) revert TickSpacingTooSmall();\n        if (key.currency0 >= key.currency1)\n            revert CurrenciesOutOfOrderOrEqual();\n        if (!key.hooks.isValidHookAddress(key.fee))\n            revert Hooks.HookAddressNotValid(address(key.hooks));\n\n        key.hooks.beforeInitialize(key, sqrtPriceX96, hookData);\n\n        PoolId id = key.toId();\n        (, uint16 protocolFee) = _fetchProtocolFee(key);\n        uint24 swapFee = key.fee.isDynamicFee()\n            ? _fetchDynamicSwapFee(key)\n            : key.fee.getStaticFee();\n\n        tick = pools[id].initialize(sqrtPriceX96, protocolFee, swapFee);\n\n        key.hooks.afterInitialize(key, sqrtPriceX96, tick, hookData);\n\n        // On intitalize we emit the key's fee, which tells us all fee settings a pool can have: either a static swap fee or dynamic swap fee and if the hook has enabled swap or withdraw fees.\n        emit Initialize(\n            id,\n            key.currency0,\n            key.currency1,\n            key.fee,\n            key.tickSpacing,\n            key.hooks\n        );\n    }\n\n    /// @inheritdoc IPoolManager\n    function lock(\n        bytes calldata data\n    ) external payable override returns (bytes memory result) {\n        if (Locker.isLocked()) revert AlreadyLocked();\n\n        Locker.setLocker(msg.sender);\n\n        // the caller does everything in this callback, including paying what they owe via calls to settle\n        result = ILockCallback(msg.sender).lockAcquired(data);\n\n        if (NonZeroDeltaCount.read() != 0) revert CurrencyNotSettled();\n        Locker.clearLocker();\n    }\n\n    function _accountDelta(Currency currency, int128 delta) internal {\n        if (delta == 0) return;\n\n        int256 current = currencyDelta[msg.sender][currency];\n        int256 next = current + delta;\n\n        unchecked {\n            if (next == 0) {\n                NonZeroDeltaCount.decrement();\n            } else if (current == 0) {\n                NonZeroDeltaCount.increment();\n            }\n        }\n\n        currencyDelta[msg.sender][currency] = next;\n    }\n\n    /// @dev Accumulates a balance change to a map of currency to balance changes\n    function _accountPoolBalanceDelta(\n        PoolKey memory key,\n        BalanceDelta delta\n    ) internal {\n        _accountDelta(key.currency0, delta.amount0());\n        _accountDelta(key.currency1, delta.amount1());\n    }\n\n    function _checkPoolInitialized(PoolId id) internal view {\n        if (pools[id].isNotInitialized()) revert PoolNotInitialized();\n    }\n\n    /// @inheritdoc IPoolManager\n    function modifyLiquidity(\n        PoolKey memory key,\n        IPoolManager.ModifyLiquidityParams memory params,\n        bytes calldata hookData\n    ) external override noDelegateCall isLocked returns (BalanceDelta delta) {\n        PoolId id = key.toId();\n        _checkPoolInitialized(id);\n\n        if (!key.hooks.beforeModifyLiquidity(key, params, hookData)) {\n            return BalanceDeltaLibrary.MAXIMUM_DELTA;\n        }\n\n        delta = pools[id].modifyPosition(\n            Pool.ModifyPositionParams({\n                owner: msg.sender,\n                tickLower: params.tickLower,\n                tickUpper: params.tickUpper,\n                liquidityDelta: params.liquidityDelta.toInt128(),\n                tickSpacing: key.tickSpacing\n            })\n        );\n\n        _accountPoolBalanceDelta(key, delta);\n\n        emit ModifyLiquidity(\n            id,\n            msg.sender,\n            params.tickLower,\n            params.tickUpper,\n            params.liquidityDelta\n        );\n\n        key.hooks.afterModifyLiquidity(key, params, delta, hookData);\n    }\n\n    /// @inheritdoc IPoolManager\n    function swap(\n        PoolKey memory key,\n        IPoolManager.SwapParams memory params,\n        bytes calldata hookData\n    ) external override noDelegateCall isLocked returns (BalanceDelta delta) {\n        PoolId id = key.toId();\n        _checkPoolInitialized(id);\n\n        if (!key.hooks.beforeSwap(key, params, hookData)) {\n            return BalanceDeltaLibrary.MAXIMUM_DELTA;\n        }\n\n        uint256 feeForProtocol;\n        uint24 swapFee;\n        Pool.SwapState memory state;\n        (delta, feeForProtocol, swapFee, state) = pools[id].swap(\n            Pool.SwapParams({\n                tickSpacing: key.tickSpacing,\n                zeroForOne: params.zeroForOne,\n                amountSpecified: params.amountSpecified,\n                sqrtPriceLimitX96: params.sqrtPriceLimitX96\n            })\n        );\n\n        _accountPoolBalanceDelta(key, delta);\n        // the fee is on the input currency\n\n        unchecked {\n            if (feeForProtocol > 0) {\n                protocolFeesAccrued[\n                    params.zeroForOne ? key.currency0 : key.currency1\n                ] += feeForProtocol;\n            }\n        }\n\n        emit Swap(\n            id,\n            msg.sender,\n            delta.amount0(),\n            delta.amount1(),\n            state.sqrtPriceX96,\n            state.liquidity,\n            state.tick,\n            swapFee\n        );\n\n        key.hooks.afterSwap(key, params, delta, hookData);\n    }\n\n    /// @inheritdoc IPoolManager\n    function donate(\n        PoolKey memory key,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata hookData\n    ) external override noDelegateCall isLocked returns (BalanceDelta delta) {\n        PoolId id = key.toId();\n        _checkPoolInitialized(id);\n\n        if (!key.hooks.beforeDonate(key, amount0, amount1, hookData)) {\n            return BalanceDeltaLibrary.MAXIMUM_DELTA;\n        }\n\n        delta = pools[id].donate(amount0, amount1);\n\n        _accountPoolBalanceDelta(key, delta);\n\n        key.hooks.afterDonate(key, amount0, amount1, hookData);\n    }\n\n    /// @inheritdoc IPoolManager\n    function take(\n        Currency currency,\n        address to,\n        uint256 amount\n    ) external override noDelegateCall isLocked {\n        _accountDelta(currency, amount.toInt128());\n        reservesOf[currency] -= amount;\n        currency.transfer(to, amount);\n    }\n\n    /// @inheritdoc IPoolManager\n    function settle(\n        Currency currency\n    ) external payable override noDelegateCall isLocked returns (uint256 paid) {\n        uint256 reservesBefore = reservesOf[currency];\n        reservesOf[currency] = currency.balanceOfSelf();\n        paid = reservesOf[currency] - reservesBefore;\n        // subtraction must be safe\n        _accountDelta(currency, -(paid.toInt128()));\n    }\n\n    /// @inheritdoc IPoolManager\n    function mint(\n        address to,\n        uint256 id,\n        uint256 amount\n    ) external override noDelegateCall isLocked {\n        _accountDelta(CurrencyLibrary.fromId(id), amount.toInt128());\n        _mint(to, id, amount);\n    }\n\n    /// @inheritdoc IPoolManager\n    function burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) external override noDelegateCall isLocked {\n        _accountDelta(CurrencyLibrary.fromId(id), -(amount.toInt128()));\n        _burnFrom(from, id, amount);\n    }\n\n    function setProtocolFee(PoolKey memory key) external {\n        (bool success, uint16 newProtocolFee) = _fetchProtocolFee(key);\n        if (!success) revert ProtocolFeeControllerCallFailedOrInvalidResult();\n        PoolId id = key.toId();\n        pools[id].setProtocolFee(newProtocolFee);\n        emit ProtocolFeeUpdated(id, newProtocolFee);\n    }\n\n    function updateDynamicSwapFee(PoolKey memory key) external {\n        if (key.fee.isDynamicFee()) {\n            uint24 newDynamicSwapFee = _fetchDynamicSwapFee(key);\n            PoolId id = key.toId();\n            pools[id].setSwapFee(newDynamicSwapFee);\n            emit DynamicSwapFeeUpdated(id, newDynamicSwapFee);\n        } else {\n            revert FeeNotDynamic();\n        }\n    }\n\n    function extsload(bytes32 slot) external view returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := sload(slot)\n        }\n    }\n\n    function extsload(\n        bytes32 startSlot,\n        uint256 nSlots\n    ) external view returns (bytes memory) {\n        bytes memory value = new bytes(32 * nSlots);\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {\n                let i := 0\n            } lt(i, nSlots) {\n                i := add(i, 1)\n            } {\n                mstore(add(value, mul(add(i, 1), 32)), sload(add(startSlot, i)))\n            }\n        }\n\n        return value;\n    }\n\n    function getLockNonzeroDeltaCount()\n        external\n        view\n        returns (uint256 _nonzeroDeltaCount)\n    {\n        return NonZeroDeltaCount.read();\n    }\n\n    function getPoolTickInfo(\n        PoolId id,\n        int24 tick\n    ) external view returns (Pool.TickInfo memory) {\n        return pools[id].getPoolTickInfo(tick);\n    }\n\n    function getPoolBitmapInfo(\n        PoolId id,\n        int16 word\n    ) external view returns (uint256 tickBitmap) {\n        return pools[id].getPoolBitmapInfo(word);\n    }\n\n    /// @notice receive native tokens for native pools\n    receive() external payable {}\n}\n"
    },
    "contracts/Uniswap/V4-Core/types/BalanceDelta.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ntype BalanceDelta is int256;\n\nusing {add as +, sub as -, eq as ==} for BalanceDelta global;\nusing BalanceDeltaLibrary for BalanceDelta global;\n\nfunction toBalanceDelta(int128 _amount0, int128 _amount1) pure returns (BalanceDelta balanceDelta) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        balanceDelta :=\n            or(shl(128, _amount0), and(0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff, _amount1))\n    }\n}\n\nfunction add(BalanceDelta a, BalanceDelta b) pure returns (BalanceDelta) {\n    return toBalanceDelta(a.amount0() + b.amount0(), a.amount1() + b.amount1());\n}\n\nfunction sub(BalanceDelta a, BalanceDelta b) pure returns (BalanceDelta) {\n    return toBalanceDelta(a.amount0() - b.amount0(), a.amount1() - b.amount1());\n}\n\nfunction eq(BalanceDelta a, BalanceDelta b) pure returns (bool) {\n    return a.amount0() == b.amount0() && a.amount1() == b.amount1();\n}\n\nlibrary BalanceDeltaLibrary {\n    // Sentinel return value used to signify that a NoOp occurred.\n    BalanceDelta public constant MAXIMUM_DELTA = BalanceDelta.wrap(int256(type(uint256).max));\n\n    function amount0(BalanceDelta balanceDelta) internal pure returns (int128 _amount0) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            _amount0 := shr(128, balanceDelta)\n        }\n    }\n\n    function amount1(BalanceDelta balanceDelta) internal pure returns (int128 _amount1) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            _amount1 := balanceDelta\n        }\n    }\n}\n"
    },
    "contracts/Uniswap/V4-Core/types/Currency.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {IERC20Minimal} from \"../interfaces/external/IERC20Minimal.sol\";\n\ntype Currency is address;\n\nusing {greaterThan as >, lessThan as <, greaterThanOrEqualTo as >=, equals as ==} for Currency global;\n\nfunction equals(Currency currency, Currency other) pure returns (bool) {\n    return Currency.unwrap(currency) == Currency.unwrap(other);\n}\n\nfunction greaterThan(Currency currency, Currency other) pure returns (bool) {\n    return Currency.unwrap(currency) > Currency.unwrap(other);\n}\n\nfunction lessThan(Currency currency, Currency other) pure returns (bool) {\n    return Currency.unwrap(currency) < Currency.unwrap(other);\n}\n\nfunction greaterThanOrEqualTo(Currency currency, Currency other) pure returns (bool) {\n    return Currency.unwrap(currency) >= Currency.unwrap(other);\n}\n\n/// @title CurrencyLibrary\n/// @dev This library allows for transferring and holding native tokens and ERC20 tokens\nlibrary CurrencyLibrary {\n    using CurrencyLibrary for Currency;\n\n    /// @notice Thrown when a native transfer fails\n    error NativeTransferFailed();\n\n    /// @notice Thrown when an ERC20 transfer fails\n    error ERC20TransferFailed();\n\n    Currency public constant NATIVE = Currency.wrap(address(0));\n\n    function transfer(Currency currency, address to, uint256 amount) internal {\n        // implementation from\n        // https://github.com/transmissions11/solmate/blob/e8f96f25d48fe702117ce76c79228ca4f20206cb/src/utils/SafeTransferLib.sol\n\n        bool success;\n        if (currency.isNative()) {\n            assembly {\n                // Transfer the ETH and store if it succeeded or not.\n                success := call(gas(), to, amount, 0, 0, 0, 0)\n            }\n\n            if (!success) revert NativeTransferFailed();\n        } else {\n            assembly {\n                // We'll write our calldata to this slot below, but restore it later.\n                let memPointer := mload(0x40)\n\n                // Write the abi-encoded calldata into memory, beginning with the function selector.\n                mstore(0, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n                mstore(4, to) // Append the \"to\" argument.\n                mstore(36, amount) // Append the \"amount\" argument.\n\n                success :=\n                    and(\n                        // Set success to whether the call reverted, if not we check it either\n                        // returned exactly 1 (can't just be non-zero data), or had no return data.\n                        or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                        // We use 68 because that's the total length of our calldata (4 + 32 * 2)\n                        // Counterintuitively, this call() must be positioned after the or() in the\n                        // surrounding and() because and() evaluates its arguments from right to left.\n                        call(gas(), currency, 0, 0, 68, 0, 32)\n                    )\n\n                mstore(0x60, 0) // Restore the zero slot to zero.\n                mstore(0x40, memPointer) // Restore the memPointer.\n            }\n\n            if (!success) revert ERC20TransferFailed();\n        }\n    }\n\n    function balanceOfSelf(Currency currency) internal view returns (uint256) {\n        if (currency.isNative()) {\n            return address(this).balance;\n        } else {\n            return IERC20Minimal(Currency.unwrap(currency)).balanceOf(address(this));\n        }\n    }\n\n    function balanceOf(Currency currency, address owner) internal view returns (uint256) {\n        if (currency.isNative()) {\n            return owner.balance;\n        } else {\n            return IERC20Minimal(Currency.unwrap(currency)).balanceOf(owner);\n        }\n    }\n\n    function isNative(Currency currency) internal pure returns (bool) {\n        return Currency.unwrap(currency) == Currency.unwrap(NATIVE);\n    }\n\n    function toId(Currency currency) internal pure returns (uint256) {\n        return uint160(Currency.unwrap(currency));\n    }\n\n    function fromId(uint256 id) internal pure returns (Currency) {\n        return Currency.wrap(address(uint160(id)));\n    }\n}\n"
    },
    "contracts/Uniswap/V4-Core/types/PoolId.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {PoolKey} from \"./PoolKey.sol\";\n\ntype PoolId is bytes32;\n\n/// @notice Library for computing the ID of a pool\nlibrary PoolIdLibrary {\n    function toId(PoolKey memory poolKey) internal pure returns (PoolId) {\n        return PoolId.wrap(keccak256(abi.encode(poolKey)));\n    }\n}\n"
    },
    "contracts/Uniswap/V4-Core/types/PoolKey.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {Currency} from \"./Currency.sol\";\nimport {IHooks} from \"../interfaces/IHooks.sol\";\n\n/// @notice Returns the key for identifying a pool\nstruct PoolKey {\n    /// @notice The lower currency of the pool, sorted numerically\n    Currency currency0;\n    /// @notice The higher currency of the pool, sorted numerically\n    Currency currency1;\n    /// @notice The pool swap fee, capped at 1_000_000. The upper 4 bits determine if the hook sets any fees.\n    uint24 fee;\n    /// @notice Ticks that involve positions must be a multiple of tick spacing\n    int24 tickSpacing;\n    /// @notice The hooks of the pool\n    IHooks hooks;\n}\n"
    },
    "contracts/UniswapInteract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n// make sure to update latest 'main' branch on Uniswap repository\n\nimport {IPoolManager} from \"./Uniswap/V4-Core/interfaces/IPoolManager.sol\";\nimport {BalanceDeltaLibrary, BalanceDelta} from \"./Uniswap/V4-Core/types/BalanceDelta.sol\";\n\nimport {Currency, CurrencyLibrary} from \"./Uniswap/V4-Core/types/Currency.sol\";\nimport {PoolIdLibrary, PoolId} from \"./Uniswap/V4-Core/types/PoolId.sol\";\nimport {PoolKey} from \"./Uniswap/V4-Core/types/PoolId.sol\";\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./Uniswap/V3-Helpers/TickMath.sol\";\nimport \"./Uniswap/V3-Helpers/LiquidityAmounts.sol\";\nerror SwapExpired();\nerror OnlyPoolManager();\n\nusing SafeERC20 for IERC20;\n\n//Uncomment below for console logs\nimport \"hardhat/console.sol\";\n\ncontract UniswapInteract {\n    using CurrencyLibrary for Currency;\n    IPoolManager public poolManager;\n    mapping(uint256 => uint256) actionChoice;\n    mapping(uint256 => IPoolManager.ModifyLiquidityParams) modificaitons;\n    mapping(uint256 => uint256[2]) tickBounds;\n    mapping(uint256 => IPoolManager.SwapParams) swaps;\n    mapping(uint256 => uint256[2]) donations;\n    mapping(uint256 => InitParams) inits;\n\n    struct position {\n        int24 lowerBound;\n        int24 upperBound;\n        PoolId poolID;\n    }\n\n    struct InitParams {\n        PoolKey key;\n        uint160 sqrtPrice;\n        bytes hookData;\n    }\n    mapping(address => position[]) positions;\n\n    uint256 modCounter;\n    uint256 modSwap;\n    uint256 doCount;\n    uint256 initCount;\n\n    constructor(IPoolManager _poolManager) {\n        poolManager = _poolManager;\n    }\n\n    function getID(PoolKey memory poolKey) public pure returns (PoolId) {\n        return PoolIdLibrary.toId(poolKey);\n    }\n\n    function startPool(\n        PoolKey memory key,\n        uint160 sqrtPrice,\n        bytes calldata hookData,\n        uint256 deadLine\n    ) public payable returns (int24 tick) {\n        inits[initCount] = InitParams(key, sqrtPrice, hookData);\n\n        bytes memory res = poolManager.lock(\n            abi.encode(msg.sender, key, 99, initCount, deadLine)\n        );\n        return abi.decode(res, (int24));\n    }\n\n    function addLiquidity(\n        PoolKey calldata poolKey,\n        IPoolManager.ModifyLiquidityParams calldata modifyLiquidtyParams,\n        uint256 deadline\n    ) public payable returns (uint256, uint256) {\n        modificaitons[modCounter] = modifyLiquidtyParams;\n        positions[msg.sender].push(\n            position(\n                modifyLiquidtyParams.tickLower,\n                modifyLiquidtyParams.tickUpper,\n                getID(poolKey)\n            )\n        );\n        bytes memory res = poolManager.lock(\n            abi.encode(msg.sender, poolKey, 0, modCounter, deadline)\n        );\n\n        return abi.decode(res, (uint256, uint256));\n    }\n\n    function closePosition(\n        PoolKey calldata poolKey,\n        int24 tickLower,\n        int24 tickUpper,\n        uint256 deadline\n    ) public payable returns (int128, int128) {\n        uint128 liq = poolManager.getLiquidity(\n            PoolIdLibrary.toId(poolKey),\n            address(this),\n            tickLower,\n            tickUpper\n        );\n        modificaitons[modCounter] = IPoolManager.ModifyLiquidityParams(\n            tickLower,\n            tickUpper,\n            -int128(liq)\n        );\n        bytes memory res = poolManager.lock(\n            abi.encode(msg.sender, poolKey, 0, modCounter, deadline)\n        );\n        (int128 t0, int128 t1) = abi.decode(res, (int128, int128));\n        return (t0, t1);\n    }\n\n    function donate(\n        PoolKey calldata poolKey,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 deadline\n    ) public payable returns (uint256, uint256) {\n        donations[doCount] = [amount0, amount1];\n        bytes memory res = poolManager.lock(\n            abi.encode(msg.sender, poolKey, 2, doCount, deadline)\n        );\n\n        return abi.decode(res, (uint256, uint256));\n    }\n\n    function swap(\n        PoolKey calldata poolKey,\n        IPoolManager.SwapParams calldata swapParams,\n        uint256 deadline\n    ) public payable returns (int256, int256) {\n        swaps[modSwap] = swapParams;\n        bytes memory res = poolManager.lock(\n            abi.encode(msg.sender, poolKey, 1, modSwap, deadline)\n        );\n\n        return abi.decode(res, (int256, int256));\n    }\n\n    function lockAcquired(\n        bytes calldata data\n    ) external returns (bytes memory res) {\n        if (msg.sender != address(poolManager)) {\n            revert OnlyPoolManager();\n        }\n\n        (\n            address user,\n            PoolKey memory poolKey,\n            uint256 action,\n            uint256 counter,\n            uint256 deadline\n        ) = abi.decode(data, (address, PoolKey, uint256, uint256, uint256));\n\n        if (block.timestamp > deadline) {\n            revert();\n        }\n        BalanceDelta delta;\n        if (action == 0) {\n            delta = poolManager.modifyLiquidity(\n                poolKey,\n                modificaitons[counter],\n                \"0x\"\n            );\n            //If the amount is positive, then it is needed for the pool\n            //If the amount is negative, then it is given to the user\n            if (BalanceDeltaLibrary.amount0(delta) > 0) {\n                SafeERC20.safeTransferFrom(\n                    IERC20(Currency.unwrap(poolKey.currency0)),\n                    user,\n                    address(this),\n                    uint256(uint128(BalanceDeltaLibrary.amount0(delta)))\n                );\n            }\n            if (BalanceDeltaLibrary.amount1(delta) > 0) {\n                SafeERC20.safeTransferFrom(\n                    IERC20(Currency.unwrap(poolKey.currency1)),\n                    user,\n                    address(this),\n                    uint256(uint128(BalanceDeltaLibrary.amount1(delta)))\n                );\n            }\n\n            modCounter++;\n        }\n        if (action == 1) {\n            delta = poolManager.swap(poolKey, swaps[counter], \"0x\");\n            if (BalanceDeltaLibrary.amount0(delta) > 0) {\n                SafeERC20.safeTransferFrom(\n                    IERC20(Currency.unwrap(poolKey.currency0)),\n                    user,\n                    address(this),\n                    uint256(uint128(BalanceDeltaLibrary.amount0(delta)))\n                );\n            }\n            if (BalanceDeltaLibrary.amount1(delta) > 0) {\n                SafeERC20.safeTransferFrom(\n                    IERC20(Currency.unwrap(poolKey.currency1)),\n                    user,\n                    address(this),\n                    uint256(uint128(BalanceDeltaLibrary.amount1(delta)))\n                );\n            }\n            console.log(\"Swapping here\");\n            return abi.encode(true);\n            modSwap++;\n        }\n        if (action == 2) {\n            delta = poolManager.donate(\n                poolKey,\n                donations[counter][0],\n                donations[counter][1],\n                \"0x\"\n            );\n            if (BalanceDeltaLibrary.amount0(delta) > 0) {\n                SafeERC20.safeTransferFrom(\n                    IERC20(Currency.unwrap(poolKey.currency0)),\n                    user,\n                    address(this),\n                    uint256(uint128(BalanceDeltaLibrary.amount0(delta)))\n                );\n            }\n            if (BalanceDeltaLibrary.amount1(delta) > 0) {\n                SafeERC20.safeTransferFrom(\n                    IERC20(Currency.unwrap(poolKey.currency1)),\n                    user,\n                    address(this),\n                    uint256(uint128(BalanceDeltaLibrary.amount1(delta)))\n                );\n            }\n            doCount++;\n        }\n        if (action == 99) {\n            InitParams memory params;\n            params = inits[counter];\n            poolManager.initialize(\n                params.key,\n                params.sqrtPrice,\n                params.hookData\n            );\n        }\n        console.log(\n            Currency.unwrap(poolKey.currency0),\n            uint128(-1 * delta.amount0())\n        );\n        console.log(\n            Currency.unwrap(poolKey.currency1),\n            uint128(-1 * delta.amount1())\n        );\n\n        _settleCurrencyBalance(poolKey.currency0, delta.amount0());\n        _settleCurrencyBalance(poolKey.currency1, delta.amount1());\n        if (action != 2) {\n            IERC20(Currency.unwrap(poolKey.currency0)).safeTransfer(\n                user,\n                IERC20(Currency.unwrap(poolKey.currency0)).balanceOf(\n                    (address(this))\n                )\n            );\n\n            IERC20(Currency.unwrap(poolKey.currency1)).safeTransfer(\n                user,\n                IERC20(Currency.unwrap(poolKey.currency1)).balanceOf(\n                    (address(this))\n                )\n            );\n        }\n\n        res = abi.encode(delta.amount0(), delta.amount1());\n        //return new bytes();\n    }\n\n    function _settleCurrencyBalance(\n        Currency currency,\n        int128 deltaAmount\n    ) private {\n        if (deltaAmount < 0) {\n            poolManager.take(currency, address(this), uint128(-deltaAmount));\n            return;\n        }\n\n        if (currency.isNative()) {\n            poolManager.settle{value: uint128(deltaAmount)}(currency);\n            return;\n        }\n\n        IERC20(Currency.unwrap(currency)).safeTransfer(\n            address(poolManager),\n            uint128(deltaAmount)\n        );\n        poolManager.settle(currency);\n    }\n\n    function getLiquidityAmount(\n        int24 currentTick,\n        int24 lowerTick,\n        int24 upperTick,\n        uint256 amount0,\n        uint256 amount1\n    ) external pure returns (uint128) {\n        return\n            LiquidityAmounts.getLiquidityForAmounts(\n                TickMath.getSqrtRatioAtTick(currentTick),\n                TickMath.getSqrtRatioAtTick(lowerTick),\n                TickMath.getSqrtRatioAtTick(upperTick),\n                amount0,\n                amount1\n            );\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        0x000000000000000000636F6e736F6c652e6c6f67;\n\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    consoleAddress,\n                    add(payload, 32),\n                    mload(payload),\n                    0,\n                    0\n                )\n            )\n        }\n    }\n\n    function _castToPure(\n      function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castToPure(_sendLogPayloadImplementation)(payload);\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}\n"
    }
  },
  "settings": {
    "evmVersion": "cancun",
    "optimizer": {
      "enabled": true,
      "runs": 1,
      "details": {
        "yul": true
      }
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}