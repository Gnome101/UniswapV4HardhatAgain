{
  "address": "0xfEab06DB80E486B998eDa170118BC16A4b2Ee73E",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_game",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "game",
      "outputs": [
        {
          "internalType": "contract Game",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "_origin",
          "type": "uint32"
        },
        {
          "internalType": "bytes32",
          "name": "_sender",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "_message",
          "type": "bytes"
        }
      ],
      "name": "handle",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "interchainSecurityModule",
      "outputs": [
        {
          "internalType": "contract IInterchainSecurityModule",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ism",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "messageCount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xa5b1ce165f04bb636c5d5c08a7e72a0225f0da698505f180f7b75fbeb5c8521a",
  "receipt": {
    "to": null,
    "from": "0x24715460e2a524725525c46F4A20f4C973e36d33",
    "contractAddress": "0xfEab06DB80E486B998eDa170118BC16A4b2Ee73E",
    "transactionIndex": 0,
    "gasUsed": "27996415",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x24482d20a6744cd87126dd29a52f85d0a619cf0fa50ae5256a87ebc56abc8af2",
    "transactionHash": "0xa5b1ce165f04bb636c5d5c08a7e72a0225f0da698505f180f7b75fbeb5c8521a",
    "logs": [],
    "blockNumber": 43977,
    "cumulativeGasUsed": "27996415",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xdAB406d0748A3F2B2E87E59B45C059724b893145"
  ],
  "numDeployments": 1,
  "solcInputHash": "525f2f9914cb988ef877bb5a5cf7c4cf",
  "metadata": "{\"compiler\":{\"version\":\"0.8.24+commit.e11b9ed9\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_game\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"game\",\"outputs\":[{\"internalType\":\"contract Game\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_origin\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_sender\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"}],\"name\":\"handle\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interchainSecurityModule\",\"outputs\":[{\"internalType\":\"contract IInterchainSecurityModule\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ism\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"messageCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/TokenTown/LukeReceiver.sol\":\"LukeRecieve\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1},\"remappings\":[]},\"sources\":{\"@chainlink/contracts/src/v0.8/vrf/VRFConsumerBaseV2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/** ****************************************************************************\\n * @notice Interface for contracts using VRF randomness\\n * *****************************************************************************\\n * @dev PURPOSE\\n *\\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\\n * @dev making his output up to suit himself. Reggie provides Vera a public key\\n * @dev to which he knows the secret key. Each time Vera provides a seed to\\n * @dev Reggie, he gives back a value which is computed completely\\n * @dev deterministically from the seed and the secret key.\\n *\\n * @dev Reggie provides a proof by which Vera can verify that the output was\\n * @dev correctly computed once Reggie tells it to her, but without that proof,\\n * @dev the output is indistinguishable to her from a uniform random sample\\n * @dev from the output space.\\n *\\n * @dev The purpose of this contract is to make it easy for unrelated contracts\\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\\n * @dev simple access to a verifiable source of randomness. It ensures 2 things:\\n * @dev 1. The fulfillment came from the VRFCoordinator\\n * @dev 2. The consumer contract implements fulfillRandomWords.\\n * *****************************************************************************\\n * @dev USAGE\\n *\\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\\n * @dev initialize VRFConsumerBase's attributes in their constructor as\\n * @dev shown:\\n *\\n * @dev   contract VRFConsumer {\\n * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)\\n * @dev       VRFConsumerBase(_vrfCoordinator) public {\\n * @dev         <initialization with other arguments goes here>\\n * @dev       }\\n * @dev   }\\n *\\n * @dev The oracle will have given you an ID for the VRF keypair they have\\n * @dev committed to (let's call it keyHash). Create subscription, fund it\\n * @dev and your consumer contract as a consumer of it (see VRFCoordinatorInterface\\n * @dev subscription management functions).\\n * @dev Call requestRandomWords(keyHash, subId, minimumRequestConfirmations,\\n * @dev callbackGasLimit, numWords),\\n * @dev see (VRFCoordinatorInterface for a description of the arguments).\\n *\\n * @dev Once the VRFCoordinator has received and validated the oracle's response\\n * @dev to your request, it will call your contract's fulfillRandomWords method.\\n *\\n * @dev The randomness argument to fulfillRandomWords is a set of random words\\n * @dev generated from your requestId and the blockHash of the request.\\n *\\n * @dev If your contract could have concurrent requests open, you can use the\\n * @dev requestId returned from requestRandomWords to track which response is associated\\n * @dev with which randomness request.\\n * @dev See \\\"SECURITY CONSIDERATIONS\\\" for principles to keep in mind,\\n * @dev if your contract could have multiple requests in flight simultaneously.\\n *\\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\\n * @dev differ.\\n *\\n * *****************************************************************************\\n * @dev SECURITY CONSIDERATIONS\\n *\\n * @dev A method with the ability to call your fulfillRandomness method directly\\n * @dev could spoof a VRF response with any random value, so it's critical that\\n * @dev it cannot be directly called by anything other than this base contract\\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\\n *\\n * @dev For your users to trust that your contract's random behavior is free\\n * @dev from malicious interference, it's best if you can write it so that all\\n * @dev behaviors implied by a VRF response are executed *during* your\\n * @dev fulfillRandomness method. If your contract must store the response (or\\n * @dev anything derived from it) and use it later, you must ensure that any\\n * @dev user-significant behavior which depends on that stored value cannot be\\n * @dev manipulated by a subsequent VRF request.\\n *\\n * @dev Similarly, both miners and the VRF oracle itself have some influence\\n * @dev over the order in which VRF responses appear on the blockchain, so if\\n * @dev your contract could have multiple VRF requests in flight simultaneously,\\n * @dev you must ensure that the order in which the VRF responses arrive cannot\\n * @dev be used to manipulate your contract's user-significant behavior.\\n *\\n * @dev Since the block hash of the block which contains the requestRandomness\\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\\n * @dev miner could, in principle, fork the blockchain to evict the block\\n * @dev containing the request, forcing the request to be included in a\\n * @dev different block with a different hash, and therefore a different input\\n * @dev to the VRF. However, such an attack would incur a substantial economic\\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\\n * @dev until it calls responds to a request. It is for this reason that\\n * @dev that you can signal to an oracle you'd like them to wait longer before\\n * @dev responding to the request (however this is not enforced in the contract\\n * @dev and so remains effective only in the case of unmodified oracle software).\\n */\\nabstract contract VRFConsumerBaseV2 {\\n  error OnlyCoordinatorCanFulfill(address have, address want);\\n  address private immutable vrfCoordinator;\\n\\n  /**\\n   * @param _vrfCoordinator address of VRFCoordinator contract\\n   */\\n  constructor(address _vrfCoordinator) {\\n    vrfCoordinator = _vrfCoordinator;\\n  }\\n\\n  /**\\n   * @notice fulfillRandomness handles the VRF response. Your contract must\\n   * @notice implement it. See \\\"SECURITY CONSIDERATIONS\\\" above for important\\n   * @notice principles to keep in mind when implementing your fulfillRandomness\\n   * @notice method.\\n   *\\n   * @dev VRFConsumerBaseV2 expects its subcontracts to have a method with this\\n   * @dev signature, and will call it once it has verified the proof\\n   * @dev associated with the randomness. (It is triggered via a call to\\n   * @dev rawFulfillRandomness, below.)\\n   *\\n   * @param requestId The Id initially returned by requestRandomness\\n   * @param randomWords the VRF output expanded to the requested number of words\\n   */\\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal virtual;\\n\\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\\n  // the origin of the call\\n  function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external {\\n    if (msg.sender != vrfCoordinator) {\\n      revert OnlyCoordinatorCanFulfill(msg.sender, vrfCoordinator);\\n    }\\n    fulfillRandomWords(requestId, randomWords);\\n  }\\n}\\n\",\"keccak256\":\"0x3d709a5e0f1f9b8841172b10ba8af785dd51a13eda9fc395723a706e51329904\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * The default value of {decimals} is 18. To change this, you should override\\n * this function so it returns a different value.\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the default value returned by this function, unless\\n     * it's overridden.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n            // decrementing then incrementing.\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n}\\n\",\"keccak256\":\"0xa56ca923f70c1748830700250b19c61b70db9a683516dc5e216694a50445d99c\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x287b55befed2961a7eabd7d7b1b2839cbca8a5b80ef8dcbb25ed3d4c2002c305\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x8de418a5503946cabe331f35fe242d3201a73f67f77aaeb7110acb1f30423aca\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n *\\n * ==== Security Considerations\\n *\\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\\n * generally recommended is:\\n *\\n * ```solidity\\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\\n *     doThing(..., value);\\n * }\\n *\\n * function doThing(..., uint256 value) public {\\n *     token.safeTransferFrom(msg.sender, address(this), value);\\n *     ...\\n * }\\n * ```\\n *\\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\\n * {SafeERC20-safeTransferFrom}).\\n *\\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\\n * contracts should have entry points that don't rely on permit.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     *\\n     * CAUTION: See Security Considerations above.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xb264c03a3442eb37a68ad620cefd1182766b58bee6cec40343480392d6b14d69\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\\n    }\\n}\\n\",\"keccak256\":\"0xabefac93435967b4d36a4fabcbdbb918d1f0b7ae3c3d85bc30923b326c927ed1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x006dd67219697fe68d7fbfdea512e7c4cb64a43565ed86171d67e844982da6fa\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\",\"keccak256\":\"0xa92e4fa126feb6907daa0513ddd816b2eb91f30a808de54f63c17d0e162c3439\",\"license\":\"MIT\"},\"contracts/Hooks/BaseHook.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.24;\\n\\nimport {Hooks} from \\\"../Uniswap/V4-Core/libraries/Hooks.sol\\\";\\nimport {IPoolManager} from \\\"../Uniswap/V4-Core/interfaces/IPoolManager.sol\\\";\\nimport {IHooks} from \\\"../Uniswap/V4-Core/interfaces/IHooks.sol\\\";\\nimport {BalanceDelta} from \\\"../Uniswap/V4-Core/types/BalanceDelta.sol\\\";\\nimport {PoolKey} from \\\"../Uniswap/V4-Core/types/PoolKey.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\nabstract contract BaseHook is IHooks {\\n    error NotPoolManager();\\n    error NotSelf();\\n    error InvalidPool();\\n    error LockFailure();\\n    error HookNotImplemented();\\n\\n    /// @notice The address of the pool manager\\n    IPoolManager public immutable poolManager;\\n\\n    constructor(IPoolManager _poolManager) {\\n        poolManager = _poolManager;\\n        validateHookAddress(this);\\n    }\\n\\n    /// @dev Only the pool manager may call this function\\n    modifier poolManagerOnly() {\\n        if (msg.sender != address(poolManager)) revert NotPoolManager();\\n        _;\\n    }\\n\\n    /// @dev Only this address may call this function\\n    modifier selfOnly() {\\n        if (msg.sender != address(this)) revert NotSelf();\\n        _;\\n    }\\n\\n    /// @dev Only pools with hooks set to this contract may call this function\\n    modifier onlyValidPools(IHooks hooks) {\\n        if (hooks != this) revert InvalidPool();\\n        _;\\n    }\\n\\n    function getHookPermissions()\\n        public\\n        pure\\n        virtual\\n        returns (Hooks.Permissions memory);\\n\\n    // this function is virtual so that we can override it during testing,\\n    // which allows us to deploy an implementation to any address\\n    // and then etch the bytecode into the correct address\\n    function validateHookAddress(BaseHook _this) internal pure virtual {\\n        // console.log(\\\"Current addy\\\", address(_this));\\n        Hooks.validateHookPermissions(_this, getHookPermissions());\\n    }\\n\\n    function lockAcquired(\\n        address,\\n        /*sender*/ bytes calldata data\\n    ) external virtual poolManagerOnly returns (bytes memory) {\\n        (bool success, bytes memory returnData) = address(this).call(data);\\n        if (success) return returnData;\\n        if (returnData.length == 0) revert LockFailure();\\n        // if the call failed, bubble up the reason\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            revert(add(returnData, 32), mload(returnData))\\n        }\\n    }\\n\\n    function beforeInitialize(\\n        address,\\n        PoolKey calldata,\\n        uint160,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        revert HookNotImplemented();\\n    }\\n\\n    function afterInitialize(\\n        address,\\n        PoolKey calldata,\\n        uint160,\\n        int24,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        revert HookNotImplemented();\\n    }\\n\\n    function beforeAddLiquidity(\\n        address,\\n        PoolKey calldata,\\n        IPoolManager.ModifyLiquidityParams calldata,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        revert HookNotImplemented();\\n    }\\n\\n    function beforeRemoveLiquidity(\\n        address,\\n        PoolKey calldata,\\n        IPoolManager.ModifyLiquidityParams calldata,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        revert HookNotImplemented();\\n    }\\n\\n    function afterAddLiquidity(\\n        address,\\n        PoolKey calldata,\\n        IPoolManager.ModifyLiquidityParams calldata,\\n        BalanceDelta,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        revert HookNotImplemented();\\n    }\\n\\n    function afterRemoveLiquidity(\\n        address,\\n        PoolKey calldata,\\n        IPoolManager.ModifyLiquidityParams calldata,\\n        BalanceDelta,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        revert HookNotImplemented();\\n    }\\n\\n    function beforeSwap(\\n        address,\\n        PoolKey calldata,\\n        IPoolManager.SwapParams calldata,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        revert HookNotImplemented();\\n    }\\n\\n    function afterSwap(\\n        address,\\n        PoolKey calldata,\\n        IPoolManager.SwapParams calldata,\\n        BalanceDelta,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        revert HookNotImplemented();\\n    }\\n\\n    function beforeDonate(\\n        address,\\n        PoolKey calldata,\\n        uint256,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        revert HookNotImplemented();\\n    }\\n\\n    function afterDonate(\\n        address,\\n        PoolKey calldata,\\n        uint256,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        revert HookNotImplemented();\\n    }\\n}\\n\",\"keccak256\":\"0x1bb9164964b17eb66f4ede3b14148aa88f89fd00f5a8537c3dfb2b9f96bd8658\",\"license\":\"UNLICENSED\"},\"contracts/Hyperlane/Interfaces/IInterchainSecurityModule.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity >=0.6.11;\\n\\ninterface IInterchainSecurityModule {\\n    enum Types {\\n        UNUSED,\\n        ROUTING,\\n        AGGREGATION,\\n        LEGACY_MULTISIG,\\n        MERKLE_ROOT_MULTISIG,\\n        MESSAGE_ID_MULTISIG,\\n        NULL, // used with relayer carrying no metadata\\n        CCIP_READ\\n    }\\n\\n    /**\\n     * @notice Returns an enum that represents the type of security model\\n     * encoded by this ISM.\\n     * @dev Relayers infer how to fetch and format metadata.\\n     */\\n    function moduleType() external view returns (uint8);\\n\\n    /**\\n     * @notice Defines a security model responsible for verifying interchain\\n     * messages based on the provided metadata.\\n     * @param _metadata Off-chain metadata provided by a relayer, specific to\\n     * the security model encoded by the module (e.g. validator signatures)\\n     * @param _message Hyperlane encoded interchain message\\n     * @return True if the message was verified\\n     */\\n    function verify(\\n        bytes calldata _metadata,\\n        bytes calldata _message\\n    ) external returns (bool);\\n}\\n\\ninterface ISpecifiesInterchainSecurityModule {\\n    function interchainSecurityModule()\\n        external\\n        view\\n        returns (IInterchainSecurityModule);\\n}\\n\",\"keccak256\":\"0xd144a00a15eef18012f8dae28ca1a7d965012f88ff4a07382a172ae6e02811ce\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/Hyperlane/NullISM.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity >=0.8.0;\\n\\nimport {IInterchainSecurityModule} from \\\"contracts/Hyperlane/Interfaces/IInterchainSecurityModule.sol\\\";\\n\\ncontract NoopIsm is IInterchainSecurityModule {\\n    uint8 public constant override moduleType = uint8(Types.NULL);\\n\\n    function verify(\\n        bytes calldata,\\n        bytes calldata\\n    ) public pure override returns (bool) {\\n        return true;\\n    }\\n}\\n\",\"keccak256\":\"0x7c3d01ab4ea5b1aa28639ed85b9b54e9dad6b47cac4409e6258c7199374eddaf\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/Mocks/Custom.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\n\\ncontract Custom is ERC20 {\\n    constructor(string memory name, string memory symbol) ERC20(name, symbol) {\\n        //Uncomment to mint upon deployment\\n        _mint(msg.sender, 1000 * 10 ** 18);\\n    }\\n\\n    function mint(uint256 amount) public {\\n        _mint(msg.sender, amount);\\n    }\\n}\\n\",\"keccak256\":\"0x70a354d2c19a538b69056f417c7f46b3b6fe2ab5acbf6f7735948811721e7bd8\",\"license\":\"MIT\"},\"contracts/MyHook.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.24;\\n\\nimport {BaseHook} from \\\"./Hooks/BaseHook.sol\\\";\\n\\nimport {Hooks} from \\\"./Uniswap/V4-Core/libraries/Hooks.sol\\\";\\n\\nimport {IPoolManager} from \\\"./Uniswap/V4-Core/interfaces/IPoolManager.sol\\\";\\nimport {Currency, CurrencyLibrary} from \\\"./Uniswap/V4-Core/types/Currency.sol\\\";\\n\\nimport {PoolKey} from \\\"./Uniswap/V4-Core/types/PoolKey.sol\\\";\\nimport {PoolId, PoolIdLibrary} from \\\"./Uniswap/V4-Core/types/PoolId.sol\\\";\\nimport {BalanceDelta} from \\\"./Uniswap/V4-Core/types/BalanceDelta.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\n// import {UniswapInteract} from \\\"./UniswapInteract.sol\\\";\\n//Uncomment below for console logs\\nimport \\\"hardhat/console.sol\\\";\\nerror SwapExpired();\\nerror OnlyPoolManager();\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {Property} from \\\"./TokenTown/Property.sol\\\";\\nimport {Game} from \\\"./TokenTown/Game.sol\\\";\\n\\ncontract MyHook is BaseHook {\\n    using PoolIdLibrary for PoolKey;\\n    using CurrencyLibrary for Currency;\\n    // NOTE: ---------------------------------------------------------\\n    // state variables should typically be unique to a pool\\n    // a single hook contract should be able to service multiple pools\\n    // ---------------------------------------------------------------\\n\\n    mapping(PoolId => uint256 count) public beforeSwapCount;\\n    mapping(PoolId => uint256 count) public afterSwapCount;\\n\\n    mapping(PoolId => uint256 count) public beforeAddLiquidityCount;\\n    mapping(PoolId => uint256 count) public beforeRemoveLiquidityCount;\\n\\n    constructor(IPoolManager _poolManager) BaseHook(_poolManager) {}\\n\\n    //Below is for uniswap interact\\n    mapping(uint256 => InitParams) inits;\\n    uint256 initCount;\\n\\n    mapping(uint256 => IPoolManager.SwapParams) swaps;\\n    uint256 modSwap;\\n    address currentUser;\\n    Game public game;\\n    struct InitParams {\\n        PoolKey key;\\n        uint160 sqrtPrice;\\n        bytes hookData;\\n    }\\n\\n    function setGame(address _game) public {\\n        game = Game(_game);\\n    }\\n\\n    function startPool(\\n        PoolKey memory key,\\n        uint160 sqrtPrice,\\n        bytes calldata hookData,\\n        uint256 deadLine\\n    ) public payable returns (int24 tick) {\\n        inits[initCount] = InitParams(key, sqrtPrice, hookData);\\n\\n        bytes memory res = poolManager.lock(\\n            abi.encode(msg.sender, key, 99, initCount, deadLine)\\n        );\\n        return abi.decode(res, (int24));\\n    }\\n\\n    mapping(address => uint256) tokenPrice;\\n    mapping(address => uint256) tokenChange;\\n\\n    function swap(\\n        PoolKey calldata poolKey,\\n        IPoolManager.SwapParams calldata swapParams,\\n        uint256 deadline,\\n        address _user\\n    ) public payable returns (int256, int256) {\\n        swaps[modSwap] = swapParams;\\n        currentUser = _user;\\n        bytes memory res = poolManager.lock(\\n            abi.encode(msg.sender, poolKey, 1, modSwap, deadline)\\n        );\\n\\n        return abi.decode(res, (int256, int256));\\n    }\\n\\n    function lockAcquired(\\n        bytes calldata data\\n    ) external returns (bytes memory res) {\\n        if (msg.sender != address(poolManager)) {\\n            revert OnlyPoolManager();\\n        }\\n\\n        (\\n            address user,\\n            PoolKey memory poolKey,\\n            uint256 action,\\n            uint256 counter,\\n            uint256 deadline\\n        ) = abi.decode(data, (address, PoolKey, uint256, uint256, uint256));\\n\\n        if (block.timestamp > deadline) {\\n            revert();\\n        }\\n        BalanceDelta delta;\\n\\n        if (action == 1) {\\n            delta = poolManager.swap(poolKey, swaps[counter], \\\"0x\\\");\\n\\n            int256 amount0 = poolManager.currencyDelta(\\n                address(this),\\n                poolKey.currency0\\n            );\\n\\n            int256 amount1 = poolManager.currencyDelta(\\n                address(this),\\n                poolKey.currency1\\n            );\\n\\n            // console.log(\\\"-\\\", uint256(-1 * amount0), uint256(amount1));\\n            // console.log(user);\\n            if (amount0 > 0) {\\n                SafeERC20.safeTransferFrom(\\n                    IERC20(Currency.unwrap(poolKey.currency0)),\\n                    user,\\n                    address(this),\\n                    uint256(amount0)\\n                );\\n\\n                SafeERC20.safeTransfer(\\n                    IERC20(Currency.unwrap(poolKey.currency0)),\\n                    address(poolManager),\\n                    uint256(amount0)\\n                );\\n                poolManager.settle(poolKey.currency0);\\n            }\\n            if (amount1 > 0) {\\n                SafeERC20.safeTransferFrom(\\n                    IERC20(Currency.unwrap(poolKey.currency1)),\\n                    user,\\n                    address(this),\\n                    uint256(amount1)\\n                );\\n\\n                SafeERC20.safeTransfer(\\n                    IERC20(Currency.unwrap(poolKey.currency1)),\\n                    address(poolManager),\\n                    uint256(amount1)\\n                );\\n                poolManager.settle(poolKey.currency1);\\n            }\\n            // console.log(\\\"Here\\\");\\n\\n            if (amount0 < 0) {\\n                poolManager.take(\\n                    poolKey.currency0,\\n                    address(this),\\n                    uint256(-1 * amount0)\\n                );\\n                SafeERC20.safeTransfer(\\n                    IERC20(Currency.unwrap(poolKey.currency0)),\\n                    user,\\n                    uint256(-1 * amount0)\\n                );\\n            }\\n            if (amount1 < 0) {\\n                poolManager.take(\\n                    poolKey.currency1,\\n                    address(this),\\n                    uint256(-1 * amount1)\\n                );\\n                // console.log(\\n                //     IERC20(Currency.unwrap(poolKey.currency1)).balanceOf(\\n                //         address(this)\\n                //     )\\n                // );\\n                SafeERC20.safeTransfer(\\n                    IERC20(Currency.unwrap(poolKey.currency1)),\\n                    user,\\n                    uint256(-1 * amount1)\\n                );\\n            }\\n            modSwap++;\\n            int256 amount0After = poolManager.currencyDelta(\\n                address(this),\\n                poolKey.currency0\\n            );\\n\\n            int256 amount1After = poolManager.currencyDelta(\\n                address(this),\\n                poolKey.currency1\\n            );\\n            require(amount0After == 0, \\\"Amount0 not settled\\\");\\n            require(amount1After == 0, \\\"Amount1 not settled\\\");\\n\\n            return res = abi.encode(amount0, amount1);\\n        }\\n\\n        if (action == 99) {\\n            InitParams memory params;\\n            params = inits[counter];\\n            poolManager.initialize(\\n                params.key,\\n                params.sqrtPrice,\\n                params.hookData\\n            );\\n        }\\n\\n        res = abi.encode(delta.amount0(), delta.amount1());\\n        //return new bytes();\\n    }\\n\\n    function getHookPermissions()\\n        public\\n        pure\\n        override\\n        returns (Hooks.Permissions memory)\\n    {\\n        return\\n            Hooks.Permissions({\\n                beforeInitialize: false,\\n                afterInitialize: false,\\n                beforeAddLiquidity: false,\\n                afterAddLiquidity: false,\\n                beforeRemoveLiquidity: false,\\n                afterRemoveLiquidity: false,\\n                beforeSwap: true,\\n                afterSwap: false,\\n                beforeDonate: false,\\n                afterDonate: false,\\n                noOp: true\\n            });\\n    }\\n\\n    // -----------------------------------------------\\n    // NOTE: see IHooks.sol for function documentation\\n    // -----------------------------------------------\\n    mapping(uint256 => uint256) public tokensBoughtAtPositon;\\n\\n    function beforeSwap(\\n        address,\\n        PoolKey calldata key,\\n        IPoolManager.SwapParams calldata params,\\n        bytes calldata\\n    ) external override returns (bytes4) {\\n        //Rules for monopoly\\n        //At most 1 token can be bought at one position\\n        // tokensBoughtAtPositon[]\\n        //User must be within the position to length of a token\\n\\n        // console.log(\\\"Before a swap 11\\\");\\n        uint256 tokenAmount = params.amountSpecified < 0\\n            ? uint256(-params.amountSpecified)\\n            : uint256(params.amountSpecified);\\n        uint256 amountSpent = tokenAmount;\\n        // console.log(\\\"Here\\\");\\n        // determine inbound/outbound token based on 0->1 or 1->0 swap\\n        (Currency inbound, Currency outbound) = params.zeroForOne\\n            ? (key.currency0, key.currency1)\\n            : (key.currency1, key.currency0);\\n\\n        if (Currency.unwrap(outbound) != game.getCurrentChosenCurrency()) {\\n            //This means the user is buying property\\n            //Must check that they are on it and enforce pricing\\n            Property property = Property(Currency.unwrap(outbound));\\n            require(currentUser != address(0), \\\"Must have new user\\\");\\n            uint256 currentUserPosition = game.getPlayerPosition(currentUser);\\n            require(\\n                property.canUserPurchase(currentUserPosition),\\n                \\\"User not on square\\\"\\n            );\\n            uint256 price = property.getPrice(currentUserPosition);\\n            // console.log(\\\"Price\\\", price);\\n            if (price == 0) {\\n                revert(\\\"The price is returning as 0\\\");\\n            }\\n            tokenAmount = tokenAmount / price;\\n            if (tokensBoughtAtPositon[currentUserPosition] >= 10 ** 18) {\\n                revert(\\\"Can not buy anymore here\\\");\\n            }\\n\\n            if (\\n                tokenAmount >\\n                10 ** 18 - tokensBoughtAtPositon[currentUserPosition]\\n            ) {\\n                tokensBoughtAtPositon[currentUserPosition] = 10 ** 18;\\n                uint256 refund = tokenAmount -\\n                    tokensBoughtAtPositon[currentUserPosition];\\n                refund = refund * price;\\n                amountSpent -= refund;\\n                tokenAmount = 10 ** 18;\\n                // console.log(\\\"Refund issued of:\\\", refund, amountSpent);\\n            } else {\\n                tokensBoughtAtPositon[currentUserPosition] = tokenAmount;\\n            }\\n        } else {\\n            Property property = Property(Currency.unwrap(inbound));\\n            uint256 currentUserPosition = game.getPlayerPosition(currentUser);\\n\\n            //User is selling property\\n            uint256 price = property.getPrice(currentUserPosition);\\n\\n            tokenAmount = tokenAmount * price;\\n            // console.log(\\\"Balance\\\", outbound.balanceOfSelf());\\n            poolManager.burn(address(this), outbound.toId(), tokenAmount); //This creates credit\\n            poolManager.take(outbound, address(this), tokenAmount); //This settles the credit\\n            if (tokenAmount > 10 ** 18) {\\n                tokensBoughtAtPositon[currentUserPosition] = 0;\\n            } else {\\n                tokensBoughtAtPositon[currentUserPosition] -= tokenAmount;\\n            }\\n\\n            // console.log(outbound.balanceOfSelf());\\n        }\\n\\n        // take the inbound token from the PoolManager, debt is paid by the swapper via the swap router\\n        // (inbound token is added to hook's reserves)\\n        poolManager.mint(address(this), inbound.toId(), amountSpent);\\n        // console.log(\\\"Here\\\", amountSpent);\\n\\n        // provide outbound token to the PoolManager, credit is claimed by the swap router who forwards it to the swapper\\n        // (outbound token is removed from hook's reserves)\\n        // console.log(\\\"Here\\\");\\n        // console.log(inbound.balanceOfSelf(), amountSpent);\\n        // console.log(outbound.balanceOfSelf(), tokenAmount);\\n        outbound.transfer(address(poolManager), tokenAmount);\\n        poolManager.settle(outbound);\\n        // console.log(outbound.balanceOfSelf(), tokenAmount);\\n\\n        // console.log(\\\"Finished\\\");\\n        return Hooks.NO_OP_SELECTOR;\\n    }\\n\\n    function afterSwap(\\n        address,\\n        PoolKey calldata key,\\n        IPoolManager.SwapParams calldata,\\n        BalanceDelta,\\n        bytes calldata\\n    ) external override returns (bytes4) {\\n        return BaseHook.afterSwap.selector;\\n    }\\n\\n    function beforeAddLiquidity(\\n        address,\\n        PoolKey calldata key,\\n        IPoolManager.ModifyLiquidityParams calldata,\\n        bytes calldata\\n    ) external override returns (bytes4) {\\n        return BaseHook.beforeAddLiquidity.selector;\\n    }\\n\\n    function beforeRemoveLiquidity(\\n        address,\\n        PoolKey calldata key,\\n        IPoolManager.ModifyLiquidityParams calldata,\\n        bytes calldata\\n    ) external override returns (bytes4) {\\n        return BaseHook.beforeRemoveLiquidity.selector;\\n    }\\n}\\n\",\"keccak256\":\"0x71e6cd8d67628eed2ff179d9896664ba2075c6d6ff084b60b6b8e513eeb19665\",\"license\":\"MIT\"},\"contracts/TokenTown/Game.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.24;\\n\\nimport \\\"hardhat/console.sol\\\";\\nimport {IGame} from \\\"./IGame.sol\\\";\\nimport {Property} from \\\"./Property.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@chainlink/contracts/src/v0.8/vrf/VRFConsumerBaseV2.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {IPoolManager} from \\\"../Uniswap/V4-Core/interfaces/IPoolManager.sol\\\";\\n\\nimport {Currency, CurrencyLibrary} from \\\"../Uniswap/V4-Core/types/Currency.sol\\\";\\nimport {PoolKey} from \\\"../Uniswap/V4-Core/types/PoolKey.sol\\\";\\nimport {MyHook} from \\\"../MyHook.sol\\\";\\nimport {IHooks} from \\\"../Uniswap/V4-Core/interfaces/IHooks.sol\\\";\\nimport {TickMath} from \\\"../Uniswap/V4-Core/libraries/TickMath.sol\\\";\\n\\nimport {IInterchainSecurityModule} from \\\"../Hyperlane/NullISM.sol\\\";\\n// import {ERC20} from \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport {Custom} from \\\"../Mocks/Custom.sol\\\";\\n\\ncontract Game is IGame {\\n    //Below is for chainlink\\n\\n    address public immutable poolManager;\\n    MyHook public immutable mainHook;\\n\\n    //Below is for the game\\n    uint256 gameID;\\n    mapping(address => uint256) public playerToGame;\\n    mapping(uint256 => GameState) public idToGameState;\\n    mapping(address => bool) public userRoll; //User can roll\\n    mapping(address => uint256) public userRollsRow; //# of rolls in a row\\n\\n    mapping(uint256 => bool) rentExists;\\n\\n    string[] usualNamesAndSymbols;\\n    uint256 constant MAX_STEPS = 20;\\n    mapping(address => uint256) addressToGame;\\n\\n    mapping(address => TokenInfo) getCurrencyInfo;\\n\\n    address public ism = 0x1F02fA4F142e0727CC3f2eC84433aB513F977657;\\n\\n    struct TokenInfo {\\n        uint8[4] priceStarts;\\n        uint8[4] priceChanges;\\n        uint256 userStart;\\n    }\\n    mapping(address => PoolKey) addressToKey;\\n\\n    constructor(\\n        address _poolManager,\\n        address _mainHook // address vrfCoordinator\\n    ) /*VRFConsumerBaseV2(vrfCoordinator)*/ {\\n        require(\\n            _poolManager != address(0),\\n            \\\"Pool manager address cannot be zero.\\\"\\n        );\\n        poolManager = _poolManager;\\n        mainHook = MyHook(_mainHook);\\n        // You can use console.log for debugging purposes\\n        // console.log(\\\"Game contract deployed by:\\\", activeUser);\\n        // console.log(\\\"Pool Manager set to:\\\", poolManager);\\n    }\\n\\n    //Function for testing\\n    // function reclaimTokens(address token) external {\\n    //     IERC20(token).transfer(\\n    //         msg.sender,\\n    //         IERC20(token).balanceOf(address(this))\\n    //     );\\n    // }\\n\\n    mapping(address => uint256) userBalance;\\n\\n    // Implementing the start function from IGame\\n    function setUp(\\n        address activeUser,\\n        address selToken,\\n        uint256 bankStart\\n    ) public {\\n        address selectedToken = mintWrapper(Custom(selToken));\\n\\n        // SafeERC20.safeTransferFrom(\\n        //     IERC20(selectedToken),\\n        //     activeUser,\\n        //     address(this),\\n        //     bankStart\\n        // );\\n        idToGameState[gameID].players.push(activeUser);\\n        addressToGame[activeUser] = gameID;\\n        idToGameState[gameID].numberOfPlayers++;\\n        // console.log(\\\"GS\\\", idToGameState[gameID].numberOfPlayers);\\n        idToGameState[gameID].chosenCurrency = selectedToken;\\n\\n        //Mint 8 ERC20s with a balance of 4 for each\\n        _createAndAssignProperties(gameID);\\n        _prepareProperties(idToGameState[gameID].propertyList, selectedToken);\\n\\n        //Open up a game for other users to join\\n        //Add liquidity with the pools\\n\\n        gameID++;\\n    }\\n\\n    function _prepareProperties(\\n        Property[] memory propertyList,\\n        address selectedToken\\n    ) internal {\\n        for (uint256 i = 0; i < propertyList.length; i++) {\\n            Property property = propertyList[i];\\n            _preparePoolProperty(property, selectedToken);\\n        }\\n    }\\n\\n    function _preparePoolProperty(Property property, address token) internal {\\n        //First we need to initalize the pool\\n        address token0 = address(property);\\n        address token1 = token;\\n        if (token1 < token0) {\\n            address temp = token0;\\n            token0 = token1;\\n            token1 = temp;\\n        }\\n        Currency currency_property = Currency.wrap(token0);\\n        Currency currency_token = Currency.wrap(token1);\\n\\n        uint24 _fee = 0;\\n        int24 tickSpacing = 60;\\n        address hookAddy = address(mainHook);\\n        IHooks hooks = IHooks(hookAddy);\\n\\n        PoolKey memory key = PoolKey(\\n            currency_property,\\n            currency_token,\\n            _fee,\\n            tickSpacing,\\n            hooks\\n        );\\n        addressToKey[address(property)] = key;\\n        uint160 sqrtPrice = TickMath.getSqrtRatioAtTick(0);\\n\\n        mainHook.startPool(key, sqrtPrice, \\\"0x\\\", block.timestamp + 10);\\n        // console.log(\\\"Pool started\\\");\\n        // uint256 totalTokenNumber = 4 *\\n        property.getPriceStart() + 6 * property.getPriceIncrease();\\n        //Then we need to add liquidity\\n        // SafeERC20.safeTransferFrom(\\n        //     IERC20(token),\\n        //     user,\\n        //     address(this),\\n        //     totalTokenNumber\\n        // );\\n\\n        SafeERC20.safeTransfer(\\n            IERC20(address(property)),\\n            address(mainHook),\\n            IERC20(address(property)).balanceOf(address(this))\\n        );\\n        // mainHook.addProperty(property);\\n    }\\n\\n    function _createAndAssignProperties(uint256 _gameID) internal {\\n        uint8[4] memory usualList = [1, 6, 11, 16]; // These are the positions that all of the properties start on\\n        uint8[4] memory priceStarts;\\n        uint8[4] memory priceChanges;\\n        uint8[4] memory rentStarts;\\n\\n        TokenInfo memory tInfo = getCurrencyInfo[\\n            idToGameState[gameID].chosenCurrency\\n        ];\\n\\n        if (tInfo.userStart > 0) {\\n            priceStarts = tInfo.priceStarts;\\n            priceChanges = tInfo.priceChanges;\\n        } else {\\n            priceStarts = [60, 120, 160, 250];\\n            rentStarts = [10, 30, 50, 70];\\n            priceChanges = [5, 10, 20, 50];\\n        }\\n\\n        for (uint256 i = 0; i < usualNamesAndSymbols.length; i++) {\\n            Property property = new Property(\\n                usualNamesAndSymbols[i],\\n                usualNamesAndSymbols[i + 1],\\n                4,\\n                usualList[i / 2],\\n                priceStarts[i / 2],\\n                rentStarts[i / 2],\\n                priceChanges[i / 2]\\n            );\\n            // console.log(usualNamesAndSymbols[i], usualNamesAndSymbols[i + 1]);\\n            //Add all of the ERC20s to the game state\\n            idToGameState[_gameID].propertyList.push(property);\\n            i++;\\n        }\\n    }\\n\\n    function joinGame(address activeUser) public {\\n        if (gameID == 0) {\\n            revert(\\\"\\\");\\n        }\\n        uint256 curentGame = gameID - 1;\\n        address[] memory list = idToGameState[curentGame].players;\\n        for (uint i = 0; i < list.length; i++) {\\n            if (activeUser == list[i]) {\\n                revert(\\\"\\\");\\n            }\\n        }\\n        idToGameState[curentGame].players.push(activeUser);\\n        addressToGame[activeUser] = curentGame;\\n        uint256 buyIn = idToGameState[curentGame].buyIn /\\n            idToGameState[curentGame].players.length;\\n        // SafeERC20.safeTransferFrom(\\n        //     IERC20(idToGameState[curentGame].chosenCurrency),\\n        //     activeUser,\\n        //     address(this),\\n        //     buyIn\\n        // );\\n        Custom(idToGameState[curentGame].chosenCurrency).mint(buyIn);\\n        idToGameState[curentGame].buyIn += buyIn;\\n\\n        idToGameState[curentGame].numberOfPlayers++;\\n    }\\n\\n    // function getBuyIn() public view returns (uint256) {\\n    //     if (gameID == 0) {\\n    //         revert(\\\"No games exist\\\");\\n    //     }\\n    //     uint256 curentGame = gameID - 1;\\n    //     uint256 buyIn = idToGameState[curentGame].buyIn /\\n    //         idToGameState[curentGame].players.length;\\n    //     return buyIn;\\n    // }\\n\\n    function getBalance(address user) public view returns (uint256) {\\n        return userBalance[user];\\n    }\\n\\n    function startGame(address activeUser) public {\\n        //This just starts the most recently made game\\n        //This will begin the game for all players, and begin a move for the first player.\\n        if (gameID == 0) {\\n            revert(\\\"\\\");\\n        }\\n        uint256 curentGameID = gameID - 1;\\n        userRoll[activeUser] = true;\\n        idToGameState[curentGameID].currentPlayer = activeUser;\\n        emit GameStarted(activeUser, gameID);\\n        //Now we have to distribute moneys\\n        uint256 amount = getCurrencyInfo[\\n            idToGameState[curentGameID].chosenCurrency\\n        ].userStart;\\n        if (amount == 0) {\\n            amount = 100 * 10 ** 18;\\n        }\\n        for (uint i = 0; i < idToGameState[curentGameID].players.length; i++) {\\n            // SafeERC20.safeTransfer(\\n            //     IERC20(idToGameState[curentGameID].chosenCurrency),\\n            //     idToGameState[curentGameID].players[i],\\n            //     amount\\n            // );\\n            userBalance[idToGameState[curentGameID].players[i]] = amount;\\n        }\\n    }\\n\\n    // function _rollDice(\\n    //     address activeUser\\n    // ) public returns (bool snake, uint256 total) {\\n    //     //Upon implementation add chainlink here\\n    //     uint256 dice1 = (uint256(\\n    //         keccak256(\\n    //             abi.encodePacked(block.timestamp, block.prevrandao, activeUser)\\n    //         )\\n    //     ) % 6) + 1;\\n\\n    //     uint256 dice2 = (uint256(\\n    //         keccak256(\\n    //             abi.encodePacked(\\n    //                 block.timestamp,\\n    //                 block.prevrandao,\\n    //                 activeUser,\\n    //                 dice1\\n    //             )\\n    //         )\\n    //     ) % 6) + 1;\\n    //     total = dice1 + dice2;\\n    //     emit RolledDice(activeUser, dice1, dice2);\\n    //     if (dice1 == dice2) {\\n    //         snake = true;\\n    //     }\\n    // }\\n\\n    function _incrementGameState(uint256 _gameID) internal {\\n        address newPlayer = _getNextPlayer(_gameID);\\n\\n        // console.log(\\\"Changing player to\\\", newPlayer);\\n        address oldCurrentPlayer = idToGameState[_gameID].currentPlayer;\\n        // console.log(\\\"player\\\", oldCurrentPlayer, newPlayer);\\n\\n        require(\\n            !userRoll[oldCurrentPlayer],\\n            \\\"can not change while a user can still roll\\\"\\n        );\\n        //Change current player\\n        //Reset their total number of rolls in a  row\\n        userRollsRow[oldCurrentPlayer] = 0;\\n\\n        idToGameState[_gameID].currentPlayer = newPlayer;\\n        // console.log(idToGameState[_gameID].currentPlayer);\\n        userRoll[newPlayer] = true;\\n    }\\n\\n    function _getNextPlayer(\\n        uint256 _gameID\\n    ) internal view returns (address newPlayer) {\\n        address oldCurrentPlayer = idToGameState[_gameID].currentPlayer;\\n        // console.log(\\\"Old player\\\", oldCurrentPlayer);\\n        uint i = 0;\\n        for (i = 0; i < idToGameState[_gameID].players.length; i++) {\\n            // console.log(idToGameState[_gameID].players[i]);\\n            if (idToGameState[_gameID].players[i] == oldCurrentPlayer) {\\n                break;\\n            }\\n        }\\n        uint256 nextIndex = (i + 1) % idToGameState[_gameID].players.length;\\n        //Lets say there are 3 players\\n        // 3 % 3\\n        return idToGameState[_gameID].players[nextIndex];\\n    }\\n\\n    function testMove(\\n        address activeUser,\\n        uint256 stepsFoward,\\n        bool rollAgain\\n    ) public {\\n        require(gameID > 0, \\\"No Game Created\\\");\\n        uint256 currentGameID = addressToGame[activeUser];\\n        // console.log(idToGameState[currentGameID].currentPlayer == activeUser);\\n        require(\\n            idToGameState[currentGameID].currentPlayer == activeUser,\\n            \\\"Must be current Player\\\"\\n        );\\n\\n        require(userRoll[activeUser], \\\"User cannot roll\\\");\\n        userRoll[activeUser] = false;\\n        // (bool rollAgain, uint256 steps)//We would stop here and wait for chainlink to respnd if using it\\n        if (userInJail[activeUser]) {\\n            daysInJail[activeUser]++;\\n            // console.log(daysInJail[activeUser]);\\n            if (rollAgain || daysInJail[activeUser] >= 2) {\\n                // console.log(\\\"User leaves jail\\\");\\n                //User leaves jail\\n                userInJail[activeUser] = false;\\n            }\\n            stepsFoward = 0;\\n            rollAgain = false;\\n        }\\n\\n        if (rollAgain) {\\n            userRoll[activeUser] = true;\\n            userRollsRow[activeUser]++;\\n            if (userRollsRow[activeUser] > 3) {\\n                sendUserToJail(activeUser);\\n            }\\n        }\\n\\n        _updatePlayerPosition(currentGameID, activeUser, stepsFoward);\\n        _incrementGameState(currentGameID);\\n    }\\n\\n    function _updatePlayerPosition(\\n        uint256 _gameID,\\n        address player,\\n        uint256 stepsFoward\\n    ) internal {\\n        if (stepsFoward == 0) {\\n            return;\\n        }\\n        idToGameState[_gameID].playerPosition[player] += stepsFoward;\\n        if (idToGameState[_gameID].playerPosition[player] >= MAX_STEPS) {\\n            emit CrossedGo(player);\\n            //Need to give the player moneys here!\\n            // SafeERC20.safeTransfer(\\n            //     IERC20(idToGameState[_gameID].chosenCurrency),\\n            //     player,\\n            //     10 * 10 ** 18\\n            // );\\n            userBalance[player] += 10 * 10 ** 18;\\n            //User arrived at the start\\n            idToGameState[_gameID].playerPosition[player] -= MAX_STEPS;\\n        }\\n        uint256 finalPosition = idToGameState[_gameID].playerPosition[player];\\n        if (finalPosition == 5) {\\n            //They are visiitng jail\\n            emit VisitJail(player);\\n            return;\\n        }\\n        if (finalPosition == 10) {\\n            //They are getting an air drop\\n            //Deposit their total number of steps up until that point\\n\\n            emit ReceivingAirdrop(player, stepsFoward * 10 ** 17);\\n            // SafeERC20.safeTransfer(\\n            //     IERC20(idToGameState[_gameID].chosenCurrency),\\n            //     player,\\n            //     stepsFoward * 10 ** 17\\n            // );\\n            userBalance[player] += stepsFoward * 10 ** 17;\\n\\n            return;\\n        }\\n        if (finalPosition == 15) {\\n            sendUserToJail(player);\\n            return;\\n        }\\n        if (finalPosition == 0) {\\n            return;\\n        }\\n        // console.log(\\\"RE\\\", rentExists[finalPosition], finalPosition);\\n        if (rentExists[finalPosition]) {\\n            //Rent exists on this point, take money\\n            Property activeProp = getProperty(finalPosition);\\n            uint256 baseRent = activeProp.getBaseRent(finalPosition) * 10 ** 16;\\n            address[] memory userList = idToGameState[_gameID].players;\\n\\n            for (uint i = 0; i < userList.length; i++) {\\n                if (activeProp.balanceOf(userList[i]) > 0) {\\n                    //The user has money\\n                    uint256 userRent = (baseRent *\\n                        activeProp.balanceOf(userList[i])) /\\n                        activeProp.totalSupply();\\n                    if (\\n                        IERC20(idToGameState[_gameID].chosenCurrency).balanceOf(\\n                            player\\n                        ) < userRent\\n                    ) {\\n                        emit UserLose(player);\\n                        _removePlayer(player);\\n                        return;\\n                    }\\n                    userBalance[player] -= userRent;\\n                    // SafeERC20.safeTransferFrom(\\n                    //     IERC20(idToGameState[_gameID].chosenCurrency),\\n                    //     player,\\n                    //     address(this),\\n                    //     userRent\\n                    // );\\n                    // SafeERC20.safeTransfer(\\n                    //     IERC20(idToGameState[_gameID].chosenCurrency),\\n                    //     userList[i],\\n                    //     userRent\\n                    // );\\n                    userBalance[userList[i]] += userRent;\\n                    emit RentPaid(player, userRent);\\n                    // console.log(\\\"Transfer funds\\\", userRent);\\n                }\\n            }\\n        }\\n    }\\n\\n    function addNames(string[] memory list) public {\\n        require(list.length % 2 == 0, \\\"Must be even\\\");\\n        require(list.length > 0, \\\"Must have stuff \\\");\\n        usualNamesAndSymbols = list;\\n    }\\n\\n    function _removePlayer(address player) public {\\n        uint256 currentGame = addressToGame[player];\\n        uint256 playerIndex = idToGameState[currentGame].numberOfPlayers; // Set to an invalid index initially\\n\\n        // Find the index of the player in the array\\n        for (uint i = 0; i < idToGameState[currentGame].players.length; i++) {\\n            if (idToGameState[currentGame].players[i] == player) {\\n                playerIndex = i;\\n                break;\\n            }\\n        }\\n\\n        require(\\n            playerIndex < idToGameState[currentGame].numberOfPlayers,\\n            \\\"Player not found\\\"\\n        );\\n\\n        // Shift the elements to the left to fill the gap\\n        for (\\n            uint i = playerIndex;\\n            i < idToGameState[currentGame].players.length - 1;\\n            i++\\n        ) {\\n            idToGameState[currentGame].players[i] = idToGameState[currentGame]\\n                .players[i + 1];\\n        }\\n\\n        // Remove the last element (now a duplicate)\\n        idToGameState[currentGame].players.pop();\\n\\n        // Decrement the number of players\\n        // console.log(idToGameState[currentGame].players.length);\\n        idToGameState[currentGame].numberOfPlayers--;\\n        // console.log(idToGameState[currentGame].players.length);\\n        if (idToGameState[currentGame].players.length == 1) {\\n            //A player can win\\n            emit PlayerWon(\\n                player,\\n                IERC20(idToGameState[currentGame].chosenCurrency).balanceOf(\\n                    address(this)\\n                )\\n            );\\n\\n            // SafeERC20.safeTransfer(\\n            //     IERC20(idToGameState[currentGame].chosenCurrency),\\n            //     player,\\n            //     IERC20(idToGameState[currentGame].chosenCurrency).balanceOf(\\n            //         address(this)\\n            //     )\\n            // );\\n            userBalance[player] += IERC20(\\n                idToGameState[currentGame].chosenCurrency\\n            ).balanceOf(address(this));\\n        }\\n    }\\n\\n    function getProperty(uint256 position) public view returns (Property prop) {\\n        Property[] memory list = getActiveProperties();\\n        for (uint i = 0; i < list.length; i++) {\\n            if (list[i].canUserPurchase(position)) {\\n                return list[i];\\n            }\\n        }\\n        return Property(address(0));\\n    }\\n\\n    function purchaseProperty(\\n        address activeUser,\\n        uint256 amountToSpend,\\n        address property\\n    ) public returns (uint256) {\\n        uint256 currentGameID = addressToGame[activeUser];\\n        PoolKey memory pk = addressToKey[property];\\n\\n        //Assume that the currency is token0 and the property is token1\\n        bool zeroForOne = true;\\n        uint160 sqrtPriceLimit = 1461446703485210103287273052203988822378723970342;\\n\\n        if (property < idToGameState[currentGameID].chosenCurrency) {\\n            zeroForOne = false;\\n            sqrtPriceLimit = 4295128740;\\n        }\\n        int256 amountSpecified = int256(amountToSpend);\\n        IPoolManager.SwapParams memory params = IPoolManager.SwapParams(\\n            zeroForOne,\\n            amountSpecified,\\n            sqrtPriceLimit\\n        );\\n        // console.log(userBalance[activeUser], amountToSpend);\\n        userBalance[activeUser] -= amountToSpend;\\n        // SafeERC20.safeTransferFrom(\\n        //     IERC20(idToGameState[currentGameID].chosenCurrency),\\n        //     activeUser,\\n        //     address(this),\\n        //     amountToSpend\\n        // );\\n        // console.log(\\\"Game\\\", address(this));\\n        SafeERC20.forceApprove(\\n            IERC20(idToGameState[currentGameID].chosenCurrency),\\n            address(mainHook),\\n            amountToSpend + 1\\n        );\\n\\n        mainHook.swap(pk, params, block.timestamp + 100, activeUser);\\n        uint256 currentPosition = getPlayerPosition(activeUser);\\n        // console.log(\\\"Property purchased\\\", currentPosition);\\n        rentExists[currentPosition] = true;\\n\\n        SafeERC20.safeTransfer(\\n            IERC20(property),\\n            activeUser,\\n            IERC20(property).balanceOf(address(this))\\n        );\\n    }\\n\\n    function sellProperty(\\n        address activeUser,\\n        uint256 amountToSell,\\n        address property\\n    ) public returns (uint256) {\\n        uint256 currentGameID = addressToGame[activeUser];\\n        PoolKey memory pk = addressToKey[property];\\n\\n        //Assume that the currency is token0 and the property is token1\\n        IPoolManager.SwapParams memory params;\\n        {\\n            bool zeroForOne = false;\\n            uint160 sqrtPriceLimit = 1461446703485210103287273052203988822378723970342;\\n\\n            if (property < idToGameState[currentGameID].chosenCurrency) {\\n                zeroForOne = true;\\n                sqrtPriceLimit = 4295128740;\\n            }\\n            int256 amountSpecified = int256(amountToSell);\\n            params = IPoolManager.SwapParams(\\n                zeroForOne,\\n                amountSpecified,\\n                sqrtPriceLimit\\n            );\\n        }\\n        SafeERC20.safeTransferFrom(\\n            IERC20(property),\\n            activeUser,\\n            address(this),\\n            amountToSell\\n        );\\n        // console.log(\\\"Game\\\", address(this));\\n        SafeERC20.safeApprove(\\n            IERC20(property),\\n            address(mainHook),\\n            amountToSell\\n        );\\n\\n        (int256 amount0, int256 amount1) = mainHook.swap(\\n            pk,\\n            params,\\n            block.timestamp + 100,\\n            activeUser\\n        );\\n        uint256 amountOwed = 0;\\n        if (amount0 < 0) {\\n            amountOwed = uint256(-1 * amount0);\\n        }\\n        if (amount1 < 0) {\\n            amountOwed = uint256(-1 * amount1);\\n        }\\n        address[] memory userList = idToGameState[currentGameID].players;\\n\\n        rentExists[getPlayerPosition(activeUser)] = false;\\n        for (uint i = 0; i < userList.length; i++) {\\n            if (Property(property).balanceOf(userList[i]) > 0) {\\n                rentExists[getPlayerPosition(activeUser)] = true;\\n            }\\n        }\\n        userBalance[activeUser] += amountOwed;\\n        // SafeERC20.safeTransfer(\\n        //     IERC20(idToGameState[currentGameID].chosenCurrency),\\n        //     activeUser,\\n        //     amountOwed\\n        // );\\n    }\\n\\n    mapping(address => uint256) public daysInJail;\\n    mapping(address => bool) public userInJail;\\n\\n    function sendUserToJail(address user) internal {\\n        emit SentToJail(user);\\n        daysInJail[user] = 0;\\n        userInJail[user] = true;\\n    }\\n\\n    function getMyPosition() public view returns (uint256) {\\n        return getPlayerPosition(msg.sender);\\n    }\\n\\n    function getMyProperties(\\n        address user\\n    ) public view returns (Property[] memory) {\\n        Property[] memory list = getActiveProperties();\\n        uint count = 0;\\n\\n        // First pass: count properties owned by the sender\\n        for (uint i = 0; i < list.length; i++) {\\n            if (list[i].balanceOf(user) > 0) {\\n                count++;\\n            }\\n        }\\n\\n        // Initialize a new array with the correct size\\n        Property[] memory newList = new Property[](count);\\n        uint index = 0;\\n\\n        // Second pass: populate the array\\n        for (uint i = 0; i < list.length; i++) {\\n            if (list[i].balanceOf(user) > 0) {\\n                newList[index] = list[i];\\n                index++;\\n            }\\n        }\\n\\n        return newList;\\n    }\\n\\n    function getBalanceOfProperty(\\n        address user,\\n        Property prop\\n    ) public view returns (uint256) {\\n        return prop.balanceOf(user);\\n    }\\n\\n    function getAllProperties() public view returns (string[] memory list) {\\n        return usualNamesAndSymbols;\\n    }\\n\\n    function getActiveProperties()\\n        public\\n        view\\n        returns (Property[] memory list)\\n    {\\n        if (gameID == 0) {\\n            revert(\\\"\\\");\\n        }\\n        uint256 currentGameID = gameID - 1;\\n        return idToGameState[currentGameID].propertyList;\\n    }\\n\\n    //These are all of the helper fucntions for a game\\n    function getActiveNumberOfPlayers() public view returns (uint256) {\\n        if (gameID == 0) {\\n            return 0;\\n        }\\n        uint256 currentGameID = gameID - 1;\\n        return idToGameState[currentGameID].numberOfPlayers;\\n    }\\n\\n    function getActiveGameID() public view returns (uint256) {\\n        if (gameID == 0) {\\n            return 0;\\n        }\\n        uint256 currentGameID = gameID - 1;\\n        return currentGameID;\\n    }\\n\\n    function getActivePlayers() public view returns (address[] memory) {\\n        if (gameID == 0) {\\n            address[] memory list;\\n            return list;\\n        }\\n        uint256 currentGameID = gameID - 1;\\n        return idToGameState[currentGameID].players;\\n    }\\n\\n    function getCurrentChosenCurrency() public view returns (address) {\\n        if (gameID == 0) {\\n            return address(0);\\n        }\\n        uint256 currentGameID = gameID - 1;\\n        return idToGameState[currentGameID].chosenCurrency;\\n    }\\n\\n    function getCurrentPlayer() public view returns (address player) {\\n        if (gameID == 0) {\\n            return address(0);\\n        }\\n        uint256 currentGameID = gameID - 1;\\n        return idToGameState[currentGameID].currentPlayer;\\n    }\\n\\n    function returnPropertyUnderPlayer(\\n        address player\\n    ) public view returns (address) {\\n        uint256 currentGameID = addressToGame[player];\\n        uint256 positon = getPlayerPosition(player);\\n\\n        for (\\n            uint256 i = 0;\\n            i < idToGameState[currentGameID].propertyList.length;\\n            i++\\n        ) {\\n            Property property = idToGameState[currentGameID].propertyList[i];\\n            if (property.canUserPurchase(positon)) {\\n                return address(property);\\n            }\\n        }\\n        return address(0);\\n    }\\n\\n    function getPlayerPosition(\\n        address user\\n    ) public view returns (uint256 position) {\\n        if (gameID == 0) {\\n            return 0;\\n        }\\n        uint256 currentGameID = gameID - 1;\\n        return idToGameState[currentGameID].playerPosition[user];\\n    }\\n\\n    function getBankBalance() public view returns (uint256 balance) {\\n        if (gameID == 0) {\\n            return 0;\\n        }\\n        uint256 currentGameID = gameID - 1;\\n        return\\n            IERC20(idToGameState[currentGameID].chosenCurrency).balanceOf(\\n                address(this)\\n            );\\n    }\\n\\n    uint256 public messageCount;\\n\\n    function mintWrapper(Custom oldAddress) public returns (address) {\\n        string memory name = \\\"Token Town\\\";\\n        string memory symb = \\\"TTN\\\";\\n\\n        Custom custom = new Custom(name, symb);\\n        return address(custom);\\n    }\\n\\n    function getBuyIn() public view returns (uint256) {\\n        if (gameID == 0) {\\n            revert(\\\"No games exist\\\");\\n        }\\n        uint256 curentGame = gameID - 1;\\n        uint256 buyIn = idToGameState[curentGame].buyIn /\\n            idToGameState[curentGame].players.length;\\n        return buyIn;\\n    }\\n\\n    // Hyperlane functions\\n\\n    function interchainSecurityModule()\\n        external\\n        view\\n        returns (IInterchainSecurityModule)\\n    {\\n        return IInterchainSecurityModule(ism);\\n    }\\n}\\n\\n//Idea for how game is going to work\\n//There are 8 different property groups\\n// There are railways\\n//Community Chests & Chance Cards\\n//Free Parking\\n//Jail\\n//Go\\n\\n//The struct will contain all of the players\\n//Lets say there are four players\\n\\n//We use ChainLink for getting Dice\\n\",\"keccak256\":\"0x9cc15e9c54829c03ef179682ddc9c7338f99f15dd2541504bdef8a73ea57ef31\",\"license\":\"MIT\"},\"contracts/TokenTown/IGame.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.24;\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {Property} from \\\"./Property.sol\\\";\\n\\ninterface IGame {\\n    //Below are the events\\n    event GameStarted(address indexed starter, uint256 gameStarted);\\n    event CrossedGo(address indexed player);\\n    event RolledDice(address indexed player, uint256 dice1, uint256 dice2);\\n    event VisitJail(address indexed player);\\n    event SentToJail(address indexed player);\\n    event PlayerWon(address indexed player, uint256 amount);\\n    event ReceivingAirdrop(address indexed player, uint256 amount);\\n    event RentPaid(address indexed player, uint256 amount);\\n    event UserLose(address indexed player);\\n\\n    type player is address;\\n\\n    //Below are the structs\\n    struct GameState {\\n        address currentPlayer; //This is the player that is rolling\\n        address[] players; //Array of the players in the game\\n        uint256 numberOfPlayers; //The total number of players\\n        address chosenCurrency; //The chosen currency (e.g HypApeCoin or USDC)\\n        mapping(address => uint256) playerPosition; //Goes from player address to position on board\\n        mapping(address => address) playerOwnedProperty;\\n        Property[] propertyList; //List of all properties\\n        uint256 buyIn;\\n    }\\n}\\n\",\"keccak256\":\"0xeef92548fe20ce795fb9283a7aab3652704f83dd1d8ddb19622b721aefc05749\",\"license\":\"MIT\"},\"contracts/TokenTown/LukeReceiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.24;\\n\\nimport \\\"hardhat/console.sol\\\";\\nimport {IGame} from \\\"./IGame.sol\\\";\\nimport {Property} from \\\"./Property.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@chainlink/contracts/src/v0.8/vrf/VRFConsumerBaseV2.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {IPoolManager} from \\\"../Uniswap/V4-Core/interfaces/IPoolManager.sol\\\";\\n\\nimport {Currency, CurrencyLibrary} from \\\"../Uniswap/V4-Core/types/Currency.sol\\\";\\nimport {PoolKey} from \\\"../Uniswap/V4-Core/types/PoolKey.sol\\\";\\nimport {MyHook} from \\\"../MyHook.sol\\\";\\nimport {IHooks} from \\\"../Uniswap/V4-Core/interfaces/IHooks.sol\\\";\\nimport {TickMath} from \\\"../Uniswap/V4-Core/libraries/TickMath.sol\\\";\\n\\nimport {IInterchainSecurityModule} from \\\"../Hyperlane/NullISM.sol\\\";\\n// import {ERC20} from \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport {Custom} from \\\"../Mocks/Custom.sol\\\";\\nimport {Game} from \\\"./Game.sol\\\";\\n\\ncontract LukeRecieve {\\n    address public ism = 0x1F02fA4F142e0727CC3f2eC84433aB513F977657;\\n    Game public game;\\n\\n    constructor(address _game) {\\n        game = Game(_game);\\n        // You can use console.log for debugging purposes\\n        // console.log(\\\"Game contract deployed by:\\\", activeUser);\\n        // console.log(\\\"Pool Manager set to:\\\", poolManager);\\n    }\\n\\n    uint256 public messageCount = 0;\\n\\n    // Hyperlane functions\\n    function handle(\\n        uint32 _origin,\\n        bytes32 _sender,\\n        bytes calldata _message\\n    ) external payable {\\n        messageCount++;\\n        (address user, uint256 action, bytes memory data) = abi.decode(\\n            _message,\\n            (address, uint256, bytes)\\n        );\\n\\n        if (action == 0) {\\n            // console.log(\\\"Action 0\\\");\\n            //setUp()\\n            (address selToken, uint256 bankStart) = abi.decode(\\n                data,\\n                (address, uint256)\\n            );\\n            game.setUp(user, selToken, bankStart);\\n        } else if (action == 1) {\\n            game.joinGame(user);\\n        } else if (action == 2) {\\n            // console.log(\\\"Action 2\\\");\\n            //startGame()\\n            game.startGame(user);\\n        } else if (action == 3) {} else if (action == 4) {\\n            // console.log(\\\"Action 4\\\");\\n            (uint256 steps, bool snake) = abi.decode(data, (uint256, bool));\\n            game.testMove(user, steps, snake);\\n        } else if (action == 5) {\\n            // console.log(\\\"Action 5\\\");\\n            (uint256 amount, address property) = abi.decode(\\n                data,\\n                (uint256, address)\\n            );\\n            game.purchaseProperty(user, amount, property);\\n            //purchaseProperty()\\n        } else if (action == 6) {\\n            // console.log(\\\"Action 6\\\");\\n            (uint256 amount, address property) = abi.decode(\\n                data,\\n                (uint256, address)\\n            );\\n            game.sellProperty(user, amount, property);\\n\\n            //sellProperty()\\n        } else if (action == 7) {\\n            // console.log(\\\"Action 7\\\");\\n        } else {\\n            // console.log(\\\"Not real\\\");\\n        }\\n    }\\n\\n    function interchainSecurityModule()\\n        external\\n        view\\n        returns (IInterchainSecurityModule)\\n    {\\n        return IInterchainSecurityModule(ism);\\n    }\\n}\\n\",\"keccak256\":\"0x167e5ea7dbd3d0188731f3e4e202534281a9da541f8d042e2c6a4fe75be3fcc1\",\"license\":\"MIT\"},\"contracts/TokenTown/Property.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\ncontract Property is ERC20 {\\n    mapping(address => uint256) userToHouse; //This records how many houses a user has\\n    address immutable theBank;\\n\\n    uint256 position; //Marks the start\\n    uint256 priceStart = 0;\\n    uint256 rentStart = 0;\\n    uint256 priceIncrease = 0;\\n    uint256 length = 4;\\n\\n    constructor(\\n        string memory name,\\n        string memory symb,\\n        uint256 supply,\\n        uint256 _position,\\n        uint256 _price,\\n        uint256 _rent,\\n        uint256 _increase\\n    ) ERC20(name, symb) {\\n        _mint(msg.sender, supply * 10 ** 18);\\n        // console.log(\\\"set token\\\", _price, _increase);\\n        theBank = msg.sender;\\n        position = _position;\\n        priceStart = _price;\\n        rentStart = _rent;\\n        priceIncrease = _increase;\\n    }\\n\\n    modifier onlyBank() {\\n        require(msg.sender == theBank);\\n        _;\\n    }\\n\\n    function addHouse(address user) public onlyBank {\\n        userToHouse[user]++;\\n    }\\n\\n    function getBaseRent(\\n        uint256 playerPoint\\n    ) public view returns (uint256 rent) {\\n        uint256 amountAfter = playerPoint - position;\\n        rent = rentStart + priceIncrease * amountAfter;\\n        console.log(rentStart, priceIncrease, amountAfter);\\n        return rent;\\n    }\\n\\n    function getPrice(uint256 playerPoint) public view returns (uint256 price) {\\n        uint256 amountAfter = playerPoint - position;\\n        price = priceStart + priceIncrease * amountAfter;\\n        console.log(priceStart, priceIncrease, amountAfter);\\n        return price;\\n    }\\n\\n    function canUserPurchase(uint256 userPosition) public view returns (bool) {\\n        if (position <= userPosition && userPosition <= position + length) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    function getPriceStart() public view returns (uint256) {\\n        return priceStart;\\n    }\\n\\n    function getPriceIncrease() public view returns (uint256) {\\n        return priceIncrease;\\n    }\\n}\\n\",\"keccak256\":\"0x6219cf63df387c9331831e5d3a294c2dd1c36ea2b6dc81f1d8e76ec4d4de28da\",\"license\":\"MIT\"},\"contracts/Uniswap/V4-Core/interfaces/IFees.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport {Currency} from \\\"../types/Currency.sol\\\";\\n\\ninterface IFees {\\n    /// @notice Thrown when the protocol fee denominator is less than 4. Also thrown when the static or dynamic fee on a pool is exceeds 100%.\\n    error FeeTooLarge();\\n    /// @notice Thrown when not enough gas is provided to look up the protocol fee\\n    error ProtocolFeeCannotBeFetched();\\n    /// @notice Thrown when the call to fetch the protocol fee reverts or returns invalid data.\\n    error ProtocolFeeControllerCallFailedOrInvalidResult();\\n    /// @notice Thrown when a pool does not have a dynamic fee.\\n    error FeeNotDynamic();\\n\\n    event ProtocolFeeControllerUpdated(address protocolFeeController);\\n\\n    /// @notice Returns the minimum denominator for the protocol fee, which restricts it to a maximum of 25%\\n    function MIN_PROTOCOL_FEE_DENOMINATOR() external view returns (uint8);\\n\\n    /// @notice Given a currency address, returns the protocol fees accrued in that currency\\n    function protocolFeesAccrued(Currency) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x258a0d4d7e4af7ef84175c8954dba586879222395e218926a223dda40780e40e\",\"license\":\"MIT\"},\"contracts/Uniswap/V4-Core/interfaces/IHooks.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.24;\\n\\nimport {PoolKey} from \\\"../types/PoolKey.sol\\\";\\nimport {BalanceDelta} from \\\"../types/BalanceDelta.sol\\\";\\nimport {IPoolManager} from \\\"./IPoolManager.sol\\\";\\n\\n/// @notice The PoolManager contract decides whether to invoke specific hooks by inspecting the leading bits\\n/// of the hooks contract address. For example, a 1 bit in the first bit of the address will\\n/// cause the 'before swap' hook to be invoked. See the Hooks library for the full spec.\\n/// @dev Should only be callable by the v4 PoolManager.\\ninterface IHooks {\\n    /// @notice The hook called before the state of a pool is initialized\\n    /// @param sender The initial msg.sender for the initialize call\\n    /// @param key The key for the pool being initialized\\n    /// @param sqrtPriceX96 The sqrt(price) of the pool as a Q64.96\\n    /// @param hookData Arbitrary data handed into the PoolManager by the initializer to be be passed on to the hook\\n    /// @return bytes4 The function selector for the hook\\n    function beforeInitialize(address sender, PoolKey calldata key, uint160 sqrtPriceX96, bytes calldata hookData)\\n        external\\n        returns (bytes4);\\n\\n    /// @notice The hook called after the state of a pool is initialized\\n    /// @param sender The initial msg.sender for the initialize call\\n    /// @param key The key for the pool being initialized\\n    /// @param sqrtPriceX96 The sqrt(price) of the pool as a Q64.96\\n    /// @param tick The current tick after the state of a pool is initialized\\n    /// @param hookData Arbitrary data handed into the PoolManager by the initializer to be be passed on to the hook\\n    /// @return bytes4 The function selector for the hook\\n    function afterInitialize(\\n        address sender,\\n        PoolKey calldata key,\\n        uint160 sqrtPriceX96,\\n        int24 tick,\\n        bytes calldata hookData\\n    ) external returns (bytes4);\\n\\n    /// @notice The hook called before liquidity is added\\n    /// @param sender The initial msg.sender for the add liquidity call\\n    /// @param key The key for the pool\\n    /// @param params The parameters for adding liquidity\\n    /// @param hookData Arbitrary data handed into the PoolManager by the liquidty provider to be be passed on to the hook\\n    /// @return bytes4 The function selector for the hook\\n    function beforeAddLiquidity(\\n        address sender,\\n        PoolKey calldata key,\\n        IPoolManager.ModifyLiquidityParams calldata params,\\n        bytes calldata hookData\\n    ) external returns (bytes4);\\n\\n    /// @notice The hook called after liquidity is added\\n    /// @param sender The initial msg.sender for the add liquidity call\\n    /// @param key The key for the pool\\n    /// @param params The parameters for adding liquidity\\n    /// @param hookData Arbitrary data handed into the PoolManager by the liquidty provider to be be passed on to the hook\\n    /// @return bytes4 The function selector for the hook\\n    function afterAddLiquidity(\\n        address sender,\\n        PoolKey calldata key,\\n        IPoolManager.ModifyLiquidityParams calldata params,\\n        BalanceDelta delta,\\n        bytes calldata hookData\\n    ) external returns (bytes4);\\n\\n    /// @notice The hook called before liquidity is removed\\n    /// @param sender The initial msg.sender for the remove liquidity call\\n    /// @param key The key for the pool\\n    /// @param params The parameters for removing liquidity\\n    /// @param hookData Arbitrary data handed into the PoolManager by the liquidty provider to be be passed on to the hook\\n    /// @return bytes4 The function selector for the hook\\n    function beforeRemoveLiquidity(\\n        address sender,\\n        PoolKey calldata key,\\n        IPoolManager.ModifyLiquidityParams calldata params,\\n        bytes calldata hookData\\n    ) external returns (bytes4);\\n\\n    /// @notice The hook called after liquidity is removed\\n    /// @param sender The initial msg.sender for the remove liquidity call\\n    /// @param key The key for the pool\\n    /// @param params The parameters for removing liquidity\\n    /// @param hookData Arbitrary data handed into the PoolManager by the liquidty provider to be be passed on to the hook\\n    /// @return bytes4 The function selector for the hook\\n    function afterRemoveLiquidity(\\n        address sender,\\n        PoolKey calldata key,\\n        IPoolManager.ModifyLiquidityParams calldata params,\\n        BalanceDelta delta,\\n        bytes calldata hookData\\n    ) external returns (bytes4);\\n\\n    /// @notice The hook called before a swap\\n    /// @param sender The initial msg.sender for the swap call\\n    /// @param key The key for the pool\\n    /// @param params The parameters for the swap\\n    /// @param hookData Arbitrary data handed into the PoolManager by the swapper to be be passed on to the hook\\n    /// @return bytes4 The function selector for the hook\\n    function beforeSwap(\\n        address sender,\\n        PoolKey calldata key,\\n        IPoolManager.SwapParams calldata params,\\n        bytes calldata hookData\\n    ) external returns (bytes4);\\n\\n    /// @notice The hook called after a swap\\n    /// @param sender The initial msg.sender for the swap call\\n    /// @param key The key for the pool\\n    /// @param params The parameters for the swap\\n    /// @param delta The amount owed to the locker (positive) or owed to the pool (negative)\\n    /// @param hookData Arbitrary data handed into the PoolManager by the swapper to be be passed on to the hook\\n    /// @return bytes4 The function selector for the hook\\n    function afterSwap(\\n        address sender,\\n        PoolKey calldata key,\\n        IPoolManager.SwapParams calldata params,\\n        BalanceDelta delta,\\n        bytes calldata hookData\\n    ) external returns (bytes4);\\n\\n    /// @notice The hook called before donate\\n    /// @param sender The initial msg.sender for the donate call\\n    /// @param key The key for the pool\\n    /// @param amount0 The amount of token0 being donated\\n    /// @param amount1 The amount of token1 being donated\\n    /// @param hookData Arbitrary data handed into the PoolManager by the donor to be be passed on to the hook\\n    /// @return bytes4 The function selector for the hook\\n    function beforeDonate(\\n        address sender,\\n        PoolKey calldata key,\\n        uint256 amount0,\\n        uint256 amount1,\\n        bytes calldata hookData\\n    ) external returns (bytes4);\\n\\n    /// @notice The hook called after donate\\n    /// @param sender The initial msg.sender for the donate call\\n    /// @param key The key for the pool\\n    /// @param amount0 The amount of token0 being donated\\n    /// @param amount1 The amount of token1 being donated\\n    /// @param hookData Arbitrary data handed into the PoolManager by the donor to be be passed on to the hook\\n    /// @return bytes4 The function selector for the hook\\n    function afterDonate(\\n        address sender,\\n        PoolKey calldata key,\\n        uint256 amount0,\\n        uint256 amount1,\\n        bytes calldata hookData\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0x2945308da700faaf6c956e0fb67bbc1880af1ed1e04a086e8cb2f2268747f31a\",\"license\":\"MIT\"},\"contracts/Uniswap/V4-Core/interfaces/IPoolManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.24;\\n\\nimport {Currency} from \\\"../types/Currency.sol\\\";\\nimport {PoolKey} from \\\"../types/PoolKey.sol\\\";\\nimport {Pool} from \\\"../libraries/Pool.sol\\\";\\nimport {IHooks} from \\\"./IHooks.sol\\\";\\nimport {IERC6909Claims} from \\\"./external/IERC6909Claims.sol\\\";\\nimport {IFees} from \\\"./IFees.sol\\\";\\nimport {BalanceDelta} from \\\"../types/BalanceDelta.sol\\\";\\nimport {PoolId} from \\\"../types/PoolId.sol\\\";\\nimport {Position} from \\\"../libraries/Position.sol\\\";\\n\\ninterface IPoolManager is IFees, IERC6909Claims {\\n    /// @notice Thrown when currencies touched has exceeded max of 256\\n    error MaxCurrenciesTouched();\\n\\n    /// @notice Thrown when a currency is not netted out after a lock\\n    error CurrencyNotSettled();\\n\\n    /// @notice Thrown when trying to interact with a non-initialized pool\\n    error PoolNotInitialized();\\n\\n    /// @notice Thrown when lock is called, but a lock is already open\\n    error AlreadyLocked();\\n\\n    /// @notice Thrown when a function is called outside of a lock\\n    error ManagerNotLocked();\\n\\n    /// @notice The ERC1155 being deposited is not the Uniswap ERC1155\\n    error NotPoolManagerToken();\\n\\n    /// @notice Pools are limited to type(int16).max tickSpacing in #initialize, to prevent overflow\\n    error TickSpacingTooLarge();\\n    /// @notice Pools must have a positive non-zero tickSpacing passed to #initialize\\n    error TickSpacingTooSmall();\\n\\n    /// @notice PoolKey must have currencies where address(currency0) < address(currency1)\\n    error CurrenciesOutOfOrderOrEqual();\\n\\n    /// @notice Emitted when a new pool is initialized\\n    /// @param id The abi encoded hash of the pool key struct for the new pool\\n    /// @param currency0 The first currency of the pool by address sort order\\n    /// @param currency1 The second currency of the pool by address sort order\\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\\n    /// @param hooks The hooks contract address for the pool, or address(0) if none\\n    event Initialize(\\n        PoolId indexed id,\\n        Currency indexed currency0,\\n        Currency indexed currency1,\\n        uint24 fee,\\n        int24 tickSpacing,\\n        IHooks hooks\\n    );\\n\\n    /// @notice Emitted when a liquidity position is modified\\n    /// @param id The abi encoded hash of the pool key struct for the pool that was modified\\n    /// @param sender The address that modified the pool\\n    /// @param tickLower The lower tick of the position\\n    /// @param tickUpper The upper tick of the position\\n    /// @param liquidityDelta The amount of liquidity that was added or removed\\n    event ModifyLiquidity(\\n        PoolId indexed id,\\n        address indexed sender,\\n        int24 tickLower,\\n        int24 tickUpper,\\n        int256 liquidityDelta\\n    );\\n\\n    /// @notice Emitted for swaps between currency0 and currency1\\n    /// @param id The abi encoded hash of the pool key struct for the pool that was modified\\n    /// @param sender The address that initiated the swap call, and that received the callback\\n    /// @param amount0 The delta of the currency0 balance of the pool\\n    /// @param amount1 The delta of the currency1 balance of the pool\\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\\n    /// @param liquidity The liquidity of the pool after the swap\\n    /// @param tick The log base 1.0001 of the price of the pool after the swap\\n    event Swap(\\n        PoolId indexed id,\\n        address indexed sender,\\n        int128 amount0,\\n        int128 amount1,\\n        uint160 sqrtPriceX96,\\n        uint128 liquidity,\\n        int24 tick,\\n        uint24 fee\\n    );\\n\\n    event ProtocolFeeUpdated(PoolId indexed id, uint16 protocolFee);\\n\\n    event DynamicSwapFeeUpdated(PoolId indexed id, uint24 dynamicSwapFee);\\n\\n    /// @notice Returns the constant representing the maximum tickSpacing for an initialized pool key\\n    function MAX_TICK_SPACING() external view returns (int24);\\n\\n    /// @notice Returns the constant representing the minimum tickSpacing for an initialized pool key\\n    function MIN_TICK_SPACING() external view returns (int24);\\n\\n    /// @notice Get the current value in slot0 of the given pool\\n    function getSlot0(\\n        PoolId id\\n    )\\n        external\\n        view\\n        returns (uint160 sqrtPriceX96, int24 tick, uint16 protocolFee);\\n\\n    /// @notice Get the current value of liquidity of the given pool\\n    function getLiquidity(PoolId id) external view returns (uint128 liquidity);\\n\\n    /// @notice Get the current value of liquidity for the specified pool and position\\n    function getLiquidity(\\n        PoolId id,\\n        address owner,\\n        int24 tickLower,\\n        int24 tickUpper\\n    ) external view returns (uint128 liquidity);\\n\\n    /// @notice Getter for TickInfo for the given poolId and tick\\n    function getPoolTickInfo(\\n        PoolId id,\\n        int24 tick\\n    ) external view returns (Pool.TickInfo memory);\\n\\n    /// @notice Getter for the bitmap given the poolId and word position\\n    function getPoolBitmapInfo(\\n        PoolId id,\\n        int16 word\\n    ) external view returns (uint256 tickBitmap);\\n\\n    /// @notice Get the position struct for a specified pool and position\\n    function getPosition(\\n        PoolId id,\\n        address owner,\\n        int24 tickLower,\\n        int24 tickUpper\\n    ) external view returns (Position.Info memory position);\\n\\n    /// @notice Returns the reserves for a given ERC20 currency\\n    function reservesOf(Currency currency) external view returns (uint256);\\n\\n    /// @notice Returns the locker of the pool\\n    function getLocker() external view returns (address locker);\\n\\n    /// @notice Returns the number of nonzero deltas open on the PoolManager that must be zerod by the close of the initial lock.\\n    function getLockNonzeroDeltaCount()\\n        external\\n        view\\n        returns (uint256 _nonzeroDeltaCount);\\n\\n    /// @notice Initialize the state for a given pool ID\\n    function initialize(\\n        PoolKey memory key,\\n        uint160 sqrtPriceX96,\\n        bytes calldata hookData\\n    ) external returns (int24 tick);\\n\\n    /// @notice Get the current delta for a locker in the given currency\\n    /// @param locker The address of the locker\\n    /// @param currency The currency for which to lookup the delta\\n    function currencyDelta(\\n        address locker,\\n        Currency currency\\n    ) external view returns (int256);\\n\\n    /// @notice All operations go through this function\\n    /// @param data Any data to pass to the callback, via `ILockCallback(msg.sender).lockAcquired(data)`\\n    /// @return The data returned by the call to `ILockCallback(msg.sender).lockAcquired(data)`\\n    function lock(bytes calldata data) external payable returns (bytes memory);\\n\\n    struct ModifyLiquidityParams {\\n        // the lower and upper tick of the position\\n        int24 tickLower;\\n        int24 tickUpper;\\n        // how to modify the liquidity\\n        int256 liquidityDelta;\\n    }\\n\\n    /// @notice Modify the liquidity for the given pool\\n    /// @dev Poke by calling with a zero liquidityDelta\\n    /// @param key The pool to modify liquidity in\\n    /// @param params The parameters for modifying the liquidity\\n    /// @param hookData Any data to pass to the callback, via `ILockCallback(msg.sender).lockAcquired(data)`\\n    /// @return delta The balance delta of the liquidity\\n    function modifyLiquidity(\\n        PoolKey memory key,\\n        ModifyLiquidityParams memory params,\\n        bytes calldata hookData\\n    ) external returns (BalanceDelta);\\n\\n    struct SwapParams {\\n        bool zeroForOne;\\n        int256 amountSpecified;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swap against the given pool\\n    function swap(\\n        PoolKey memory key,\\n        SwapParams memory params,\\n        bytes calldata hookData\\n    ) external returns (BalanceDelta);\\n\\n    /// @notice Donate the given currency amounts to the pool with the given pool key\\n    function donate(\\n        PoolKey memory key,\\n        uint256 amount0,\\n        uint256 amount1,\\n        bytes calldata hookData\\n    ) external returns (BalanceDelta);\\n\\n    /// @notice Called by the user to net out some value owed to the user\\n    /// @dev Can also be used as a mechanism for _free_ flash loans\\n    function take(Currency currency, address to, uint256 amount) external;\\n\\n    /// @notice Called by the user to move value into ERC6909 balance\\n    function mint(address to, uint256 id, uint256 amount) external;\\n\\n    /// @notice Called by the user to move value from ERC6909 balance\\n    function burn(address from, uint256 id, uint256 amount) external;\\n\\n    /// @notice Called by the user to pay what is owed\\n    function settle(Currency token) external payable returns (uint256 paid);\\n\\n    /// @notice Sets the protocol's swap fee for the given pool\\n    /// Protocol fees are always a portion of the LP swap fee that is owed. If that fee is 0, no protocol fees will accrue even if it is set to > 0.\\n    function setProtocolFee(PoolKey memory key) external;\\n\\n    /// @notice Updates the pools swap fees for the a pool that has enabled dynamic swap fees.\\n    function updateDynamicSwapFee(PoolKey memory key) external;\\n\\n    /// @notice Called by external contracts to access granular pool state\\n    /// @param slot Key of slot to sload\\n    /// @return value The value of the slot as bytes32\\n    function extsload(bytes32 slot) external view returns (bytes32 value);\\n\\n    /// @notice Called by external contracts to access granular pool state\\n    /// @param slot Key of slot to start sloading from\\n    /// @param nSlots Number of slots to load into return value\\n    /// @return value The value of the sload-ed slots concatenated as dynamic bytes\\n    function extsload(\\n        bytes32 slot,\\n        uint256 nSlots\\n    ) external view returns (bytes memory value);\\n}\\n\",\"keccak256\":\"0x9875f91f04abee14def3d63b0544bdf2bc7d0ca63213857934848d8c9deccdf6\",\"license\":\"MIT\"},\"contracts/Uniswap/V4-Core/interfaces/external/IERC20Minimal.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\n/// @title Minimal ERC20 interface for Uniswap\\n/// @notice Contains a subset of the full ERC20 interface that is used in Uniswap V3\\ninterface IERC20Minimal {\\n    /// @notice Returns the balance of a token\\n    /// @param account The account for which to look up the number of tokens it has, i.e. its balance\\n    /// @return The number of tokens held by the account\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /// @notice Transfers the amount of token from the `msg.sender` to the recipient\\n    /// @param recipient The account that will receive the amount transferred\\n    /// @param amount The number of tokens to send from the sender to the recipient\\n    /// @return Returns true for a successful transfer, false for an unsuccessful transfer\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /// @notice Returns the current allowance given to a spender by an owner\\n    /// @param owner The account of the token owner\\n    /// @param spender The account of the token spender\\n    /// @return The current allowance granted by `owner` to `spender`\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /// @notice Sets the allowance of a spender from the `msg.sender` to the value `amount`\\n    /// @param spender The account which will be allowed to spend a given amount of the owners tokens\\n    /// @param amount The amount of tokens allowed to be used by `spender`\\n    /// @return Returns true for a successful approval, false for unsuccessful\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /// @notice Transfers `amount` tokens from `sender` to `recipient` up to the allowance given to the `msg.sender`\\n    /// @param sender The account from which the transfer will be initiated\\n    /// @param recipient The recipient of the transfer\\n    /// @param amount The amount of the transfer\\n    /// @return Returns true for a successful transfer, false for unsuccessful\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /// @notice Event emitted when tokens are transferred from one address to another, either via `#transfer` or `#transferFrom`.\\n    /// @param from The account from which the tokens were sent, i.e. the balance decreased\\n    /// @param to The account to which the tokens were sent, i.e. the balance increased\\n    /// @param value The amount of tokens that were transferred\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /// @notice Event emitted when the approval amount for the spender of a given owner's tokens changes.\\n    /// @param owner The account that approved spending of its tokens\\n    /// @param spender The account for which the spending allowance was modified\\n    /// @param value The new allowance from the owner to the spender\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0x8dc5ee72426906aeb12f4ae6a2426df059491739bd5cbdb8ea4a3e26970436c6\",\"license\":\"GPL-2.0-or-later\"},\"contracts/Uniswap/V4-Core/interfaces/external/IERC6909Claims.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\ninterface IERC6909Claims {\\n    /// @notice Owner balance of an id.\\n    /// @param owner The address of the owner.\\n    /// @param id The id of the token.\\n    /// @return amount The balance of the token.\\n    function balanceOf(address owner, uint256 id) external view returns (uint256 amount);\\n\\n    /// @notice Spender allowance of an id.\\n    /// @param owner The address of the owner.\\n    /// @param spender The address of the spender.\\n    /// @param id The id of the token.\\n    /// @return amount The allowance of the token.\\n    function allowance(address owner, address spender, uint256 id) external view returns (uint256 amount);\\n\\n    /// @notice Checks if a spender is approved by an owner as an operator\\n    /// @param owner The address of the owner.\\n    /// @param spender The address of the spender.\\n    /// @return approved The approval status.\\n    function isOperator(address owner, address spender) external view returns (bool approved);\\n\\n    /// @notice Transfers an amount of an id from the caller to a receiver.\\n    /// @param receiver The address of the receiver.\\n    /// @param id The id of the token.\\n    /// @param amount The amount of the token.\\n    function transfer(address receiver, uint256 id, uint256 amount) external returns (bool);\\n\\n    /// @notice Transfers an amount of an id from a sender to a receiver.\\n    /// @param sender The address of the sender.\\n    /// @param receiver The address of the receiver.\\n    /// @param id The id of the token.\\n    /// @param amount The amount of the token.\\n    function transferFrom(address sender, address receiver, uint256 id, uint256 amount) external returns (bool);\\n\\n    /// @notice Approves an amount of an id to a spender.\\n    /// @param spender The address of the spender.\\n    /// @param id The id of the token.\\n    /// @param amount The amount of the token.\\n    function approve(address spender, uint256 id, uint256 amount) external returns (bool);\\n\\n    /// @notice Sets or removes a spender as an operator for the caller.\\n    /// @param spender The address of the spender.\\n    /// @param approved The approval status.\\n    function setOperator(address spender, bool approved) external returns (bool);\\n}\\n\",\"keccak256\":\"0x1d53aa307e997fd73e1a31abe1052aad574994627958399375f760b8a750afbc\",\"license\":\"MIT\"},\"contracts/Uniswap/V4-Core/libraries/BitMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\n/// @title BitMath\\n/// @dev This library provides functionality for computing bit properties of an unsigned integer\\nlibrary BitMath {\\n    /// @notice Returns the index of the most significant bit of the number,\\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\\n    /// @dev The function satisfies the property:\\n    ///     x >= 2**mostSignificantBit(x) and x < 2**(mostSignificantBit(x)+1)\\n    /// @param x the value for which to compute the most significant bit, must be greater than 0\\n    /// @return r the index of the most significant bit\\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\\n        require(x > 0);\\n\\n        unchecked {\\n            if (x >= 0x100000000000000000000000000000000) {\\n                x >>= 128;\\n                r += 128;\\n            }\\n            if (x >= 0x10000000000000000) {\\n                x >>= 64;\\n                r += 64;\\n            }\\n            if (x >= 0x100000000) {\\n                x >>= 32;\\n                r += 32;\\n            }\\n            if (x >= 0x10000) {\\n                x >>= 16;\\n                r += 16;\\n            }\\n            if (x >= 0x100) {\\n                x >>= 8;\\n                r += 8;\\n            }\\n            if (x >= 0x10) {\\n                x >>= 4;\\n                r += 4;\\n            }\\n            if (x >= 0x4) {\\n                x >>= 2;\\n                r += 2;\\n            }\\n            if (x >= 0x2) r += 1;\\n        }\\n    }\\n\\n    /// @notice Returns the index of the least significant bit of the number,\\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\\n    /// @dev The function satisfies the property:\\n    ///     (x & 2**leastSignificantBit(x)) != 0 and (x & (2**(leastSignificantBit(x)) - 1)) == 0)\\n    /// @param x the value for which to compute the least significant bit, must be greater than 0\\n    /// @return r the index of the least significant bit\\n    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {\\n        require(x > 0);\\n\\n        unchecked {\\n            r = 255;\\n            if (x & type(uint128).max > 0) {\\n                r -= 128;\\n            } else {\\n                x >>= 128;\\n            }\\n            if (x & type(uint64).max > 0) {\\n                r -= 64;\\n            } else {\\n                x >>= 64;\\n            }\\n            if (x & type(uint32).max > 0) {\\n                r -= 32;\\n            } else {\\n                x >>= 32;\\n            }\\n            if (x & type(uint16).max > 0) {\\n                r -= 16;\\n            } else {\\n                x >>= 16;\\n            }\\n            if (x & type(uint8).max > 0) {\\n                r -= 8;\\n            } else {\\n                x >>= 8;\\n            }\\n            if (x & 0xf > 0) {\\n                r -= 4;\\n            } else {\\n                x >>= 4;\\n            }\\n            if (x & 0x3 > 0) {\\n                r -= 2;\\n            } else {\\n                x >>= 2;\\n            }\\n            if (x & 0x1 > 0) r -= 1;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x652cd36970d953b3067c766b3b0c0063d4c403eba7352df09ec10dcc868910d9\",\"license\":\"GPL-2.0-or-later\"},\"contracts/Uniswap/V4-Core/libraries/FeeLibrary.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\nlibrary FeeLibrary {\\n    uint24 public constant STATIC_FEE_MASK = 0x0FFFFF;\\n    uint24 public constant DYNAMIC_FEE_FLAG = 0x800000; // 1000\\n\\n    function isDynamicFee(uint24 self) internal pure returns (bool) {\\n        return self & DYNAMIC_FEE_FLAG != 0;\\n    }\\n\\n    function isStaticFeeTooLarge(uint24 self) internal pure returns (bool) {\\n        return self & STATIC_FEE_MASK >= 1000000;\\n    }\\n\\n    function getStaticFee(uint24 self) internal pure returns (uint24) {\\n        return self & STATIC_FEE_MASK;\\n    }\\n}\\n\",\"keccak256\":\"0x47f19ee7f8883b015e5976bdea208257ea6456c1d83b976148220b4a8ab2cc7e\",\"license\":\"GPL-2.0-or-later\"},\"contracts/Uniswap/V4-Core/libraries/FixedPoint128.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\n/// @title FixedPoint128\\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\\nlibrary FixedPoint128 {\\n    uint256 internal constant Q128 = 0x100000000000000000000000000000000;\\n}\\n\",\"keccak256\":\"0x1f015a7a107f4c471985a958f1bfbc1710948f9bcd3786a02310bc0ad5080c69\",\"license\":\"GPL-2.0-or-later\"},\"contracts/Uniswap/V4-Core/libraries/FixedPoint96.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\n/// @title FixedPoint96\\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\\n/// @dev Used in SqrtPriceMath.sol\\nlibrary FixedPoint96 {\\n    uint8 internal constant RESOLUTION = 96;\\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\\n}\\n\",\"keccak256\":\"0x7731aeeba692b0ca5dac8f27803ec9e5ce98795a554c09ae05c220861bd0314e\",\"license\":\"GPL-2.0-or-later\"},\"contracts/Uniswap/V4-Core/libraries/FullMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\n/// @title Contains 512-bit math functions\\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\\n/// @dev Handles \\\"phantom overflow\\\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\\nlibrary FullMath {\\n    /// @notice Calculates floor(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n    function mulDiv(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = a * b\\n            // Compute the product mod 2**256 and mod 2**256 - 1\\n            // then use the Chinese Remainder Theorem to reconstruct\\n            // the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2**256 + prod0\\n            uint256 prod0 = a * b; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(a, b, not(0))\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Make sure the result is less than 2**256.\\n            // Also prevents denominator == 0\\n            require(denominator > prod1);\\n\\n            // Handle non-overflow cases, 256 by 256 division\\n            if (prod1 == 0) {\\n                assembly {\\n                    result := div(prod0, denominator)\\n                }\\n                return result;\\n            }\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0]\\n            // Compute remainder using mulmod\\n            uint256 remainder;\\n            assembly {\\n                remainder := mulmod(a, b, denominator)\\n            }\\n            // Subtract 256 bit number from 512 bit number\\n            assembly {\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator\\n            // Compute largest power of two divisor of denominator.\\n            // Always >= 1.\\n            uint256 twos = (0 - denominator) & denominator;\\n            // Divide denominator by power of two\\n            assembly {\\n                denominator := div(denominator, twos)\\n            }\\n\\n            // Divide [prod1 prod0] by the factors of two\\n            assembly {\\n                prod0 := div(prod0, twos)\\n            }\\n            // Shift in bits from prod1 into prod0. For this we need\\n            // to flip `twos` such that it is 2**256 / twos.\\n            // If twos is zero, then it becomes one\\n            assembly {\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2**256\\n            // Now that denominator is an odd number, it has an inverse\\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\n            // Compute the inverse by starting with a seed that is correct\\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\\n            uint256 inv = (3 * denominator) ^ 2;\\n            // Now use Newton-Raphson iteration to improve the precision.\\n            // Thanks to Hensel's lifting lemma, this also works in modular\\n            // arithmetic, doubling the correct bits in each step.\\n            inv *= 2 - denominator * inv; // inverse mod 2**8\\n            inv *= 2 - denominator * inv; // inverse mod 2**16\\n            inv *= 2 - denominator * inv; // inverse mod 2**32\\n            inv *= 2 - denominator * inv; // inverse mod 2**64\\n            inv *= 2 - denominator * inv; // inverse mod 2**128\\n            inv *= 2 - denominator * inv; // inverse mod 2**256\\n\\n            // Because the division is now exact we can divide by multiplying\\n            // with the modular inverse of denominator. This will give us the\\n            // correct result modulo 2**256. Since the preconditions guarantee\\n            // that the outcome is less than 2**256, this is the final result.\\n            // We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inv;\\n            return result;\\n        }\\n    }\\n\\n    /// @notice Calculates ceil(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    function mulDivRoundingUp(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            result = mulDiv(a, b, denominator);\\n            if (mulmod(a, b, denominator) > 0) {\\n                require(result < type(uint256).max);\\n                result++;\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x6d8760794ed38264579c5da7b2afe8ff5543de999180850bc08687b77dce36ea\",\"license\":\"MIT\"},\"contracts/Uniswap/V4-Core/libraries/Hooks.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.24;\\n\\nimport {PoolKey} from \\\"../types/PoolKey.sol\\\";\\nimport {IHooks} from \\\"../interfaces/IHooks.sol\\\";\\nimport {FeeLibrary} from \\\"./FeeLibrary.sol\\\";\\nimport {BalanceDelta} from \\\"../types/BalanceDelta.sol\\\";\\nimport {IPoolManager} from \\\"../interfaces/IPoolManager.sol\\\";\\nimport {Locker} from \\\"./Locker.sol\\\";\\n\\n/// @notice V4 decides whether to invoke specific hooks by inspecting the leading bits of the address that\\n/// the hooks contract is deployed to.\\n/// For example, a hooks contract deployed to address: 0x9000000000000000000000000000000000000000\\n/// has leading bits '1001' which would cause the 'before initialize' and 'after add liquidity' hooks to be used.\\nlibrary Hooks {\\n    using FeeLibrary for uint24;\\n    using Hooks for IHooks;\\n\\n    uint256 internal constant BEFORE_INITIALIZE_FLAG = 1 << 159; //1\\n    uint256 internal constant AFTER_INITIALIZE_FLAG = 1 << 158; //2\\n    uint256 internal constant BEFORE_ADD_LIQUIDITY_FLAG = 1 << 157; //3\\n    uint256 internal constant AFTER_ADD_LIQUIDITY_FLAG = 1 << 156; //4\\n    uint256 internal constant BEFORE_REMOVE_LIQUIDITY_FLAG = 1 << 155; //5\\n    uint256 internal constant AFTER_REMOVE_LIQUIDITY_FLAG = 1 << 154; //6\\n    uint256 internal constant BEFORE_SWAP_FLAG = 1 << 153; //7\\n    uint256 internal constant AFTER_SWAP_FLAG = 1 << 152; //8\\n    uint256 internal constant BEFORE_DONATE_FLAG = 1 << 151; //9\\n    uint256 internal constant AFTER_DONATE_FLAG = 1 << 150; //10\\n    uint256 internal constant NO_OP_FLAG = 1 << 149; //11\\n\\n    bytes4 public constant NO_OP_SELECTOR =\\n        bytes4(keccak256(abi.encodePacked(\\\"NoOp\\\")));\\n\\n    struct Permissions {\\n        bool beforeInitialize;\\n        bool afterInitialize;\\n        bool beforeAddLiquidity;\\n        bool afterAddLiquidity;\\n        bool beforeRemoveLiquidity;\\n        bool afterRemoveLiquidity;\\n        bool beforeSwap;\\n        bool afterSwap;\\n        bool beforeDonate;\\n        bool afterDonate;\\n        bool noOp;\\n    }\\n\\n    /// @notice Thrown if the address will not lead to the specified hook calls being called\\n    /// @param hooks The address of the hooks contract\\n    error HookAddressNotValid(address hooks);\\n\\n    /// @notice Hook did not return its selector\\n    error InvalidHookResponse();\\n\\n    /// @notice thrown when a hook call fails\\n    error FailedHookCall();\\n\\n    /// @notice Utility function intended to be used in hook constructors to ensure\\n    /// the deployed hooks address causes the intended hooks to be called\\n    /// @param permissions The hooks that are intended to be called\\n    /// @dev permissions param is memory as the function will be called from constructors\\n    function validateHookPermissions(\\n        IHooks self,\\n        Permissions memory permissions\\n    ) internal pure {\\n        if (\\n            permissions.beforeInitialize !=\\n            self.hasPermission(BEFORE_INITIALIZE_FLAG) ||\\n            permissions.afterInitialize !=\\n            self.hasPermission(AFTER_INITIALIZE_FLAG) ||\\n            permissions.beforeAddLiquidity !=\\n            self.hasPermission(BEFORE_ADD_LIQUIDITY_FLAG) ||\\n            permissions.afterAddLiquidity !=\\n            self.hasPermission(AFTER_ADD_LIQUIDITY_FLAG) ||\\n            permissions.beforeRemoveLiquidity !=\\n            self.hasPermission(BEFORE_REMOVE_LIQUIDITY_FLAG) ||\\n            permissions.afterRemoveLiquidity !=\\n            self.hasPermission(AFTER_REMOVE_LIQUIDITY_FLAG) ||\\n            permissions.beforeSwap != self.hasPermission(BEFORE_SWAP_FLAG) ||\\n            permissions.afterSwap != self.hasPermission(AFTER_SWAP_FLAG) ||\\n            permissions.beforeDonate !=\\n            self.hasPermission(BEFORE_DONATE_FLAG) ||\\n            permissions.afterDonate != self.hasPermission(AFTER_DONATE_FLAG) ||\\n            permissions.noOp != self.hasPermission(NO_OP_FLAG)\\n        ) {\\n            revert HookAddressNotValid(address(self));\\n        }\\n    }\\n\\n    /// @notice Ensures that the hook address includes at least one hook flag or dynamic fees, or is the 0 address\\n    /// @param hook The hook to verify\\n    function isValidHookAddress(\\n        IHooks hook,\\n        uint24 fee\\n    ) internal pure returns (bool) {\\n        // if NoOp is allowed, at least one of beforeRemoveLiquidity, beforeAddLiquidity, beforeSwap and beforeDonate should be allowed\\n        if (\\n            hook.hasPermission(NO_OP_FLAG) &&\\n            !hook.hasPermission(BEFORE_ADD_LIQUIDITY_FLAG) &&\\n            !hook.hasPermission(BEFORE_REMOVE_LIQUIDITY_FLAG) &&\\n            !hook.hasPermission(BEFORE_SWAP_FLAG) &&\\n            !hook.hasPermission(BEFORE_DONATE_FLAG)\\n        ) {\\n            return false;\\n        }\\n        // If there is no hook contract set, then fee cannot be dynamic\\n        // If a hook contract is set, it must have at least 1 flag set, or have a dynamic fee\\n        return\\n            address(hook) == address(0)\\n                ? !fee.isDynamicFee()\\n                : (uint160(address(hook)) >= NO_OP_FLAG || fee.isDynamicFee());\\n    }\\n\\n    /// @notice performs a hook call using the given calldata on the given hook\\n    /// @return expectedSelector The selector that the hook is expected to return\\n    /// @return selector The selector that the hook actually returned\\n    function _callHook(\\n        IHooks self,\\n        bytes memory data\\n    ) private returns (bytes4 expectedSelector, bytes4 selector) {\\n        assembly {\\n            expectedSelector := mload(add(data, 0x20))\\n        }\\n\\n        (bool success, bytes memory result) = address(self).call(data);\\n        if (!success) _revert(result);\\n\\n        selector = abi.decode(result, (bytes4));\\n    }\\n\\n    /// @notice performs a hook call using the given calldata on the given hook\\n    function callHook(IHooks self, bytes memory data) internal {\\n        (bytes4 expectedSelector, bytes4 selector) = _callHook(self, data);\\n\\n        if (selector != expectedSelector) {\\n            revert InvalidHookResponse();\\n        }\\n    }\\n\\n    /// @notice performs a hook call using the given calldata on the given hook\\n    /// @return shouldExecute Whether the operation should be executed or nooped\\n    function callHookNoopable(\\n        IHooks self,\\n        bytes memory data\\n    ) internal returns (bool shouldExecute) {\\n        (bytes4 expectedSelector, bytes4 selector) = _callHook(self, data);\\n\\n        if (selector == expectedSelector) {\\n            shouldExecute = true;\\n        } else if (\\n            selector == NO_OP_SELECTOR && self.hasPermission(NO_OP_FLAG)\\n        ) {\\n            shouldExecute = false;\\n        } else {\\n            revert InvalidHookResponse();\\n        }\\n    }\\n\\n    /// @notice calls beforeInitialize hook if permissioned and validates return value\\n    function beforeInitialize(\\n        IHooks self,\\n        PoolKey memory key,\\n        uint160 sqrtPriceX96,\\n        bytes calldata hookData\\n    ) internal {\\n        if (self.hasPermission(BEFORE_INITIALIZE_FLAG)) {\\n            self.callHook(\\n                abi.encodeWithSelector(\\n                    IHooks.beforeInitialize.selector,\\n                    msg.sender,\\n                    key,\\n                    sqrtPriceX96,\\n                    hookData\\n                )\\n            );\\n        }\\n    }\\n\\n    /// @notice calls afterInitialize hook if permissioned and validates return value\\n    function afterInitialize(\\n        IHooks self,\\n        PoolKey memory key,\\n        uint160 sqrtPriceX96,\\n        int24 tick,\\n        bytes calldata hookData\\n    ) internal {\\n        if (self.hasPermission(AFTER_INITIALIZE_FLAG)) {\\n            self.callHook(\\n                abi.encodeWithSelector(\\n                    IHooks.afterInitialize.selector,\\n                    msg.sender,\\n                    key,\\n                    sqrtPriceX96,\\n                    tick,\\n                    hookData\\n                )\\n            );\\n        }\\n    }\\n\\n    /// @notice calls beforeModifyLiquidity hook if permissioned and validates return value\\n    function beforeModifyLiquidity(\\n        IHooks self,\\n        PoolKey memory key,\\n        IPoolManager.ModifyLiquidityParams memory params,\\n        bytes calldata hookData\\n    ) internal returns (bool shouldExecute) {\\n        if (\\n            params.liquidityDelta > 0 &&\\n            key.hooks.hasPermission(BEFORE_ADD_LIQUIDITY_FLAG)\\n        ) {\\n            shouldExecute = self.callHookNoopable(\\n                abi.encodeWithSelector(\\n                    IHooks.beforeAddLiquidity.selector,\\n                    msg.sender,\\n                    key,\\n                    params,\\n                    hookData\\n                )\\n            );\\n        } else if (\\n            params.liquidityDelta <= 0 &&\\n            key.hooks.hasPermission(BEFORE_REMOVE_LIQUIDITY_FLAG)\\n        ) {\\n            shouldExecute = self.callHookNoopable(\\n                abi.encodeWithSelector(\\n                    IHooks.beforeRemoveLiquidity.selector,\\n                    msg.sender,\\n                    key,\\n                    params,\\n                    hookData\\n                )\\n            );\\n        } else {\\n            shouldExecute = true;\\n        }\\n    }\\n\\n    /// @notice calls afterModifyLiquidity hook if permissioned and validates return value\\n    function afterModifyLiquidity(\\n        IHooks self,\\n        PoolKey memory key,\\n        IPoolManager.ModifyLiquidityParams memory params,\\n        BalanceDelta delta,\\n        bytes calldata hookData\\n    ) internal {\\n        if (\\n            params.liquidityDelta > 0 &&\\n            key.hooks.hasPermission(AFTER_ADD_LIQUIDITY_FLAG)\\n        ) {\\n            self.callHook(\\n                abi.encodeWithSelector(\\n                    IHooks.afterAddLiquidity.selector,\\n                    msg.sender,\\n                    key,\\n                    params,\\n                    delta,\\n                    hookData\\n                )\\n            );\\n        } else if (\\n            params.liquidityDelta <= 0 &&\\n            key.hooks.hasPermission(AFTER_REMOVE_LIQUIDITY_FLAG)\\n        ) {\\n            self.callHook(\\n                abi.encodeWithSelector(\\n                    IHooks.afterRemoveLiquidity.selector,\\n                    msg.sender,\\n                    key,\\n                    params,\\n                    delta,\\n                    hookData\\n                )\\n            );\\n        }\\n    }\\n\\n    /// @notice calls beforeSwap hook if permissioned and validates return value\\n    function beforeSwap(\\n        IHooks self,\\n        PoolKey memory key,\\n        IPoolManager.SwapParams memory params,\\n        bytes calldata hookData\\n    ) internal returns (bool shouldExecute) {\\n        if (key.hooks.hasPermission(BEFORE_SWAP_FLAG)) {\\n            shouldExecute = self.callHookNoopable(\\n                abi.encodeWithSelector(\\n                    IHooks.beforeSwap.selector,\\n                    msg.sender,\\n                    key,\\n                    params,\\n                    hookData\\n                )\\n            );\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /// @notice calls afterSwap hook if permissioned and validates return value\\n    function afterSwap(\\n        IHooks self,\\n        PoolKey memory key,\\n        IPoolManager.SwapParams memory params,\\n        BalanceDelta delta,\\n        bytes calldata hookData\\n    ) internal {\\n        if (key.hooks.hasPermission(AFTER_SWAP_FLAG)) {\\n            self.callHook(\\n                abi.encodeWithSelector(\\n                    IHooks.afterSwap.selector,\\n                    msg.sender,\\n                    key,\\n                    params,\\n                    delta,\\n                    hookData\\n                )\\n            );\\n        }\\n    }\\n\\n    /// @notice calls beforeDonate hook if permissioned and validates return value\\n    function beforeDonate(\\n        IHooks self,\\n        PoolKey memory key,\\n        uint256 amount0,\\n        uint256 amount1,\\n        bytes calldata hookData\\n    ) internal returns (bool shouldExecute) {\\n        if (key.hooks.hasPermission(BEFORE_DONATE_FLAG)) {\\n            shouldExecute = self.callHookNoopable(\\n                abi.encodeWithSelector(\\n                    IHooks.beforeDonate.selector,\\n                    msg.sender,\\n                    key,\\n                    amount0,\\n                    amount1,\\n                    hookData\\n                )\\n            );\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /// @notice calls afterDonate hook if permissioned and validates return value\\n    function afterDonate(\\n        IHooks self,\\n        PoolKey memory key,\\n        uint256 amount0,\\n        uint256 amount1,\\n        bytes calldata hookData\\n    ) internal {\\n        if (key.hooks.hasPermission(AFTER_DONATE_FLAG)) {\\n            self.callHook(\\n                abi.encodeWithSelector(\\n                    IHooks.afterDonate.selector,\\n                    msg.sender,\\n                    key,\\n                    amount0,\\n                    amount1,\\n                    hookData\\n                )\\n            );\\n        }\\n    }\\n\\n    function hasPermission(\\n        IHooks self,\\n        uint256 flag\\n    ) internal pure returns (bool) {\\n        return uint256(uint160(address(self))) & flag != 0;\\n    }\\n\\n    /// @notice bubble up revert if present. Else throw FailedHookCall\\n    function _revert(bytes memory result) private pure {\\n        if (result.length > 0) {\\n            assembly {\\n                revert(add(0x20, result), mload(result))\\n            }\\n        } else {\\n            revert FailedHookCall();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc095e692dcaa5e02224e4491cec4d1d7af4d826f5febd334e90091f91767ca06\",\"license\":\"MIT\"},\"contracts/Uniswap/V4-Core/libraries/Locker.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.20;\\n\\nimport {IHooks} from \\\"../interfaces/IHooks.sol\\\";\\n\\n/// @notice This is a temporary library that allows us to use transient storage (tstore/tload)\\n/// for the lockers array\\n/// TODO: This library can be deleted when we have the transient keyword support in solidity.\\nlibrary Locker {\\n    // The slot holding the locker, transiently, and the lock caller in the next slot\\n    uint256 constant LOCKER_SLOT = uint256(keccak256(\\\"Locker\\\")) - 1;\\n\\n    /// @notice Thrown when trying to set the lock target as address(0)\\n    /// we use locker==address(0) to signal that the pool is not locked\\n    error InvalidLocker();\\n\\n    function setLocker(address locker) internal {\\n        if (locker == address(0)) revert InvalidLocker();\\n        uint256 slot = LOCKER_SLOT;\\n\\n        assembly {\\n            // set the locker\\n            tstore(slot, locker)\\n        }\\n    }\\n\\n    function clearLocker() internal {\\n        uint256 slot = LOCKER_SLOT;\\n        assembly {\\n            tstore(slot, 0)\\n        }\\n    }\\n\\n    function getLocker() internal view returns (address locker) {\\n        uint256 slot = LOCKER_SLOT;\\n        assembly {\\n            locker := tload(slot)\\n        }\\n    }\\n\\n    function isLocked() internal view returns (bool) {\\n        return getLocker() != address(0);\\n    }\\n}\\n\",\"keccak256\":\"0x50232e5302de8d5430a7a2f174435705e7aec23acb991897a23598b0a3331e55\",\"license\":\"BUSL-1.1\"},\"contracts/Uniswap/V4-Core/libraries/Pool.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.20;\\n\\nimport {SafeCast} from \\\"./SafeCast.sol\\\";\\nimport {TickBitmap} from \\\"./TickBitmap.sol\\\";\\nimport {Position} from \\\"./Position.sol\\\";\\nimport {FullMath} from \\\"./FullMath.sol\\\";\\nimport {FixedPoint128} from \\\"./FixedPoint128.sol\\\";\\nimport {TickMath} from \\\"./TickMath.sol\\\";\\nimport {SqrtPriceMath} from \\\"./SqrtPriceMath.sol\\\";\\nimport {SwapMath} from \\\"./SwapMath.sol\\\";\\nimport {BalanceDelta, toBalanceDelta} from \\\"../types/BalanceDelta.sol\\\";\\n\\n// import {PoolNotInitialized} from \\\"../interfaces/IPoolManager.sol\\\";\\n\\nlibrary Pool {\\n    using SafeCast for *;\\n    using TickBitmap for mapping(int16 => uint256);\\n    using Position for mapping(bytes32 => Position.Info);\\n    using Position for Position.Info;\\n    using Pool for State;\\n\\n    /// @notice Thrown when tickLower is not below tickUpper\\n    /// @param tickLower The invalid tickLower\\n    /// @param tickUpper The invalid tickUpper\\n    error TicksMisordered(int24 tickLower, int24 tickUpper);\\n\\n    /// @notice Thrown when tickLower is less than min tick\\n    /// @param tickLower The invalid tickLower\\n    error TickLowerOutOfBounds(int24 tickLower);\\n\\n    /// @notice Thrown when tickUpper exceeds max tick\\n    /// @param tickUpper The invalid tickUpper\\n    error TickUpperOutOfBounds(int24 tickUpper);\\n\\n    /// @notice For the tick spacing, the tick has too much liquidity\\n    error TickLiquidityOverflow(int24 tick);\\n\\n    /// @notice Thrown when interacting with an uninitialized tick that must be initialized\\n    /// @param tick The uninitialized tick\\n    error TickNotInitialized(int24 tick);\\n\\n    /// @notice Thrown when trying to initialize an already initialized pool\\n    error PoolAlreadyInitialized();\\n\\n    /// @notice Thrown when trying to interact with a non-initialized pool\\n    error PoolNotInitialized1();\\n\\n    /// @notice Thrown when trying to swap amount of 0\\n    error SwapAmountCannotBeZero();\\n\\n    /// @notice Thrown when sqrtPriceLimitX96 on a swap has already exceeded its limit\\n    /// @param sqrtPriceCurrentX96 The invalid, already surpassed sqrtPriceLimitX96\\n    /// @param sqrtPriceLimitX96 The surpassed price limit\\n    error PriceLimitAlreadyExceeded(\\n        uint160 sqrtPriceCurrentX96,\\n        uint160 sqrtPriceLimitX96\\n    );\\n\\n    /// @notice Thrown when sqrtPriceLimitX96 lies outside of valid tick/price range\\n    /// @param sqrtPriceLimitX96 The invalid, out-of-bounds sqrtPriceLimitX96\\n    error PriceLimitOutOfBounds(uint160 sqrtPriceLimitX96);\\n\\n    /// @notice Thrown by donate if there is currently 0 liquidity, since the fees will not go to any liquidity providers\\n    error NoLiquidityToReceiveFees();\\n\\n    struct Slot0 {\\n        // the current price\\n        uint160 sqrtPriceX96;\\n        // the current tick\\n        int24 tick;\\n        // protocol swap fee represented as integer denominator (1/x), taken as a % of the LP swap fee\\n        // upper 8 bits are for 1->0, and the lower 8 are for 0->1\\n        // the minimum permitted denominator is 4 - meaning the maximum protocol fee is 25%\\n        // granularity is increments of 0.38% (100/type(uint8).max)\\n        uint16 protocolFee;\\n        // used for the swap fee, either static at initialize or dynamic via hook\\n        uint24 swapFee;\\n    }\\n\\n    // info stored for each initialized individual tick\\n    struct TickInfo {\\n        // the total position liquidity that references this tick\\n        uint128 liquidityGross;\\n        // amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left),\\n        int128 liquidityNet;\\n        // fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)\\n        // only has relative meaning, not absolute \\u2014 the value depends on when the tick is initialized\\n        uint256 feeGrowthOutside0X128;\\n        uint256 feeGrowthOutside1X128;\\n    }\\n\\n    /// @dev The state of a pool\\n    struct State {\\n        Slot0 slot0;\\n        uint256 feeGrowthGlobal0X128;\\n        uint256 feeGrowthGlobal1X128;\\n        uint128 liquidity;\\n        mapping(int24 => TickInfo) ticks;\\n        mapping(int16 => uint256) tickBitmap;\\n        mapping(bytes32 => Position.Info) positions;\\n    }\\n\\n    /// @dev Common checks for valid tick inputs.\\n    function checkTicks(int24 tickLower, int24 tickUpper) private pure {\\n        if (tickLower >= tickUpper)\\n            revert TicksMisordered(tickLower, tickUpper);\\n        if (tickLower < TickMath.MIN_TICK)\\n            revert TickLowerOutOfBounds(tickLower);\\n        if (tickUpper > TickMath.MAX_TICK)\\n            revert TickUpperOutOfBounds(tickUpper);\\n    }\\n\\n    function initialize(\\n        State storage self,\\n        uint160 sqrtPriceX96,\\n        uint16 protocolFee,\\n        uint24 swapFee\\n    ) internal returns (int24 tick) {\\n        if (self.slot0.sqrtPriceX96 != 0) revert PoolAlreadyInitialized();\\n\\n        tick = TickMath.getTickAtSqrtRatio(sqrtPriceX96);\\n\\n        self.slot0 = Slot0({\\n            sqrtPriceX96: sqrtPriceX96,\\n            tick: tick,\\n            protocolFee: protocolFee,\\n            swapFee: swapFee\\n        });\\n    }\\n\\n    function setProtocolFee(State storage self, uint16 protocolFee) internal {\\n        if (self.isNotInitialized()) revert PoolNotInitialized1();\\n\\n        self.slot0.protocolFee = protocolFee;\\n    }\\n\\n    /// @notice Only dynamic fee pools may update the swap fee.\\n    function setSwapFee(State storage self, uint24 swapFee) internal {\\n        if (self.isNotInitialized()) revert PoolNotInitialized1();\\n        self.slot0.swapFee = swapFee;\\n    }\\n\\n    struct ModifyPositionParams {\\n        // the address that owns the position\\n        address owner;\\n        // the lower and upper tick of the position\\n        int24 tickLower;\\n        int24 tickUpper;\\n        // any change in liquidity\\n        int128 liquidityDelta;\\n        // the spacing between ticks\\n        int24 tickSpacing;\\n    }\\n\\n    struct ModifyPositionState {\\n        bool flippedLower;\\n        uint128 liquidityGrossAfterLower;\\n        bool flippedUpper;\\n        uint128 liquidityGrossAfterUpper;\\n        uint256 feeGrowthInside0X128;\\n        uint256 feeGrowthInside1X128;\\n    }\\n\\n    /// @notice Effect changes to a position in a pool\\n    /// @dev PoolManager checks that the pool is initialized before calling\\n    /// @param params the position details and the change to the position's liquidity to effect\\n    /// @return result the deltas of the token balances of the pool\\n    function modifyPosition(\\n        State storage self,\\n        ModifyPositionParams memory params\\n    ) internal returns (BalanceDelta result) {\\n        checkTicks(params.tickLower, params.tickUpper);\\n\\n        uint256 feesOwed0;\\n        uint256 feesOwed1;\\n        {\\n            ModifyPositionState memory state;\\n\\n            // if we need to update the ticks, do it\\n            if (params.liquidityDelta != 0) {\\n                (\\n                    state.flippedLower,\\n                    state.liquidityGrossAfterLower\\n                ) = updateTick(\\n                    self,\\n                    params.tickLower,\\n                    params.liquidityDelta,\\n                    false\\n                );\\n                (\\n                    state.flippedUpper,\\n                    state.liquidityGrossAfterUpper\\n                ) = updateTick(\\n                    self,\\n                    params.tickUpper,\\n                    params.liquidityDelta,\\n                    true\\n                );\\n\\n                if (params.liquidityDelta > 0) {\\n                    uint128 maxLiquidityPerTick = tickSpacingToMaxLiquidityPerTick(\\n                            params.tickSpacing\\n                        );\\n                    if (state.liquidityGrossAfterLower > maxLiquidityPerTick) {\\n                        revert TickLiquidityOverflow(params.tickLower);\\n                    }\\n                    if (state.liquidityGrossAfterUpper > maxLiquidityPerTick) {\\n                        revert TickLiquidityOverflow(params.tickUpper);\\n                    }\\n                }\\n\\n                if (state.flippedLower) {\\n                    self.tickBitmap.flipTick(\\n                        params.tickLower,\\n                        params.tickSpacing\\n                    );\\n                }\\n                if (state.flippedUpper) {\\n                    self.tickBitmap.flipTick(\\n                        params.tickUpper,\\n                        params.tickSpacing\\n                    );\\n                }\\n            }\\n\\n            (\\n                state.feeGrowthInside0X128,\\n                state.feeGrowthInside1X128\\n            ) = getFeeGrowthInside(self, params.tickLower, params.tickUpper);\\n\\n            (feesOwed0, feesOwed1) = self\\n                .positions\\n                .get(params.owner, params.tickLower, params.tickUpper)\\n                .update(\\n                    params.liquidityDelta,\\n                    state.feeGrowthInside0X128,\\n                    state.feeGrowthInside1X128\\n                );\\n\\n            // clear any tick data that is no longer needed\\n            if (params.liquidityDelta < 0) {\\n                if (state.flippedLower) {\\n                    clearTick(self, params.tickLower);\\n                }\\n                if (state.flippedUpper) {\\n                    clearTick(self, params.tickUpper);\\n                }\\n            }\\n        }\\n\\n        if (params.liquidityDelta != 0) {\\n            if (self.slot0.tick < params.tickLower) {\\n                // current tick is below the passed range; liquidity can only become in range by crossing from left to\\n                // right, when we'll need _more_ currency0 (it's becoming more valuable) so user must provide it\\n                result =\\n                    result +\\n                    toBalanceDelta(\\n                        SqrtPriceMath\\n                            .getAmount0Delta(\\n                                TickMath.getSqrtRatioAtTick(params.tickLower),\\n                                TickMath.getSqrtRatioAtTick(params.tickUpper),\\n                                params.liquidityDelta\\n                            )\\n                            .toInt128(),\\n                        0\\n                    );\\n            } else if (self.slot0.tick < params.tickUpper) {\\n                result =\\n                    result +\\n                    toBalanceDelta(\\n                        SqrtPriceMath\\n                            .getAmount0Delta(\\n                                self.slot0.sqrtPriceX96,\\n                                TickMath.getSqrtRatioAtTick(params.tickUpper),\\n                                params.liquidityDelta\\n                            )\\n                            .toInt128(),\\n                        SqrtPriceMath\\n                            .getAmount1Delta(\\n                                TickMath.getSqrtRatioAtTick(params.tickLower),\\n                                self.slot0.sqrtPriceX96,\\n                                params.liquidityDelta\\n                            )\\n                            .toInt128()\\n                    );\\n\\n                self.liquidity = params.liquidityDelta < 0\\n                    ? self.liquidity - uint128(-params.liquidityDelta)\\n                    : self.liquidity + uint128(params.liquidityDelta);\\n            } else {\\n                // current tick is above the passed range; liquidity can only become in range by crossing from right to\\n                // left, when we'll need _more_ currency1 (it's becoming more valuable) so user must provide it\\n                result =\\n                    result +\\n                    toBalanceDelta(\\n                        0,\\n                        SqrtPriceMath\\n                            .getAmount1Delta(\\n                                TickMath.getSqrtRatioAtTick(params.tickLower),\\n                                TickMath.getSqrtRatioAtTick(params.tickUpper),\\n                                params.liquidityDelta\\n                            )\\n                            .toInt128()\\n                    );\\n            }\\n        }\\n\\n        // Fees earned from LPing are removed from the pool balance.\\n        result =\\n            result -\\n            toBalanceDelta(feesOwed0.toInt128(), feesOwed1.toInt128());\\n    }\\n\\n    struct SwapCache {\\n        // liquidity at the beginning of the swap\\n        uint128 liquidityStart;\\n        // the protocol fee for the input token\\n        uint8 protocolFee;\\n    }\\n\\n    // the top level state of the swap, the results of which are recorded in storage at the end\\n    struct SwapState {\\n        // the amount remaining to be swapped in/out of the input/output asset\\n        int256 amountSpecifiedRemaining;\\n        // the amount already swapped out/in of the output/input asset\\n        int256 amountCalculated;\\n        // current sqrt(price)\\n        uint160 sqrtPriceX96;\\n        // the tick associated with the current price\\n        int24 tick;\\n        // the global fee growth of the input token\\n        uint256 feeGrowthGlobalX128;\\n        // the current liquidity in range\\n        uint128 liquidity;\\n    }\\n\\n    struct StepComputations {\\n        // the price at the beginning of the step\\n        uint160 sqrtPriceStartX96;\\n        // the next tick to swap to from the current tick in the swap direction\\n        int24 tickNext;\\n        // whether tickNext is initialized or not\\n        bool initialized;\\n        // sqrt(price) for the next tick (1/0)\\n        uint160 sqrtPriceNextX96;\\n        // how much is being swapped in in this step\\n        uint256 amountIn;\\n        // how much is being swapped out\\n        uint256 amountOut;\\n        // how much fee is being paid in\\n        uint256 feeAmount;\\n    }\\n\\n    struct SwapParams {\\n        int24 tickSpacing;\\n        bool zeroForOne;\\n        int256 amountSpecified;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Executes a swap against the state, and returns the amount deltas of the pool\\n    /// @dev PoolManager checks that the pool is initialized before calling\\n    function swap(\\n        State storage self,\\n        SwapParams memory params\\n    )\\n        internal\\n        returns (\\n            BalanceDelta result,\\n            uint256 feeForProtocol,\\n            uint24 swapFee,\\n            SwapState memory state\\n        )\\n    {\\n        if (params.amountSpecified == 0) revert SwapAmountCannotBeZero();\\n\\n        Slot0 memory slot0Start = self.slot0;\\n        swapFee = slot0Start.swapFee;\\n        if (params.zeroForOne) {\\n            if (params.sqrtPriceLimitX96 >= slot0Start.sqrtPriceX96) {\\n                revert PriceLimitAlreadyExceeded(\\n                    slot0Start.sqrtPriceX96,\\n                    params.sqrtPriceLimitX96\\n                );\\n            }\\n            if (params.sqrtPriceLimitX96 <= TickMath.MIN_SQRT_RATIO) {\\n                revert PriceLimitOutOfBounds(params.sqrtPriceLimitX96);\\n            }\\n        } else {\\n            if (params.sqrtPriceLimitX96 <= slot0Start.sqrtPriceX96) {\\n                revert PriceLimitAlreadyExceeded(\\n                    slot0Start.sqrtPriceX96,\\n                    params.sqrtPriceLimitX96\\n                );\\n            }\\n            if (params.sqrtPriceLimitX96 >= TickMath.MAX_SQRT_RATIO) {\\n                revert PriceLimitOutOfBounds(params.sqrtPriceLimitX96);\\n            }\\n        }\\n\\n        SwapCache memory cache = SwapCache({\\n            liquidityStart: self.liquidity,\\n            protocolFee: params.zeroForOne\\n                ? uint8(slot0Start.protocolFee % 256)\\n                : uint8(slot0Start.protocolFee >> 8)\\n        });\\n\\n        bool exactInput = params.amountSpecified > 0;\\n\\n        state = SwapState({\\n            amountSpecifiedRemaining: params.amountSpecified,\\n            amountCalculated: 0,\\n            sqrtPriceX96: slot0Start.sqrtPriceX96,\\n            tick: slot0Start.tick,\\n            feeGrowthGlobalX128: params.zeroForOne\\n                ? self.feeGrowthGlobal0X128\\n                : self.feeGrowthGlobal1X128,\\n            liquidity: cache.liquidityStart\\n        });\\n\\n        StepComputations memory step;\\n        // continue swapping as long as we haven't used the entire input/output and haven't reached the price limit\\n        while (\\n            state.amountSpecifiedRemaining != 0 &&\\n            state.sqrtPriceX96 != params.sqrtPriceLimitX96\\n        ) {\\n            step.sqrtPriceStartX96 = state.sqrtPriceX96;\\n\\n            (step.tickNext, step.initialized) = self\\n                .tickBitmap\\n                .nextInitializedTickWithinOneWord(\\n                    state.tick,\\n                    params.tickSpacing,\\n                    params.zeroForOne\\n                );\\n\\n            // ensure that we do not overshoot the min/max tick, as the tick bitmap is not aware of these bounds\\n            if (step.tickNext < TickMath.MIN_TICK) {\\n                step.tickNext = TickMath.MIN_TICK;\\n            } else if (step.tickNext > TickMath.MAX_TICK) {\\n                step.tickNext = TickMath.MAX_TICK;\\n            }\\n\\n            // get the price for the next tick\\n            step.sqrtPriceNextX96 = TickMath.getSqrtRatioAtTick(step.tickNext);\\n\\n            // compute values to swap to the target tick, price limit, or point where input/output amount is exhausted\\n            (\\n                state.sqrtPriceX96,\\n                step.amountIn,\\n                step.amountOut,\\n                step.feeAmount\\n            ) = SwapMath.computeSwapStep(\\n                state.sqrtPriceX96,\\n                (\\n                    params.zeroForOne\\n                        ? step.sqrtPriceNextX96 < params.sqrtPriceLimitX96\\n                        : step.sqrtPriceNextX96 > params.sqrtPriceLimitX96\\n                )\\n                    ? params.sqrtPriceLimitX96\\n                    : step.sqrtPriceNextX96,\\n                state.liquidity,\\n                state.amountSpecifiedRemaining,\\n                swapFee\\n            );\\n\\n            if (exactInput) {\\n                // safe because we test that amountSpecified > amountIn + feeAmount in SwapMath\\n                unchecked {\\n                    state.amountSpecifiedRemaining -= (step.amountIn +\\n                        step.feeAmount).toInt256();\\n                }\\n                state.amountCalculated =\\n                    state.amountCalculated -\\n                    step.amountOut.toInt256();\\n            } else {\\n                unchecked {\\n                    state.amountSpecifiedRemaining += step.amountOut.toInt256();\\n                }\\n                state.amountCalculated =\\n                    state.amountCalculated +\\n                    (step.amountIn + step.feeAmount).toInt256();\\n            }\\n\\n            // if the protocol fee is on, calculate how much is owed, decrement feeAmount, and increment protocolFee\\n            if (cache.protocolFee > 0) {\\n                // A: calculate the amount of the fee that should go to the protocol\\n                uint256 delta = step.feeAmount / cache.protocolFee;\\n                // A: subtract it from the regular fee and add it to the protocol fee\\n                unchecked {\\n                    step.feeAmount -= delta;\\n                    feeForProtocol += delta;\\n                }\\n            }\\n\\n            // update global fee tracker\\n            if (state.liquidity > 0) {\\n                unchecked {\\n                    state.feeGrowthGlobalX128 += FullMath.mulDiv(\\n                        step.feeAmount,\\n                        FixedPoint128.Q128,\\n                        state.liquidity\\n                    );\\n                }\\n            }\\n\\n            // shift tick if we reached the next price\\n            if (state.sqrtPriceX96 == step.sqrtPriceNextX96) {\\n                // if the tick is initialized, run the tick transition\\n                if (step.initialized) {\\n                    int128 liquidityNet = Pool.crossTick(\\n                        self,\\n                        step.tickNext,\\n                        (\\n                            params.zeroForOne\\n                                ? state.feeGrowthGlobalX128\\n                                : self.feeGrowthGlobal0X128\\n                        ),\\n                        (\\n                            params.zeroForOne\\n                                ? self.feeGrowthGlobal1X128\\n                                : state.feeGrowthGlobalX128\\n                        )\\n                    );\\n                    // if we're moving leftward, we interpret liquidityNet as the opposite sign\\n                    // safe because liquidityNet cannot be type(int128).min\\n                    unchecked {\\n                        if (params.zeroForOne) liquidityNet = -liquidityNet;\\n                    }\\n\\n                    state.liquidity = liquidityNet < 0\\n                        ? state.liquidity - uint128(-liquidityNet)\\n                        : state.liquidity + uint128(liquidityNet);\\n                }\\n\\n                unchecked {\\n                    state.tick = params.zeroForOne\\n                        ? step.tickNext - 1\\n                        : step.tickNext;\\n                }\\n            } else if (state.sqrtPriceX96 != step.sqrtPriceStartX96) {\\n                // recompute unless we're on a lower tick boundary (i.e. already transitioned ticks), and haven't moved\\n                state.tick = TickMath.getTickAtSqrtRatio(state.sqrtPriceX96);\\n            }\\n        }\\n\\n        (self.slot0.sqrtPriceX96, self.slot0.tick) = (\\n            state.sqrtPriceX96,\\n            state.tick\\n        );\\n\\n        // update liquidity if it changed\\n        if (cache.liquidityStart != state.liquidity)\\n            self.liquidity = state.liquidity;\\n\\n        // update fee growth global\\n        if (params.zeroForOne) {\\n            self.feeGrowthGlobal0X128 = state.feeGrowthGlobalX128;\\n        } else {\\n            self.feeGrowthGlobal1X128 = state.feeGrowthGlobalX128;\\n        }\\n\\n        unchecked {\\n            if (params.zeroForOne == exactInput) {\\n                result = toBalanceDelta(\\n                    (params.amountSpecified - state.amountSpecifiedRemaining)\\n                        .toInt128(),\\n                    state.amountCalculated.toInt128()\\n                );\\n            } else {\\n                result = toBalanceDelta(\\n                    state.amountCalculated.toInt128(),\\n                    (params.amountSpecified - state.amountSpecifiedRemaining)\\n                        .toInt128()\\n                );\\n            }\\n        }\\n    }\\n\\n    /// @notice Donates the given amount of currency0 and currency1 to the pool\\n    function donate(\\n        State storage state,\\n        uint256 amount0,\\n        uint256 amount1\\n    ) internal returns (BalanceDelta delta) {\\n        if (state.liquidity == 0) revert NoLiquidityToReceiveFees();\\n        delta = toBalanceDelta(amount0.toInt128(), amount1.toInt128());\\n        unchecked {\\n            if (amount0 > 0) {\\n                state.feeGrowthGlobal0X128 += FullMath.mulDiv(\\n                    amount0,\\n                    FixedPoint128.Q128,\\n                    state.liquidity\\n                );\\n            }\\n            if (amount1 > 0) {\\n                state.feeGrowthGlobal1X128 += FullMath.mulDiv(\\n                    amount1,\\n                    FixedPoint128.Q128,\\n                    state.liquidity\\n                );\\n            }\\n        }\\n    }\\n\\n    /// @notice Retrieves fee growth data\\n    /// @param self The Pool state struct\\n    /// @param tickLower The lower tick boundary of the position\\n    /// @param tickUpper The upper tick boundary of the position\\n    /// @return feeGrowthInside0X128 The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries\\n    /// @return feeGrowthInside1X128 The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries\\n    function getFeeGrowthInside(\\n        State storage self,\\n        int24 tickLower,\\n        int24 tickUpper\\n    )\\n        internal\\n        view\\n        returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128)\\n    {\\n        TickInfo storage lower = self.ticks[tickLower];\\n        TickInfo storage upper = self.ticks[tickUpper];\\n        int24 tickCurrent = self.slot0.tick;\\n\\n        unchecked {\\n            if (tickCurrent < tickLower) {\\n                feeGrowthInside0X128 =\\n                    lower.feeGrowthOutside0X128 -\\n                    upper.feeGrowthOutside0X128;\\n                feeGrowthInside1X128 =\\n                    lower.feeGrowthOutside1X128 -\\n                    upper.feeGrowthOutside1X128;\\n            } else if (tickCurrent >= tickUpper) {\\n                feeGrowthInside0X128 =\\n                    upper.feeGrowthOutside0X128 -\\n                    lower.feeGrowthOutside0X128;\\n                feeGrowthInside1X128 =\\n                    upper.feeGrowthOutside1X128 -\\n                    lower.feeGrowthOutside1X128;\\n            } else {\\n                feeGrowthInside0X128 =\\n                    self.feeGrowthGlobal0X128 -\\n                    lower.feeGrowthOutside0X128 -\\n                    upper.feeGrowthOutside0X128;\\n                feeGrowthInside1X128 =\\n                    self.feeGrowthGlobal1X128 -\\n                    lower.feeGrowthOutside1X128 -\\n                    upper.feeGrowthOutside1X128;\\n            }\\n        }\\n    }\\n\\n    /// @notice Updates a tick and returns true if the tick was flipped from initialized to uninitialized, or vice versa\\n    /// @param self The mapping containing all tick information for initialized ticks\\n    /// @param tick The tick that will be updated\\n    /// @param liquidityDelta A new amount of liquidity to be added (subtracted) when tick is crossed from left to right (right to left)\\n    /// @param upper true for updating a position's upper tick, or false for updating a position's lower tick\\n    /// @return flipped Whether the tick was flipped from initialized to uninitialized, or vice versa\\n    /// @return liquidityGrossAfter The total amount of  liquidity for all positions that references the tick after the update\\n    function updateTick(\\n        State storage self,\\n        int24 tick,\\n        int128 liquidityDelta,\\n        bool upper\\n    ) internal returns (bool flipped, uint128 liquidityGrossAfter) {\\n        TickInfo storage info = self.ticks[tick];\\n\\n        uint128 liquidityGrossBefore;\\n        int128 liquidityNetBefore;\\n        assembly {\\n            // load first slot of info which contains liquidityGross and liquidityNet packed\\n            // where the top 128 bits are liquidityNet and the bottom 128 bits are liquidityGross\\n            let liquidity := sload(info.slot)\\n            // slice off top 128 bits of liquidity (liquidityNet) to get just liquidityGross\\n            liquidityGrossBefore := shr(128, shl(128, liquidity))\\n            // shift right 128 bits to get just liquidityNet\\n            liquidityNetBefore := shr(128, liquidity)\\n        }\\n\\n        liquidityGrossAfter = liquidityDelta < 0\\n            ? liquidityGrossBefore - uint128(-liquidityDelta)\\n            : liquidityGrossBefore + uint128(liquidityDelta);\\n\\n        flipped = (liquidityGrossAfter == 0) != (liquidityGrossBefore == 0);\\n\\n        if (liquidityGrossBefore == 0) {\\n            // by convention, we assume that all growth before a tick was initialized happened _below_ the tick\\n            if (tick <= self.slot0.tick) {\\n                info.feeGrowthOutside0X128 = self.feeGrowthGlobal0X128;\\n                info.feeGrowthOutside1X128 = self.feeGrowthGlobal1X128;\\n            }\\n        }\\n\\n        // when the lower (upper) tick is crossed left to right (right to left), liquidity must be added (removed)\\n        int128 liquidityNet = upper\\n            ? liquidityNetBefore - liquidityDelta\\n            : liquidityNetBefore + liquidityDelta;\\n        assembly {\\n            // liquidityGrossAfter and liquidityNet are packed in the first slot of `info`\\n            // So we can store them with a single sstore by packing them ourselves first\\n            sstore(\\n                info.slot,\\n                // bitwise OR to pack liquidityGrossAfter and liquidityNet\\n                or(\\n                    // liquidityGross is in the low bits, upper bits are already 0\\n                    liquidityGrossAfter,\\n                    // shift liquidityNet to take the upper bits and lower bits get filled with 0\\n                    shl(128, liquidityNet)\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @notice Derives max liquidity per tick from given tick spacing\\n    /// @dev Executed within the pool constructor\\n    /// @param tickSpacing The amount of required tick separation, realized in multiples of `tickSpacing`\\n    ///     e.g., a tickSpacing of 3 requires ticks to be initialized every 3rd tick i.e., ..., -6, -3, 0, 3, 6, ...\\n    /// @return The max liquidity per tick\\n    function tickSpacingToMaxLiquidityPerTick(\\n        int24 tickSpacing\\n    ) internal pure returns (uint128) {\\n        unchecked {\\n            return\\n                uint128(\\n                    (type(uint128).max * uint256(int256(tickSpacing))) /\\n                        uint256(int256(TickMath.MAX_TICK * 2 + tickSpacing))\\n                );\\n        }\\n    }\\n\\n    function isNotInitialized(State storage self) internal view returns (bool) {\\n        return self.slot0.sqrtPriceX96 == 0;\\n    }\\n\\n    /// @notice Clears tick data\\n    /// @param self The mapping containing all initialized tick information for initialized ticks\\n    /// @param tick The tick that will be cleared\\n    function clearTick(State storage self, int24 tick) internal {\\n        delete self.ticks[tick];\\n    }\\n\\n    /// @notice Transitions to next tick as needed by price movement\\n    /// @param self The Pool state struct\\n    /// @param tick The destination tick of the transition\\n    /// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0\\n    /// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1\\n    /// @return liquidityNet The amount of liquidity added (subtracted) when tick is crossed from left to right (right to left)\\n    function crossTick(\\n        State storage self,\\n        int24 tick,\\n        uint256 feeGrowthGlobal0X128,\\n        uint256 feeGrowthGlobal1X128\\n    ) internal returns (int128 liquidityNet) {\\n        unchecked {\\n            TickInfo storage info = self.ticks[tick];\\n            info.feeGrowthOutside0X128 =\\n                feeGrowthGlobal0X128 -\\n                info.feeGrowthOutside0X128;\\n            info.feeGrowthOutside1X128 =\\n                feeGrowthGlobal1X128 -\\n                info.feeGrowthOutside1X128;\\n            liquidityNet = info.liquidityNet;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x71dca8fb335ad2833b4a92c89168063d00deedb5490f68c9f8e4ac454c2502d6\",\"license\":\"BUSL-1.1\"},\"contracts/Uniswap/V4-Core/libraries/Position.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.20;\\n\\nimport {FullMath} from \\\"./FullMath.sol\\\";\\nimport {FixedPoint128} from \\\"./FixedPoint128.sol\\\";\\n\\n/// @title Position\\n/// @notice Positions represent an owner address' liquidity between a lower and upper tick boundary\\n/// @dev Positions store additional state for tracking fees owed to the position\\nlibrary Position {\\n    /// @notice Cannot update a position with no liquidity\\n    error CannotUpdateEmptyPosition();\\n\\n    // info stored for each user's position\\n    struct Info {\\n        // the amount of liquidity owned by this position\\n        uint128 liquidity;\\n        // fee growth per unit of liquidity as of the last update to liquidity or fees owed\\n        uint256 feeGrowthInside0LastX128;\\n        uint256 feeGrowthInside1LastX128;\\n    }\\n\\n    /// @notice Returns the Info struct of a position, given an owner and position boundaries\\n    /// @param self The mapping containing all user positions\\n    /// @param owner The address of the position owner\\n    /// @param tickLower The lower tick boundary of the position\\n    /// @param tickUpper The upper tick boundary of the position\\n    /// @return position The position info struct of the given owners' position\\n    function get(mapping(bytes32 => Info) storage self, address owner, int24 tickLower, int24 tickUpper)\\n        internal\\n        view\\n        returns (Position.Info storage position)\\n    {\\n        position = self[keccak256(abi.encodePacked(owner, tickLower, tickUpper))];\\n    }\\n\\n    /// @notice Credits accumulated fees to a user's position\\n    /// @param self The individual position to update\\n    /// @param liquidityDelta The change in pool liquidity as a result of the position update\\n    /// @param feeGrowthInside0X128 The all-time fee growth in currency0, per unit of liquidity, inside the position's tick boundaries\\n    /// @param feeGrowthInside1X128 The all-time fee growth in currency1, per unit of liquidity, inside the position's tick boundaries\\n    /// @return feesOwed0 The amount of currency0 owed to the position owner\\n    /// @return feesOwed1 The amount of currency1 owed to the position owner\\n    function update(\\n        Info storage self,\\n        int128 liquidityDelta,\\n        uint256 feeGrowthInside0X128,\\n        uint256 feeGrowthInside1X128\\n    ) internal returns (uint256 feesOwed0, uint256 feesOwed1) {\\n        Info memory _self = self;\\n\\n        uint128 liquidityNext;\\n        if (liquidityDelta == 0) {\\n            if (_self.liquidity == 0) revert CannotUpdateEmptyPosition(); // disallow pokes for 0 liquidity positions\\n            liquidityNext = _self.liquidity;\\n        } else {\\n            liquidityNext = liquidityDelta < 0\\n                ? _self.liquidity - uint128(-liquidityDelta)\\n                : _self.liquidity + uint128(liquidityDelta);\\n        }\\n\\n        // calculate accumulated fees. overflow in the subtraction of fee growth is expected\\n        unchecked {\\n            feesOwed0 = FullMath.mulDiv(\\n                feeGrowthInside0X128 - _self.feeGrowthInside0LastX128, _self.liquidity, FixedPoint128.Q128\\n            );\\n            feesOwed1 = FullMath.mulDiv(\\n                feeGrowthInside1X128 - _self.feeGrowthInside1LastX128, _self.liquidity, FixedPoint128.Q128\\n            );\\n        }\\n\\n        // update the position\\n        if (liquidityDelta != 0) self.liquidity = liquidityNext;\\n        self.feeGrowthInside0LastX128 = feeGrowthInside0X128;\\n        self.feeGrowthInside1LastX128 = feeGrowthInside1X128;\\n    }\\n}\\n\",\"keccak256\":\"0x1319e4c172e31427c3b3521dd3c9c9c3949da22e25c9919ae57c47a8c9328e43\",\"license\":\"BUSL-1.1\"},\"contracts/Uniswap/V4-Core/libraries/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\n/// @title Safe casting methods\\n/// @notice Contains methods for safely casting between types\\nlibrary SafeCast {\\n    error SafeCastOverflow();\\n\\n    /// @notice Cast a uint256 to a uint160, revert on overflow\\n    /// @param y The uint256 to be downcasted\\n    /// @return z The downcasted integer, now type uint160\\n    function toUint160(uint256 y) internal pure returns (uint160 z) {\\n        z = uint160(y);\\n        if (z != y) revert SafeCastOverflow();\\n    }\\n\\n    /// @notice Cast a int256 to a int128, revert on overflow or underflow\\n    /// @param y The int256 to be downcasted\\n    /// @return z The downcasted integer, now type int128\\n    function toInt128(int256 y) internal pure returns (int128 z) {\\n        z = int128(y);\\n        if (z != y) revert SafeCastOverflow();\\n    }\\n\\n    /// @notice Cast a uint256 to a int256, revert on overflow\\n    /// @param y The uint256 to be casted\\n    /// @return z The casted integer, now type int256\\n    function toInt256(uint256 y) internal pure returns (int256 z) {\\n        if (y > uint256(type(int256).max)) revert SafeCastOverflow();\\n        z = int256(y);\\n    }\\n\\n    /// @notice Cast a uint256 to a int128, revert on overflow\\n    /// @param y The uint256 to be downcasted\\n    /// @return z The downcasted integer, now type int128\\n    function toInt128(uint256 y) internal pure returns (int128 z) {\\n        if (y > uint128(type(int128).max)) revert SafeCastOverflow();\\n        z = int128(int256(y));\\n    }\\n}\\n\",\"keccak256\":\"0x197985a64d2ccf38a5e6a80cf70dc345594cc7296a2364b7447e553966ed89dc\",\"license\":\"GPL-2.0-or-later\"},\"contracts/Uniswap/V4-Core/libraries/SqrtPriceMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {SafeCast} from \\\"./SafeCast.sol\\\";\\n\\nimport {FullMath} from \\\"./FullMath.sol\\\";\\nimport {UnsafeMath} from \\\"./UnsafeMath.sol\\\";\\nimport {FixedPoint96} from \\\"./FixedPoint96.sol\\\";\\n\\n/// @title Functions based on Q64.96 sqrt price and liquidity\\n/// @notice Contains the math that uses square root of price as a Q64.96 and liquidity to compute deltas\\nlibrary SqrtPriceMath {\\n    using SafeCast for uint256;\\n\\n    error InvalidPriceOrLiquidity();\\n    error InvalidPrice();\\n    error NotEnoughLiquidity();\\n    error PriceOverflow();\\n\\n    /// @notice Gets the next sqrt price given a delta of currency0\\n    /// @dev Always rounds up, because in the exact output case (increasing price) we need to move the price at least\\n    /// far enough to get the desired output amount, and in the exact input case (decreasing price) we need to move the\\n    /// price less in order to not send too much output.\\n    /// The most precise formula for this is liquidity * sqrtPX96 / (liquidity +- amount * sqrtPX96),\\n    /// if this is impossible because of overflow, we calculate liquidity / (liquidity / sqrtPX96 +- amount).\\n    /// @param sqrtPX96 The starting price, i.e. before accounting for the currency0 delta\\n    /// @param liquidity The amount of usable liquidity\\n    /// @param amount How much of currency0 to add or remove from virtual reserves\\n    /// @param add Whether to add or remove the amount of currency0\\n    /// @return The price after adding or removing amount, depending on add\\n    function getNextSqrtPriceFromAmount0RoundingUp(uint160 sqrtPX96, uint128 liquidity, uint256 amount, bool add)\\n        internal\\n        pure\\n        returns (uint160)\\n    {\\n        // we short circuit amount == 0 because the result is otherwise not guaranteed to equal the input price\\n        if (amount == 0) return sqrtPX96;\\n        uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;\\n\\n        if (add) {\\n            unchecked {\\n                uint256 product = amount * sqrtPX96;\\n                if (product / amount == sqrtPX96) {\\n                    uint256 denominator = numerator1 + product;\\n                    if (denominator >= numerator1) {\\n                        // always fits in 160 bits\\n                        return uint160(FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator));\\n                    }\\n                }\\n            }\\n            // denominator is checked for overflow\\n            return uint160(UnsafeMath.divRoundingUp(numerator1, (numerator1 / sqrtPX96) + amount));\\n        } else {\\n            unchecked {\\n                uint256 product = amount * sqrtPX96;\\n                // if the product overflows, we know the denominator underflows\\n                // in addition, we must check that the denominator does not underflow\\n                if (product / amount != sqrtPX96 || numerator1 <= product) revert PriceOverflow();\\n                uint256 denominator = numerator1 - product;\\n                return FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator).toUint160();\\n            }\\n        }\\n    }\\n\\n    /// @notice Gets the next sqrt price given a delta of currency1\\n    /// @dev Always rounds down, because in the exact output case (decreasing price) we need to move the price at least\\n    /// far enough to get the desired output amount, and in the exact input case (increasing price) we need to move the\\n    /// price less in order to not send too much output.\\n    /// The formula we compute is within <1 wei of the lossless version: sqrtPX96 +- amount / liquidity\\n    /// @param sqrtPX96 The starting price, i.e., before accounting for the currency1 delta\\n    /// @param liquidity The amount of usable liquidity\\n    /// @param amount How much of currency1 to add, or remove, from virtual reserves\\n    /// @param add Whether to add, or remove, the amount of currency1\\n    /// @return The price after adding or removing `amount`\\n    function getNextSqrtPriceFromAmount1RoundingDown(uint160 sqrtPX96, uint128 liquidity, uint256 amount, bool add)\\n        internal\\n        pure\\n        returns (uint160)\\n    {\\n        // if we're adding (subtracting), rounding down requires rounding the quotient down (up)\\n        // in both cases, avoid a mulDiv for most inputs\\n        if (add) {\\n            uint256 quotient = (\\n                amount <= type(uint160).max\\n                    ? (amount << FixedPoint96.RESOLUTION) / liquidity\\n                    : FullMath.mulDiv(amount, FixedPoint96.Q96, liquidity)\\n            );\\n\\n            return (uint256(sqrtPX96) + quotient).toUint160();\\n        } else {\\n            uint256 quotient = (\\n                amount <= type(uint160).max\\n                    ? UnsafeMath.divRoundingUp(amount << FixedPoint96.RESOLUTION, liquidity)\\n                    : FullMath.mulDivRoundingUp(amount, FixedPoint96.Q96, liquidity)\\n            );\\n\\n            if (sqrtPX96 <= quotient) revert NotEnoughLiquidity();\\n            // always fits 160 bits\\n            unchecked {\\n                return uint160(sqrtPX96 - quotient);\\n            }\\n        }\\n    }\\n\\n    /// @notice Gets the next sqrt price given an input amount of currency0 or currency1\\n    /// @dev Throws if price or liquidity are 0, or if the next price is out of bounds\\n    /// @param sqrtPX96 The starting price, i.e., before accounting for the input amount\\n    /// @param liquidity The amount of usable liquidity\\n    /// @param amountIn How much of currency0, or currency1, is being swapped in\\n    /// @param zeroForOne Whether the amount in is currency0 or currency1\\n    /// @return sqrtQX96 The price after adding the input amount to currency0 or currency1\\n    function getNextSqrtPriceFromInput(uint160 sqrtPX96, uint128 liquidity, uint256 amountIn, bool zeroForOne)\\n        internal\\n        pure\\n        returns (uint160 sqrtQX96)\\n    {\\n        if (sqrtPX96 == 0 || liquidity == 0) revert InvalidPriceOrLiquidity();\\n\\n        // round to make sure that we don't pass the target price\\n        return zeroForOne\\n            ? getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountIn, true)\\n            : getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountIn, true);\\n    }\\n\\n    /// @notice Gets the next sqrt price given an output amount of currency0 or currency1\\n    /// @dev Throws if price or liquidity are 0 or the next price is out of bounds\\n    /// @param sqrtPX96 The starting price before accounting for the output amount\\n    /// @param liquidity The amount of usable liquidity\\n    /// @param amountOut How much of currency0, or currency1, is being swapped out\\n    /// @param zeroForOne Whether the amount out is currency0 or currency1\\n    /// @return sqrtQX96 The price after removing the output amount of currency0 or currency1\\n    function getNextSqrtPriceFromOutput(uint160 sqrtPX96, uint128 liquidity, uint256 amountOut, bool zeroForOne)\\n        internal\\n        pure\\n        returns (uint160 sqrtQX96)\\n    {\\n        if (sqrtPX96 == 0 || liquidity == 0) revert InvalidPriceOrLiquidity();\\n\\n        // round to make sure that we pass the target price\\n        return zeroForOne\\n            ? getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountOut, false)\\n            : getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountOut, false);\\n    }\\n\\n    /// @notice Gets the amount0 delta between two prices\\n    /// @dev Calculates liquidity / sqrt(lower) - liquidity / sqrt(upper),\\n    /// i.e. liquidity * (sqrt(upper) - sqrt(lower)) / (sqrt(upper) * sqrt(lower))\\n    /// @param sqrtRatioAX96 A sqrt price\\n    /// @param sqrtRatioBX96 Another sqrt price\\n    /// @param liquidity The amount of usable liquidity\\n    /// @param roundUp Whether to round the amount up or down\\n    /// @return amount0 Amount of currency0 required to cover a position of size liquidity between the two passed prices\\n    function getAmount0Delta(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity, bool roundUp)\\n        internal\\n        pure\\n        returns (uint256 amount0)\\n    {\\n        unchecked {\\n            if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n\\n            uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;\\n            uint256 numerator2 = sqrtRatioBX96 - sqrtRatioAX96;\\n\\n            if (sqrtRatioAX96 == 0) revert InvalidPrice();\\n\\n            return roundUp\\n                ? UnsafeMath.divRoundingUp(FullMath.mulDivRoundingUp(numerator1, numerator2, sqrtRatioBX96), sqrtRatioAX96)\\n                : FullMath.mulDiv(numerator1, numerator2, sqrtRatioBX96) / sqrtRatioAX96;\\n        }\\n    }\\n\\n    /// @notice Gets the amount1 delta between two prices\\n    /// @dev Calculates liquidity * (sqrt(upper) - sqrt(lower))\\n    /// @param sqrtRatioAX96 A sqrt price\\n    /// @param sqrtRatioBX96 Another sqrt price\\n    /// @param liquidity The amount of usable liquidity\\n    /// @param roundUp Whether to round the amount up, or down\\n    /// @return amount1 Amount of currency1 required to cover a position of size liquidity between the two passed prices\\n    function getAmount1Delta(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity, bool roundUp)\\n        internal\\n        pure\\n        returns (uint256 amount1)\\n    {\\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n\\n        return roundUp\\n            ? FullMath.mulDivRoundingUp(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96)\\n            : FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);\\n    }\\n\\n    /// @notice Helper that gets signed currency0 delta\\n    /// @param sqrtRatioAX96 A sqrt price\\n    /// @param sqrtRatioBX96 Another sqrt price\\n    /// @param liquidity The change in liquidity for which to compute the amount0 delta\\n    /// @return amount0 Amount of currency0 corresponding to the passed liquidityDelta between the two prices\\n    function getAmount0Delta(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, int128 liquidity)\\n        internal\\n        pure\\n        returns (int256 amount0)\\n    {\\n        unchecked {\\n            return liquidity < 0\\n                ? -getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()\\n                : getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();\\n        }\\n    }\\n\\n    /// @notice Helper that gets signed currency1 delta\\n    /// @param sqrtRatioAX96 A sqrt price\\n    /// @param sqrtRatioBX96 Another sqrt price\\n    /// @param liquidity The change in liquidity for which to compute the amount1 delta\\n    /// @return amount1 Amount of currency1 corresponding to the passed liquidityDelta between the two prices\\n    function getAmount1Delta(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, int128 liquidity)\\n        internal\\n        pure\\n        returns (int256 amount1)\\n    {\\n        unchecked {\\n            return liquidity < 0\\n                ? -getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()\\n                : getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe54bb39a96f98df7b8d36fade6b95bc866e138594b146ef0d4cee4e542170058\",\"license\":\"GPL-2.0-or-later\"},\"contracts/Uniswap/V4-Core/libraries/SwapMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {FullMath} from \\\"./FullMath.sol\\\";\\nimport {SqrtPriceMath} from \\\"./SqrtPriceMath.sol\\\";\\n\\n/// @title Computes the result of a swap within ticks\\n/// @notice Contains methods for computing the result of a swap within a single tick price range, i.e., a single tick.\\nlibrary SwapMath {\\n    /// @notice Computes the result of swapping some amount in, or amount out, given the parameters of the swap\\n    /// @dev The fee, plus the amount in, will never exceed the amount remaining if the swap's `amountSpecified` is positive\\n    /// @param sqrtRatioCurrentX96 The current sqrt price of the pool\\n    /// @param sqrtRatioTargetX96 The price that cannot be exceeded, from which the direction of the swap is inferred\\n    /// @param liquidity The usable liquidity\\n    /// @param amountRemaining How much input or output amount is remaining to be swapped in/out\\n    /// @param feePips The fee taken from the input amount, expressed in hundredths of a bip\\n    /// @return sqrtRatioNextX96 The price after swapping the amount in/out, not to exceed the price target\\n    /// @return amountIn The amount to be swapped in, of either currency0 or currency1, based on the direction of the swap\\n    /// @return amountOut The amount to be received, of either currency0 or currency1, based on the direction of the swap\\n    /// @return feeAmount The amount of input that will be taken as a fee\\n    function computeSwapStep(\\n        uint160 sqrtRatioCurrentX96,\\n        uint160 sqrtRatioTargetX96,\\n        uint128 liquidity,\\n        int256 amountRemaining,\\n        uint24 feePips\\n    ) internal pure returns (uint160 sqrtRatioNextX96, uint256 amountIn, uint256 amountOut, uint256 feeAmount) {\\n        unchecked {\\n            bool zeroForOne = sqrtRatioCurrentX96 >= sqrtRatioTargetX96;\\n            bool exactIn = amountRemaining >= 0;\\n\\n            if (exactIn) {\\n                uint256 amountRemainingLessFee = FullMath.mulDiv(uint256(amountRemaining), 1e6 - feePips, 1e6);\\n                amountIn = zeroForOne\\n                    ? SqrtPriceMath.getAmount0Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, true)\\n                    : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, true);\\n                if (amountRemainingLessFee >= amountIn) {\\n                    sqrtRatioNextX96 = sqrtRatioTargetX96;\\n                } else {\\n                    sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromInput(\\n                        sqrtRatioCurrentX96, liquidity, amountRemainingLessFee, zeroForOne\\n                    );\\n                }\\n            } else {\\n                amountOut = zeroForOne\\n                    ? SqrtPriceMath.getAmount1Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, false)\\n                    : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, false);\\n                if (uint256(-amountRemaining) >= amountOut) {\\n                    sqrtRatioNextX96 = sqrtRatioTargetX96;\\n                } else {\\n                    sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromOutput(\\n                        sqrtRatioCurrentX96, liquidity, uint256(-amountRemaining), zeroForOne\\n                    );\\n                }\\n            }\\n\\n            bool max = sqrtRatioTargetX96 == sqrtRatioNextX96;\\n\\n            // get the input/output amounts\\n            if (zeroForOne) {\\n                amountIn = max && exactIn\\n                    ? amountIn\\n                    : SqrtPriceMath.getAmount0Delta(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, true);\\n                amountOut = max && !exactIn\\n                    ? amountOut\\n                    : SqrtPriceMath.getAmount1Delta(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, false);\\n            } else {\\n                amountIn = max && exactIn\\n                    ? amountIn\\n                    : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioNextX96, liquidity, true);\\n                amountOut = max && !exactIn\\n                    ? amountOut\\n                    : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioNextX96, liquidity, false);\\n            }\\n\\n            // cap the output amount to not exceed the remaining output amount\\n            if (!exactIn && amountOut > uint256(-amountRemaining)) {\\n                amountOut = uint256(-amountRemaining);\\n            }\\n\\n            if (exactIn && sqrtRatioNextX96 != sqrtRatioTargetX96) {\\n                // we didn't reach the target, so take the remainder of the maximum input as fee\\n                feeAmount = uint256(amountRemaining) - amountIn;\\n            } else {\\n                feeAmount = FullMath.mulDivRoundingUp(amountIn, feePips, 1e6 - feePips);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xac5b75b36ff928e88cbec828bdc9db03e681cc3b337d5d7f6be9fd617b3fef7f\",\"license\":\"GPL-2.0-or-later\"},\"contracts/Uniswap/V4-Core/libraries/TickBitmap.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {BitMath} from \\\"./BitMath.sol\\\";\\n\\n/// @title Packed tick initialized state library\\n/// @notice Stores a packed mapping of tick index to its initialized state\\n/// @dev The mapping uses int16 for keys since ticks are represented as int24 and there are 256 (2^8) values per word.\\nlibrary TickBitmap {\\n    /// @notice Thrown when the tick is not enumerated by the tick spacing\\n    /// @param tick the invalid tick\\n    /// @param tickSpacing The tick spacing of the pool\\n    error TickMisaligned(int24 tick, int24 tickSpacing);\\n\\n    /// @notice Computes the position in the mapping where the initialized bit for a tick lives\\n    /// @param tick The tick for which to compute the position\\n    /// @return wordPos The key in the mapping containing the word in which the bit is stored\\n    /// @return bitPos The bit position in the word where the flag is stored\\n    function position(int24 tick) internal pure returns (int16 wordPos, uint8 bitPos) {\\n        unchecked {\\n            wordPos = int16(tick >> 8);\\n            bitPos = uint8(int8(tick % 256));\\n        }\\n    }\\n\\n    /// @notice Flips the initialized state for a given tick from false to true, or vice versa\\n    /// @param self The mapping in which to flip the tick\\n    /// @param tick The tick to flip\\n    /// @param tickSpacing The spacing between usable ticks\\n    function flipTick(mapping(int16 => uint256) storage self, int24 tick, int24 tickSpacing) internal {\\n        unchecked {\\n            if (tick % tickSpacing != 0) revert TickMisaligned(tick, tickSpacing); // ensure that the tick is spaced\\n            (int16 wordPos, uint8 bitPos) = position(tick / tickSpacing);\\n            uint256 mask = 1 << bitPos;\\n            self[wordPos] ^= mask;\\n        }\\n    }\\n\\n    /// @notice Returns the next initialized tick contained in the same word (or adjacent word) as the tick that is either\\n    /// to the left (less than or equal to) or right (greater than) of the given tick\\n    /// @param self The mapping in which to compute the next initialized tick\\n    /// @param tick The starting tick\\n    /// @param tickSpacing The spacing between usable ticks\\n    /// @param lte Whether to search for the next initialized tick to the left (less than or equal to the starting tick)\\n    /// @return next The next initialized or uninitialized tick up to 256 ticks away from the current tick\\n    /// @return initialized Whether the next tick is initialized, as the function only searches within up to 256 ticks\\n    function nextInitializedTickWithinOneWord(\\n        mapping(int16 => uint256) storage self,\\n        int24 tick,\\n        int24 tickSpacing,\\n        bool lte\\n    ) internal view returns (int24 next, bool initialized) {\\n        unchecked {\\n            int24 compressed = tick / tickSpacing;\\n            if (tick < 0 && tick % tickSpacing != 0) compressed--; // round towards negative infinity\\n\\n            if (lte) {\\n                (int16 wordPos, uint8 bitPos) = position(compressed);\\n                // all the 1s at or to the right of the current bitPos\\n                uint256 mask = (1 << bitPos) - 1 + (1 << bitPos);\\n                uint256 masked = self[wordPos] & mask;\\n\\n                // if there are no initialized ticks to the right of or at the current tick, return rightmost in the word\\n                initialized = masked != 0;\\n                // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick\\n                next = initialized\\n                    ? (compressed - int24(uint24(bitPos - BitMath.mostSignificantBit(masked)))) * tickSpacing\\n                    : (compressed - int24(uint24(bitPos))) * tickSpacing;\\n            } else {\\n                // start from the word of the next tick, since the current tick state doesn't matter\\n                (int16 wordPos, uint8 bitPos) = position(compressed + 1);\\n                // all the 1s at or to the left of the bitPos\\n                uint256 mask = ~((1 << bitPos) - 1);\\n                uint256 masked = self[wordPos] & mask;\\n\\n                // if there are no initialized ticks to the left of the current tick, return leftmost in the word\\n                initialized = masked != 0;\\n                // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick\\n                next = initialized\\n                    ? (compressed + 1 + int24(uint24(BitMath.leastSignificantBit(masked) - bitPos))) * tickSpacing\\n                    : (compressed + 1 + int24(uint24(type(uint8).max - bitPos))) * tickSpacing;\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9998b760bc3d948912bf43d7c556e2ccff16ed800b51fd59e2bb179517ad909d\",\"license\":\"GPL-2.0-or-later\"},\"contracts/Uniswap/V4-Core/libraries/TickMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\n/// @title Math library for computing sqrt prices from ticks and vice versa\\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\\n/// prices between 2**-128 and 2**128\\nlibrary TickMath {\\n    /// @notice Thrown when the tick passed to #getSqrtRatioAtTick is not between MIN_TICK and MAX_TICK\\n    error InvalidTick();\\n    /// @notice Thrown when the ratio passed to #getTickAtSqrtRatio does not correspond to a price between MIN_TICK and MAX_TICK\\n    error InvalidSqrtRatio();\\n\\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\\n    int24 internal constant MIN_TICK = -887272;\\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\\n    int24 internal constant MAX_TICK = -MIN_TICK;\\n\\n    /// @dev The minimum tick spacing value drawn from the range of type int16 that is greater than 0, i.e. min from the range [1, 32767]\\n    int24 internal constant MIN_TICK_SPACING = 1;\\n    /// @dev The maximum tick spacing value drawn from the range of type int16, i.e. max from the range [1, 32767]\\n    int24 internal constant MAX_TICK_SPACING = type(int16).max;\\n\\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\\n\\n    /// @notice Given a tickSpacing, compute the maximum usable tick\\n    function maxUsableTick(int24 tickSpacing) internal pure returns (int24) {\\n        unchecked {\\n            return (MAX_TICK / tickSpacing) * tickSpacing;\\n        }\\n    }\\n\\n    /// @notice Given a tickSpacing, compute the minimum usable tick\\n    function minUsableTick(int24 tickSpacing) internal pure returns (int24) {\\n        unchecked {\\n            return (MIN_TICK / tickSpacing) * tickSpacing;\\n        }\\n    }\\n\\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\\n    /// @dev Throws if |tick| > max tick\\n    /// @param tick The input tick for the above formula\\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (currency1/currency0)\\n    /// at the given tick\\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\\n        unchecked {\\n            uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\\n            if (absTick > uint256(int256(MAX_TICK))) revert InvalidTick();\\n\\n            uint256 ratio =\\n                absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\\n            if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\\n            if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\\n            if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\\n            if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\\n            if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\\n            if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\\n            if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\\n            if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\\n            if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\\n            if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\\n            if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\\n            if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\\n            if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\\n            if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\\n            if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\\n            if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\\n            if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\\n            if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\\n            if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\\n\\n            if (tick > 0) ratio = type(uint256).max / ratio;\\n\\n            // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\\n            // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\\n            // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\\n            sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\\n        }\\n    }\\n\\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\\n    /// ever return.\\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\\n        unchecked {\\n            // second inequality must be < because the price can never reach the price at the max tick\\n            if (sqrtPriceX96 < MIN_SQRT_RATIO || sqrtPriceX96 >= MAX_SQRT_RATIO) revert InvalidSqrtRatio();\\n            uint256 ratio = uint256(sqrtPriceX96) << 32;\\n\\n            uint256 r = ratio;\\n            uint256 msb = 0;\\n\\n            assembly {\\n                let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(5, gt(r, 0xFFFFFFFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(4, gt(r, 0xFFFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(3, gt(r, 0xFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(2, gt(r, 0xF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(1, gt(r, 0x3))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := gt(r, 0x1)\\n                msb := or(msb, f)\\n            }\\n\\n            if (msb >= 128) r = ratio >> (msb - 127);\\n            else r = ratio << (127 - msb);\\n\\n            int256 log_2 = (int256(msb) - 128) << 64;\\n\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(63, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(62, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(61, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(60, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(59, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(58, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(57, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(56, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(55, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(54, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(53, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(52, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(51, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(50, f))\\n            }\\n\\n            int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\\n\\n            int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\\n            int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\\n\\n            tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc7e49d8f58765e4d586f943b782f3b11b5330864ffc273494420f268dc3b34a8\",\"license\":\"GPL-2.0-or-later\"},\"contracts/Uniswap/V4-Core/libraries/UnsafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\n/// @title Math functions that do not check inputs or outputs\\n/// @notice Contains methods that perform common math functions but do not do any overflow or underflow checks\\nlibrary UnsafeMath {\\n    /// @notice Returns ceil(x / y)\\n    /// @dev division by 0 has unspecified behavior, and must be checked externally\\n    /// @param x The dividend\\n    /// @param y The divisor\\n    /// @return z The quotient, ceil(x / y)\\n    function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        unchecked {\\n            assembly {\\n                z := add(div(x, y), gt(mod(x, y), 0))\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2a8cb75af05f8557b698b089a0ab19e24279fffb7e87cddf5794404c7eaf1c69\",\"license\":\"GPL-2.0-or-later\"},\"contracts/Uniswap/V4-Core/types/BalanceDelta.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\ntype BalanceDelta is int256;\\n\\nusing {add as +, sub as -, eq as ==} for BalanceDelta global;\\nusing BalanceDeltaLibrary for BalanceDelta global;\\n\\nfunction toBalanceDelta(int128 _amount0, int128 _amount1) pure returns (BalanceDelta balanceDelta) {\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n        balanceDelta :=\\n            or(shl(128, _amount0), and(0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff, _amount1))\\n    }\\n}\\n\\nfunction add(BalanceDelta a, BalanceDelta b) pure returns (BalanceDelta) {\\n    return toBalanceDelta(a.amount0() + b.amount0(), a.amount1() + b.amount1());\\n}\\n\\nfunction sub(BalanceDelta a, BalanceDelta b) pure returns (BalanceDelta) {\\n    return toBalanceDelta(a.amount0() - b.amount0(), a.amount1() - b.amount1());\\n}\\n\\nfunction eq(BalanceDelta a, BalanceDelta b) pure returns (bool) {\\n    return a.amount0() == b.amount0() && a.amount1() == b.amount1();\\n}\\n\\nlibrary BalanceDeltaLibrary {\\n    // Sentinel return value used to signify that a NoOp occurred.\\n    BalanceDelta public constant MAXIMUM_DELTA = BalanceDelta.wrap(int256(type(uint256).max));\\n\\n    function amount0(BalanceDelta balanceDelta) internal pure returns (int128 _amount0) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            _amount0 := shr(128, balanceDelta)\\n        }\\n    }\\n\\n    function amount1(BalanceDelta balanceDelta) internal pure returns (int128 _amount1) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            _amount1 := balanceDelta\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xb348472d6a9050f8e162173712911896882939a0cd7316db386ced5182716845\",\"license\":\"MIT\"},\"contracts/Uniswap/V4-Core/types/Currency.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport {IERC20Minimal} from \\\"../interfaces/external/IERC20Minimal.sol\\\";\\n\\ntype Currency is address;\\n\\nusing {greaterThan as >, lessThan as <, greaterThanOrEqualTo as >=, equals as ==} for Currency global;\\n\\nfunction equals(Currency currency, Currency other) pure returns (bool) {\\n    return Currency.unwrap(currency) == Currency.unwrap(other);\\n}\\n\\nfunction greaterThan(Currency currency, Currency other) pure returns (bool) {\\n    return Currency.unwrap(currency) > Currency.unwrap(other);\\n}\\n\\nfunction lessThan(Currency currency, Currency other) pure returns (bool) {\\n    return Currency.unwrap(currency) < Currency.unwrap(other);\\n}\\n\\nfunction greaterThanOrEqualTo(Currency currency, Currency other) pure returns (bool) {\\n    return Currency.unwrap(currency) >= Currency.unwrap(other);\\n}\\n\\n/// @title CurrencyLibrary\\n/// @dev This library allows for transferring and holding native tokens and ERC20 tokens\\nlibrary CurrencyLibrary {\\n    using CurrencyLibrary for Currency;\\n\\n    /// @notice Thrown when a native transfer fails\\n    error NativeTransferFailed();\\n\\n    /// @notice Thrown when an ERC20 transfer fails\\n    error ERC20TransferFailed();\\n\\n    Currency public constant NATIVE = Currency.wrap(address(0));\\n\\n    function transfer(Currency currency, address to, uint256 amount) internal {\\n        // implementation from\\n        // https://github.com/transmissions11/solmate/blob/e8f96f25d48fe702117ce76c79228ca4f20206cb/src/utils/SafeTransferLib.sol\\n\\n        bool success;\\n        if (currency.isNative()) {\\n            assembly {\\n                // Transfer the ETH and store if it succeeded or not.\\n                success := call(gas(), to, amount, 0, 0, 0, 0)\\n            }\\n\\n            if (!success) revert NativeTransferFailed();\\n        } else {\\n            assembly {\\n                // We'll write our calldata to this slot below, but restore it later.\\n                let memPointer := mload(0x40)\\n\\n                // Write the abi-encoded calldata into memory, beginning with the function selector.\\n                mstore(0, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n                mstore(4, to) // Append the \\\"to\\\" argument.\\n                mstore(36, amount) // Append the \\\"amount\\\" argument.\\n\\n                success :=\\n                    and(\\n                        // Set success to whether the call reverted, if not we check it either\\n                        // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                        or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                        // We use 68 because that's the total length of our calldata (4 + 32 * 2)\\n                        // Counterintuitively, this call() must be positioned after the or() in the\\n                        // surrounding and() because and() evaluates its arguments from right to left.\\n                        call(gas(), currency, 0, 0, 68, 0, 32)\\n                    )\\n\\n                mstore(0x60, 0) // Restore the zero slot to zero.\\n                mstore(0x40, memPointer) // Restore the memPointer.\\n            }\\n\\n            if (!success) revert ERC20TransferFailed();\\n        }\\n    }\\n\\n    function balanceOfSelf(Currency currency) internal view returns (uint256) {\\n        if (currency.isNative()) {\\n            return address(this).balance;\\n        } else {\\n            return IERC20Minimal(Currency.unwrap(currency)).balanceOf(address(this));\\n        }\\n    }\\n\\n    function balanceOf(Currency currency, address owner) internal view returns (uint256) {\\n        if (currency.isNative()) {\\n            return owner.balance;\\n        } else {\\n            return IERC20Minimal(Currency.unwrap(currency)).balanceOf(owner);\\n        }\\n    }\\n\\n    function isNative(Currency currency) internal pure returns (bool) {\\n        return Currency.unwrap(currency) == Currency.unwrap(NATIVE);\\n    }\\n\\n    function toId(Currency currency) internal pure returns (uint256) {\\n        return uint160(Currency.unwrap(currency));\\n    }\\n\\n    function fromId(uint256 id) internal pure returns (Currency) {\\n        return Currency.wrap(address(uint160(id)));\\n    }\\n}\\n\",\"keccak256\":\"0xb1395e2817b604745bf6cd41821aafeaaa252caafe45133e54f02d6f6be13d2b\",\"license\":\"MIT\"},\"contracts/Uniswap/V4-Core/types/PoolId.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport {PoolKey} from \\\"./PoolKey.sol\\\";\\n\\ntype PoolId is bytes32;\\n\\n/// @notice Library for computing the ID of a pool\\nlibrary PoolIdLibrary {\\n    function toId(PoolKey memory poolKey) internal pure returns (PoolId) {\\n        return PoolId.wrap(keccak256(abi.encode(poolKey)));\\n    }\\n}\\n\",\"keccak256\":\"0x2928a23cdf4c3dd05fafd3094020723954150901c6935a40fbb8e3cbc1e0ebe3\",\"license\":\"MIT\"},\"contracts/Uniswap/V4-Core/types/PoolKey.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport {Currency} from \\\"./Currency.sol\\\";\\nimport {IHooks} from \\\"../interfaces/IHooks.sol\\\";\\n\\n/// @notice Returns the key for identifying a pool\\nstruct PoolKey {\\n    /// @notice The lower currency of the pool, sorted numerically\\n    Currency currency0;\\n    /// @notice The higher currency of the pool, sorted numerically\\n    Currency currency1;\\n    /// @notice The pool swap fee, capped at 1_000_000. The upper 4 bits determine if the hook sets any fees.\\n    uint24 fee;\\n    /// @notice Ticks that involve positions must be a multiple of tick spacing\\n    int24 tickSpacing;\\n    /// @notice The hooks of the pool\\n    IHooks hooks;\\n}\\n\",\"keccak256\":\"0xef7421713157a514d757863e99c2d094a6fac1dcbae602ac0eb47eda2d651a6d\",\"license\":\"MIT\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\nlibrary console {\\n    address constant CONSOLE_ADDRESS =\\n        0x000000000000000000636F6e736F6c652e6c6f67;\\n\\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            pop(\\n                staticcall(\\n                    gas(),\\n                    consoleAddress,\\n                    add(payload, 32),\\n                    mload(payload),\\n                    0,\\n                    0\\n                )\\n            )\\n        }\\n    }\\n\\n    function _castToPure(\\n      function(bytes memory) internal view fnIn\\n    ) internal pure returns (function(bytes memory) pure fnOut) {\\n        assembly {\\n            fnOut := fnIn\\n        }\\n    }\\n\\n    function _sendLogPayload(bytes memory payload) internal pure {\\n        _castToPure(_sendLogPayloadImplementation)(payload);\\n    }\\n\\n    function log() internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n    }\\n    function logInt(int256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n    }\\n\\n    function logUint(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function logString(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function logBool(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function logAddress(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function logBytes(bytes memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n    }\\n\\n    function logBytes1(bytes1 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n    }\\n\\n    function logBytes2(bytes2 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n    }\\n\\n    function logBytes3(bytes3 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n    }\\n\\n    function logBytes4(bytes4 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n    }\\n\\n    function logBytes5(bytes5 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n    }\\n\\n    function logBytes6(bytes6 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n    }\\n\\n    function logBytes7(bytes7 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n    }\\n\\n    function logBytes8(bytes8 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n    }\\n\\n    function logBytes9(bytes9 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n    }\\n\\n    function logBytes10(bytes10 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n    }\\n\\n    function logBytes11(bytes11 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n    }\\n\\n    function logBytes12(bytes12 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n    }\\n\\n    function logBytes13(bytes13 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n    }\\n\\n    function logBytes14(bytes14 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n    }\\n\\n    function logBytes15(bytes15 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n    }\\n\\n    function logBytes16(bytes16 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n    }\\n\\n    function logBytes17(bytes17 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n    }\\n\\n    function logBytes18(bytes18 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n    }\\n\\n    function logBytes19(bytes19 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n    }\\n\\n    function logBytes20(bytes20 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n    }\\n\\n    function logBytes21(bytes21 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n    }\\n\\n    function logBytes22(bytes22 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n    }\\n\\n    function logBytes23(bytes23 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n    }\\n\\n    function logBytes24(bytes24 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n    }\\n\\n    function logBytes25(bytes25 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n    }\\n\\n    function logBytes26(bytes26 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n    }\\n\\n    function logBytes27(bytes27 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n    }\\n\\n    function logBytes28(bytes28 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n    }\\n\\n    function logBytes29(bytes29 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n    }\\n\\n    function logBytes30(bytes30 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n    }\\n\\n    function logBytes31(bytes31 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n    }\\n\\n    function logBytes32(bytes32 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n    }\\n\\n    function log(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function log(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function log(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function log(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function log(uint256 p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n}\\n\",\"keccak256\":\"0x7434453e6d3b7d0e5d0eb7846ffdbc27f0ccf3b163591263739b628074dc103a\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60806040525f80546001600160a01b031916731f02fa4f142e0727cc3f2ec84433ab513f977657178155600255348015610037575f80fd5b506040516107133803806107138339810160408190526100569161007b565b600180546001600160a01b0319166001600160a01b03929092169190911790556100a8565b5f6020828403121561008b575f80fd5b81516001600160a01b03811681146100a1575f80fd5b9392505050565b61065e806100b55f395ff3fe608060405260043610610049575f3560e01c80633dbcc8d11461004d5780634deefab21461007557806356d5d475146100a0578063c3fe3e28146100b5578063de523cf3146100d4575b5f80fd5b348015610058575f80fd5b5061006260025481565b6040519081526020015b60405180910390f35b348015610080575f80fd5b505f54610093906001600160a01b031681565b60405161006c91906103bc565b6100b36100ae3660046103d0565b6100f0565b005b3480156100c0575f80fd5b50600154610093906001600160a01b031681565b3480156100df575f80fd5b505f546001600160a01b0316610093565b60028054905f6100ff83610459565b909155505f90508080610114848601866104a8565b925092509250815f036101af575f8082806020019051810190610137919061056d565b60015460405163eeb23ac560e01b81526001600160a01b038981166004830152808516602483015260448201849052939550919350919091169063eeb23ac5906064015b5f604051808303815f87803b158015610192575f80fd5b505af11580156101a4573d5f803e3d5ffd5b5050505050506103b3565b81600103610219576001546040516302389a2960e41b81526001600160a01b0390911690632389a290906101e79086906004016103bc565b5f604051808303815f87803b1580156101fe575f80fd5b505af1158015610210573d5f803e3d5ffd5b505050506103b3565b8160020361025157600154604051634e1f10d760e11b81526001600160a01b0390911690639c3e21ae906101e79086906004016103bc565b600382146103b357816004036102bf575f80828060200190518101906102779190610599565b600154604051630748f02d60e21b81526001600160a01b0389811660048301526024820185905283151560448301529395509193509190911690631d23c0b49060640161017b565b8160050361035d575f80828060200190518101906102dd91906105cb565b600154604051637ce7c83360e11b81529294509092506001600160a01b03169063f9cf906690610315908890869086906004016105ee565b6020604051808303815f875af1158015610331573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906103559190610611565b5050506103b3565b816006036103b3575f808280602001905181019061037b91906105cb565b60015460405163637cfb2160e11b81529294509092506001600160a01b03169063c6f9f64290610315908890869086906004016105ee565b50505050505050565b6001600160a01b0391909116815260200190565b5f805f80606085870312156103e3575f80fd5b843563ffffffff811681146103f6575f80fd5b93506020850135925060408501356001600160401b0380821115610418575f80fd5b818701915087601f83011261042b575f80fd5b813581811115610439575f80fd5b88602082850101111561044a575f80fd5b95989497505060200194505050565b5f6001820161047657634e487b7160e01b5f52601160045260245ffd5b5060010190565b6001600160a01b0381168114610491575f80fd5b50565b634e487b7160e01b5f52604160045260245ffd5b5f805f606084860312156104ba575f80fd5b83356104c58161047d565b92506020840135915060408401356001600160401b03808211156104e7575f80fd5b818601915086601f8301126104fa575f80fd5b81358181111561050c5761050c610494565b604051601f8201601f19908116603f0116810190838211818310171561053457610534610494565b8160405282815289602084870101111561054c575f80fd5b826020860160208301375f6020848301015280955050505050509250925092565b5f806040838503121561057e575f80fd5b82516105898161047d565b6020939093015192949293505050565b5f80604083850312156105aa575f80fd5b82519150602083015180151581146105c0575f80fd5b809150509250929050565b5f80604083850312156105dc575f80fd5b8251915060208301516105c08161047d565b6001600160a01b0393841681526020810192909252909116604082015260600190565b5f60208284031215610621575f80fd5b505191905056fea2646970667358221220ac10998f9b82e884346e8532335b12363ed67ed3ff251f458fc28a596b7202f464736f6c63430008180033",
  "deployedBytecode": "0x608060405260043610610049575f3560e01c80633dbcc8d11461004d5780634deefab21461007557806356d5d475146100a0578063c3fe3e28146100b5578063de523cf3146100d4575b5f80fd5b348015610058575f80fd5b5061006260025481565b6040519081526020015b60405180910390f35b348015610080575f80fd5b505f54610093906001600160a01b031681565b60405161006c91906103bc565b6100b36100ae3660046103d0565b6100f0565b005b3480156100c0575f80fd5b50600154610093906001600160a01b031681565b3480156100df575f80fd5b505f546001600160a01b0316610093565b60028054905f6100ff83610459565b909155505f90508080610114848601866104a8565b925092509250815f036101af575f8082806020019051810190610137919061056d565b60015460405163eeb23ac560e01b81526001600160a01b038981166004830152808516602483015260448201849052939550919350919091169063eeb23ac5906064015b5f604051808303815f87803b158015610192575f80fd5b505af11580156101a4573d5f803e3d5ffd5b5050505050506103b3565b81600103610219576001546040516302389a2960e41b81526001600160a01b0390911690632389a290906101e79086906004016103bc565b5f604051808303815f87803b1580156101fe575f80fd5b505af1158015610210573d5f803e3d5ffd5b505050506103b3565b8160020361025157600154604051634e1f10d760e11b81526001600160a01b0390911690639c3e21ae906101e79086906004016103bc565b600382146103b357816004036102bf575f80828060200190518101906102779190610599565b600154604051630748f02d60e21b81526001600160a01b0389811660048301526024820185905283151560448301529395509193509190911690631d23c0b49060640161017b565b8160050361035d575f80828060200190518101906102dd91906105cb565b600154604051637ce7c83360e11b81529294509092506001600160a01b03169063f9cf906690610315908890869086906004016105ee565b6020604051808303815f875af1158015610331573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906103559190610611565b5050506103b3565b816006036103b3575f808280602001905181019061037b91906105cb565b60015460405163637cfb2160e11b81529294509092506001600160a01b03169063c6f9f64290610315908890869086906004016105ee565b50505050505050565b6001600160a01b0391909116815260200190565b5f805f80606085870312156103e3575f80fd5b843563ffffffff811681146103f6575f80fd5b93506020850135925060408501356001600160401b0380821115610418575f80fd5b818701915087601f83011261042b575f80fd5b813581811115610439575f80fd5b88602082850101111561044a575f80fd5b95989497505060200194505050565b5f6001820161047657634e487b7160e01b5f52601160045260245ffd5b5060010190565b6001600160a01b0381168114610491575f80fd5b50565b634e487b7160e01b5f52604160045260245ffd5b5f805f606084860312156104ba575f80fd5b83356104c58161047d565b92506020840135915060408401356001600160401b03808211156104e7575f80fd5b818601915086601f8301126104fa575f80fd5b81358181111561050c5761050c610494565b604051601f8201601f19908116603f0116810190838211818310171561053457610534610494565b8160405282815289602084870101111561054c575f80fd5b826020860160208301375f6020848301015280955050505050509250925092565b5f806040838503121561057e575f80fd5b82516105898161047d565b6020939093015192949293505050565b5f80604083850312156105aa575f80fd5b82519150602083015180151581146105c0575f80fd5b809150509250929050565b5f80604083850312156105dc575f80fd5b8251915060208301516105c08161047d565b6001600160a01b0393841681526020810192909252909116604082015260600190565b5f60208284031215610621575f80fd5b505191905056fea2646970667358221220ac10998f9b82e884346e8532335b12363ed67ed3ff251f458fc28a596b7202f464736f6c63430008180033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 6332,
        "contract": "contracts/TokenTown/LukeReceiver.sol:LukeRecieve",
        "label": "ism",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 6335,
        "contract": "contracts/TokenTown/LukeReceiver.sol:LukeRecieve",
        "label": "game",
        "offset": 0,
        "slot": "1",
        "type": "t_contract(Game)5743"
      },
      {
        "astId": 6350,
        "contract": "contracts/TokenTown/LukeReceiver.sol:LukeRecieve",
        "label": "messageCount",
        "offset": 0,
        "slot": "2",
        "type": "t_uint256"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_contract(Game)5743": {
        "encoding": "inplace",
        "label": "contract Game",
        "numberOfBytes": "20"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}